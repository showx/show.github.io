---
layout: post
title: 闲谈码
date: 2011-03-08 12:30
author: admin
comments: true
categories: []
---
数值在计算机中表示形式为机器数,计算机只能识别0和1,使用的是二进制,而在日常生活中人们使用的是十进制,"正如亚里士多德早就指出的那样,今天十进制的广泛采用,只不过我们绝大多数人生来具有10个手指头这个解剖学事实的结果.尽管在历史上手指计数(5,10进制)的实践要比二或三进制计数出现的晚."(摘自<<数学发展史>>有空大家可以看看哦~,很有意思的).为了能方便的与二进制转换,就使用了十六进制(2 4)和八进制(23).下面进入正题.

数值有正负之分,计算机就用一个数的最高位存放符号(0为正,1为负).这就是机器数的原码了.假设机器能处理的位数为8.即字长为1byte,原码能表示数值的范围为

(-127~-0 +0~127)共256个.

  有了数值的表示方法就可以对数进行算术运算.但是很快就发现用带符号位的原码进行乘除运算时结果正确,而在加减运算的时候就出现了问题,如下: 假设字长为8bits

( 1 ) 10-  ( 1 )10 =  ( 1 )10 + ( -1 )10 =  ( 0 )10

(00000001)原 + (10000001)原 = (10000010)原 = ( -2 ) 显然不正确.

  因为在两个整数的加法运算中是没有问题的,于是就发现问题出现在带符号位的负数身上,对除符号位外的其余各位逐位取反就产生了反码.反码的取值空间和原码相同且一一对应. 下面是反码的减法运算:

 ( 1 )10 -  ( 1 ) 10=  ( 1 ) 10+ ( -1 ) 10=  ( 0 )10

 (00000001) 反+ (11111110)反 =  (11111111)反 =  ( -0 )  有问题.

( 1 )10 -  ( 2)10 =  ( 1 )10 + ( -2 )10 =  ( -1 )10

(00000001) 反+ (11111101)反 =  (11111110)反 =  ( -1 ) 正确

问题出现在(+0)和(-0)上,在人们的计算概念中零是没有正负之分的.(印度人首先将零作为标记并放入运算之中,包含有零号的印度数学和十进制计数对人类文明的贡献极大).

于是就引入了补码概念. 负数的补码就是对反码加一,而正数不变,正数的原码反码补码是一样的.在补码中用(-128)代替了(-0),所以补码的表示范围为:

(-128~0~127)共256个.

注意:(-128)没有相对应的原码和反码, (-128) = (10000000)  补码的加减运算如下:

( 1 ) 10-  ( 1 ) 10=  ( 1 )10 + ( -1 )10 =  ( 0 )10

(00000001)补 + (11111111)补 =  (00000000)补 = ( 0 ) 正确

( 1 ) 10-  ( 2) 10=  ( 1 )10 + ( -2 )10 =  ( -1 )10

(00000001) 补+ (11111110) 补=  (11111111)补 = ( -1 )  正确

   所以补码的设计目的是:

     ⑴使符号位能与有效值部分一起参加运算,从而简化运算规则.

⑵使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计

  所有这些转换都是在计算机的最底层进行的，而在我们使用的汇编、C等其他高级语言中使用的都是原码。看了上面这些大家应该对原码、反码、补码有了新的认识了吧！

#######################################################################
计算机系统内部采用二进制表示数值数据，也采用二进制编码表示非数值数据和指令。计算机中存储信息的最小单位称为位。位分别代表0和1两种状态。数值数据分为有符号数和无符号数。无符号数最高位表示数值，而有符号数最高位表示符号。有符号数有不同的编码方式，常用的是补码。
(1)原码:
  最高位表示符号(正数用0,负数用1),其他位表示数值位,称为有符号数的原码表示法.
  例:X=45=00101101B  [X]原=00101101B
     X=-45,[X]原=10101101B
原码表示简单易懂,但若是两个异号数相加(或两个同号数相减),就要做减法.为了把减法运算转换为加法运算就引进了反码和补码.
(2)反码:
   正数的反码与原码相同,符号位用0表示,数值位值不变.负数的反码符号位用1表示,数值位为原码数值位按位取反形成,即0变1,1变0.
  例:X=45=00101101B  [X]反=00101101B
     X=-45,[X]反=11010010B
(3)补码:
  正数的补码与原码相同,即符号用0表示,数值位值不变.负数的补码为反码加1形成.
  例:X=45=00101101B  [X]补=00101101B
     X=-45,[X]反=11010011B
补充点感觉这样就完全了，文章写的不错对于程序设计就应该了解这些！

