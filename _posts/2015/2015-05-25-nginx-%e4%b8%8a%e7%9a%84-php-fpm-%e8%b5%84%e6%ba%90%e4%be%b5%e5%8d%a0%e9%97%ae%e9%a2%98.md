---
layout: post
title: Nginx 上的 php-fpm 资源侵占问题
date: 2015-05-25 13:28
author: admin
comments: true
categories: []
---
测试人员向我们反映：在Facebook平台的游戏比其它平台的游戏明显更慢。我询问，是不是因为翻墙网络原因。他们说：不是，其它游戏也比较流畅。使用httpwatch查看了http请求，发现api.php请求花了6秒，且大部分时间是红色(httpwatch红色表示服务器运算时间)。平常2秒，现在6秒,服务器处理时间在不同的服务器相差这么多。直觉告诉：服务器资源。

服务器概况
操作系统:CentOS5.3-64-2.6.18-164.el5
应用服务Nginx0.6、PHP-Fpm、MySQL5.1、PHP5.2、Memcached
Memcached仅cached游戏系统设置与模板参数据
故障检测
1.别的先不管，先top看一下cpu、ram、swap哪个比较紧张。
\
由上图分析，可以看出共有602个进程，其中有601个进程休眠了。这好像有点不对劲，内核进程也就80个左右，加上memcached, nginx, mysqld，也不会超出90个。除了这些，剩下的只有php-fpm管理的php-cgi，难道是…？
CPU显示，CPU压力并不大，可以说没有压力。我们再看内存使用概要，发现4G的内存，消耗得所剩余无几(free+buffers)， 95%以上的内存都已分配。交互空间使用情况，我们暂时不去关心。指令top还列出了占用资源最多的进程，运行时间最久(Time+)的mysqld(约2小时)占用资源并不是最多。另外，再看php-cgi,单个php-cgi占用的内存也不算多。所以，可以大胆地猜想：服务器内存资源比较紧张，并没有被某个进程占用大量内存，有可能被某些挂起的进程占着内存没有释放。通过free进一步监控内存使用情况，验证我们的想法。
2.指令free，了解RAM资源使用情况。当然，你也可以查看文件/proc/meminfo
\

我们先来看Mem统计信息，total表示物理内存总量，约4G。used，表示已分配内存，分配了并不表示使用了，包括(buffer&cached)。free指未分配的内存,buffers与cached表示分配了但还没有被使用的内存。第二行(buffers/cache)的，used表示真正被使用了内存，由第一行的(used-buffer-cached)得到，free则表示还没有被使用的内存,由第一行的(free+buffer+cached)得到。Swap行则表示内存交换使用情况，少量的(不频繁地)swpd，是不会影响服务器性能的，因为系统需要将V类型的内存页面交换出去或者调整了buffer与cached的大小。但是频繁地swpd，则有可能意味着服务器物理内存不足，小于指定的swap额定值，需要换出内存页。

查看free结果的时候，我们主要查看第二行。一眼就能看出4G的内存，其中有3898M内存被用了，还有49M内存没有，都快用完了。这也证实了我们第一步的猜想，内存被用完。这里，我们进一步猜想，内存空间严重不足的情况下，进程会被blocked，系统会不断地将不用的数据换出so，将要用的数据读入si。我们能通过vmstat进一步验证，我们的这个猜想。

3.指令vmstat监控内存使用情况
\
作为对内存监控，我们比较关心swpd、free、si、so。一般系统不繁忙的状态下，我们看到swpd,so的值不会持续很高，经常为0。这里，我们看到swpd值为1.5G，以及free值很小，再一次表明物理内存不足。其中si报告了每秒从swap区移入到物理内存的内存总量，so报告了每秒从物理内存移出到swap区的内存总量。当然，si有时较大，并不要过份的焦虑，经常碰到一个程序需要较大内存来读写媒体文件时，si值就会变大。反倒是so，它通常是一个内存紧缺的一个信号，如果长时间这个值一直保持较大的话，则很有可能内存不够，小额波动，可以不用理会。接下来，可以通过ps找出消耗内存的元凶。
4.指令ps找出消耗内存的元凶

[root@localhost ~]# ps -A –sort -rss -o comm,pmem,pcpu |uniq -c |head -15
1 COMMAND %MEM %CPU
1 mysqld 0.6 0.0
503 php-cgi 0.3 0.0
5 php-cgi 0.2 0.0
1 php-cgi 0.1 0.0
1 php-cgi 0.0 0.0
1 memcached 0.0 0.0
1 sshd 0.0 0.0
1 nginx 0.0 0.0
1 sshd 0.0 0.0
1 nginx 0.0 0.0
2 bash 0.0 0.0
3 nginx 0.0 0.0
1 sshd 0.0 0.0
1 nginx 0.0 0.0
指令ps比较常用，也比较简单。上面报告结果，我们一眼就可以命中php-cgi这个进程。虽然单个php-cgi占用内存并不算太大，但是503个php-cgi进程，就有点恐怖了。几乎占尽了全部内存（503*0.3%）。我们可以猜想，php-cgi由php-fpm管理，是不是可以php-fpm的某个参数配置不当，导致打开过多的php-cgi进程。
5. 设置php-fpm进程数量管理
通过重新将php-conf.conf的max_children值设置为150，系统内存又恢复到正常使用情况。free、si、so、b均表示内存系统资源正常，没有压力。
\

php-cgi进程释放的内存并不会被系统立即回收，一个php-cgi大概占用20MB内存（取决于你加载的php extensions）。所以，有必要限制你启动的php-cgi进程数量。那么，这个数量多少合适呢，你可以在服务器高峰期通过top统计出php-cgi数量。也可以像php-fpm建议的那样，通过netstat -np | grep 127.0.0.1:9000来收集数据，通过设置max_children使等待的数量尽量小

6.一个php-cgi占用多少内存
一个php-cgi进程，大概占用多少内存呢，大概是20MB(具体的要看你的php加载了多少模块)。可以通过pmap指令查看哪些地方占用了内存。所以，尽量不要加载不必要的php扩展模块，可以减少不必要的内存浪费。

[root@localhost etc]# pmap $(pgrep php-cgi |head -1)
6746: /usr/local/php/bin/php-cgi –fpm –fpm-config /usr/local/php/etc/php-fpm.conf
0000000000400000 6680K r-x– /usr/local/php/bin/php-cgi
0000000000c86000 268K rw— /usr/local/php/bin/php-cgi
0000000000cc9000 56K rw— [ anon ]
0000000005012000 2240K rw— [ anon ]
0000003efd200000 112K r-x– /lib64/ld-2.5.so
…….
00002ac28a7a5000 2048K —– /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/xhprof.so
00002ac28a9a5000 4K rw— /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/xhprof.so
00002ac28a9a6000 84K r-x– /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/apc.so
00002ac28a9bb000 2048K —– /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/apc.so
00002ac28abbb000 8K rw— /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/apc.so
00002ac28abbd000 32K rw— [ anon ]
00002ac28abd4000 40K r-x– /lib64/libnss_files-2.5.so
00002ac28abde000 2044K —– /lib64/libnss_files-2.5.so
00002ac28addd000 4K r—- /lib64/libnss_files-2.5.so
00002ac28adde000 4K rw— /lib64/libnss_files-2.5.so
00007fffa717e000 84K rw— [ stack ]
ffffffffff600000 8192K —– [ anon ]
total 154172K
