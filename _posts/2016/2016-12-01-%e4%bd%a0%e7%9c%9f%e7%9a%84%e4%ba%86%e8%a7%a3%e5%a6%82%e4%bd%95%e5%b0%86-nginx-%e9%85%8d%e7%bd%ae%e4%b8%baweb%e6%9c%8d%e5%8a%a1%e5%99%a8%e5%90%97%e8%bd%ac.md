---
layout: post
title: 你真的了解如何将 Nginx 配置为Web服务器吗[转]
date: 2016-12-01 09:32
author: admin
comments: true
categories: [Uncategorized]
---
阅读之前，建议先阅读<a href="https://lufficc.com/blog/nginx-for-beginners">初识 Nginx</a>。 之后，我们来了解一下 Nginx 配置。

抽象来说，将 Nginx 配置为 Web 服务器就是定义<strong>处理哪些 <code>URLS</code> </strong>和<strong>如何处理这些<code>URLS</code> 对应的请求</strong>。具体来说，就是定义一些虚拟服务器（Virtual Servers），控制具有特定 IP 和域名的请求。

更具体的来说， Nginx 通过定义一系列 <code>location</code>s 来控制对 <code>URIS</code> 的选择。每一个 <code>location</code>定义了对映射到自己的请求的处理场景：<strong>返回一个文件</strong>或者<strong>代理请求</strong>，或者根据不同的错误代码返回不同的错误页面。另外，根据 <code>URI</code> 的不同，请求也可以被<strong>重定向</strong>到其它 <code>server</code> 或者 <code>location</code> 。
<h2>设置虚拟服务器</h2>
<h4><code>listen</code>：</h4>
Nginx 配置文件至少包含一个 <code>server</code> 命令 ，用来定义虚拟服务器。当请求到来时， Nginx 会首先选择一个虚拟服务器来处理该请求。

虚拟服务器定义在 <code>http</code> 上下文中的 <code>server</code> 中：
<pre><code class="hljs nginx"><span class="hljs-section">http</span> {
    <span class="hljs-section">server</span> {
        <span class="hljs-comment"># Server configuration</span>
    }
}</code></pre>
<blockquote><em>注意： <code>http</code> 中可以定义多个 <code>server</code></em></blockquote>
<code>server</code> 配置块使用 <code>listen</code> 命令监听本机 IP 和端口号（包括 Unix domain socket and path），支持 IPv4、IPv6，IPv6地址需要用方括号括起来：
<pre><code class="hljs nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span> <span class="hljs-number">127.0.0.1:8080</span>;  <span class="hljs-comment"># IPv4地址，8080端口</span>
    <span class="hljs-comment"># listen [2001:3CA1:10F:1A:121B:0:0:10]:80;   # IPv6地址，80端口</span>
    <span class="hljs-comment"># listen [::]:80;  # 听本机的所有IPv4与IPv6地址，80端口</span>
    <span class="hljs-comment"># The rest of server configuration</span>
}</code></pre>
上述配置，如果不写端口号，默认使用80端口，如果不写 IP ，则监听本机所有 IP。
<h4><code>server_name</code>：</h4>
如果多个 <code>server</code> 的 <code>listen</code> IP 和端口号一模一样， Nginx 通过请求头中的 Host <img src="https://static.lufficc.com/image/474c32008006ad74c1d7c1dcb8f152ed.png" />与 <code>server_name</code> 定义的主机名进行比较，来选择合适的虚拟服务器处理请求：
<pre><code class="hljs perl">server {
    <span class="hljs-keyword">listen</span>      <span class="hljs-number">80</span>;
    server_name lufficc.com  www.lufficc.com;
    ...
}</code></pre>
<code>server_name</code> 的参数可以为：
<ol>
 	<li>完整的主机名，如：<code>api.lufficc.com</code> 。</li>
 	<li>含有通配符（含有 <code>*</code>），如：<code>*.lufficc.com</code> 或 <code>api.*</code> 。</li>
 	<li>正则表达式，以 <code>~</code> 开头。</li>
</ol>
<blockquote>通配符只能在开头或结尾，而且只能与一个 <code>.</code> 相邻。<code>www.*.example.org</code> 和 <code>w*.example.org</code> 均无效。 但是，可以使用正则表达式匹配这些名称，例如 <code>~^www\..+\.example\.org$</code> 和 <code>~^w.*\.example\.org$</code> 。 而且 <code>*</code> 可以匹配多个部分。 名称 <code>* .example.org</code> 不仅匹配 <code>www.example.org</code>，还匹配<code>www.sub.example.org</code>。
对于正则表达式：Nginx 使用的正则表达式与 Perl 编程语言（PCRE）使用的正则表达式兼容。 要使用正则表达式，且必须以 <code>~</code> 开头。</blockquote>
命名的正则表达式可以捕获变量，然后使用：
<pre><code class="hljs nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">server_name</span>   ~^(www\.)?(?&lt;domain&gt;.+)$;

    <span class="hljs-attribute">location</span> / {
        <span class="hljs-attribute">root</span>   /sites/<span class="hljs-variable">$domain</span>;
    }
}</code></pre>
小括号 <code>()</code> 之间匹配的内容，也可以在后面通过 <code>$1</code> 来引用，<code>$2</code> 表示的是前面第二个 <code>()</code> 里的内容。因此上述内容也可写为：
<pre><code class="hljs nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">server_name</span>   ~^(www\.)?(.+)$;

    <span class="hljs-attribute">location</span> / {
        <span class="hljs-attribute">root</span>   /sites/<span class="hljs-variable">$2</span>;
    }
}</code></pre>
一个 <code>server_name</code> 示例：
<pre><code class="hljs perl">server {
    <span class="hljs-keyword">listen</span>      <span class="hljs-number">80</span>;
    server_name api.lufficc.com  *.lufficc.com;
    ...
}</code></pre>
同样，如果多个名称匹配 <code>Host</code> 头部， Nginx 采用下列顺序选择：
<ol>
 	<li>完整的主机名，如 <code>api.lufficc.com</code>。</li>
 	<li>最长的，且以 <code>*</code> 开头的通配名，如：<code>*.lufficc.com</code>。</li>
 	<li>最长的，且以 <code>*</code> 结尾的通配名，如：<code>api.*</code> 。</li>
 	<li>第一个匹配的正则表达式。（按照配置文件中的顺序）</li>
</ol>
即优先级：<code>api.lufficc.com</code> &gt; <code>*.lufficc.com</code> &gt; <code>api.*</code> &gt; 正则。

如果 <code>Host</code> 头部不匹配任何一个 <code>server_name</code> ,Nginx 将请求路由到默认虚拟服务器。默认虚拟服务器是指：<code>nginx.conf</code> 文件中第一个 <code>server</code> 或者 显式用 <code>default_server</code> 声明：
<pre><code class="hljs perl">server {
    <span class="hljs-keyword">listen</span>      <span class="hljs-number">80</span> default_server;
    ...
}</code></pre>
<h2>配置 <code>location</code></h2>
<h4><code>URI</code> 与 <code>location</code> 参数的匹配</h4>
当选择好 <code>server</code> 之后，Nginx 会根据 <code>URI</code>s 选择合适的 <code>location</code> 来决定代理请求或者返回文件。

<code>location</code> 指令接受两种类型的参数：
<ol>
 	<li>前缀字符串（路径名称）</li>
 	<li>正则表达式</li>
</ol>
对于前缀字符串参数， <code>URI</code>s 必须严格的以它开头。例如对于 <code>/some/path/</code> 参数，可以匹配 <code>/some/path/document.html</code> ，但是不匹配 <code>/my-site/some/path</code>，因为 <code>/my-site/some/path</code> 不以 <code>/some/path/</code> 开头。
<pre><code class="hljs coffeescript">location <span class="hljs-regexp">/some/path/</span> {
    ...
}</code></pre>
对于正则表达式，以 <code>~</code> 开头表示大小写敏感，以 <code>~*</code> 开头表示大小写不敏感。注意路径中的 <code>.</code> 要写成 <code>\.</code> 。例如一个匹配以 <code>.html</code> 或者 <code>.htm</code> 结尾的 <code>URI</code> 的 <code>location</code>：
<pre><code class="hljs">location ~ \.html? {
    ...
}</code></pre>
正则表达式的优先级大于前缀字符串。如果找到匹配的前缀字符串，仍继续搜索正则表达式，但如果前缀字符串以 <code>^~</code> 开头，则不再检查正则表达式。

具体的搜索匹配流程如下：
<ol>
 	<li>将 <code>URI</code> 与所有的前缀字符串进行比较。</li>
 	<li><code>=</code> 修饰符表明 <code>URI</code> 必须与前缀字符串相等（不是开始，而是相等），如果找到，则搜索停止。</li>
 	<li>如果找到的最长前缀匹配字符串以 <code>^~</code> 开头，则不再搜索正则表达式是否匹配。</li>
 	<li>存储匹配的最长前缀字符串。</li>
 	<li>测试对比 <code>URI</code> 与正则表达式。</li>
 	<li>找到第一个匹配的正则表达式后停止。</li>
 	<li>如果没有正则表达式匹配，使用 4 存储的前缀字符串对应的 <code>location</code>。</li>
</ol>
<code>=</code> 修饰符拥有最高的优先级。如网站首页访问频繁，我们可以专门定义一个 <code>location</code> 来减少搜索匹配次数（因为搜索到 <code>=</code> 修饰的匹配的 <code>location</code> 将停止搜索），提高速度：
<pre><code class="hljs makefile">location = / {
    ...
}</code></pre>
<h4>静态文件和代理</h4>
<code>location</code> 也定义了如何处理匹配的请求：<strong>返回静态文件</strong> 或者 <strong>交给代理服务器处理</strong>。下面的例子中，第一个 <code>location</code> 返回 <code>/data</code> 目录中的静态文件，第二个 <code>location</code> 则将请求传递给 <a href="https://lufficc.com/">https://lufficc.com</a> 域名的服务器处理：
<pre><code class="hljs nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">location</span> /images/ {
        <span class="hljs-attribute">root</span> /data;
    }

    <span class="hljs-attribute">location</span> / {
        <span class="hljs-attribute">proxy_pass</span> https://lufficc.com;
    }
}</code></pre>
<code>root</code> 指令定义了静态文件的根目录，并且和 <code>URI</code> 拼接形成最终的本地文件路径。如请求 <code>/images/example.png</code>，则拼接后返回本地服务器文件 <code>/data/images/example.png</code> 。

<code>proxy_pass</code> 指令将请求传递到 URL 指向的代理服务器。让后将来自代理服务器的响应转发给客户端。 在上面的示例中，所有不以 <code>/images /</code> 开头的 <code>URI</code> 的请求都将传递给代理服务器处理。

比如我把 <code>proxy_pass</code> 设置为 <code>https://www.baidu.com/</code>，那么访问 <a href="http://search.lufficc.com/">http://search.lufficc.com/</a>将得到百度首页一样的响应（页面）（感兴趣的童鞋可以自己试一试搜索功能，和百度没差别呢）：
<pre><code class="hljs cpp">server{
      listen <span class="hljs-number">80</span>;
      server_name search.lufficc.com;
      location / {
              proxy_pass https:<span class="hljs-comment">//www.baidu.com;</span>
      }
}</code></pre>
<h2>使用变量（Variables）</h2>
你可以使用变量来使 Nginx 在不同的请求下采用不同的处理方式。变量是在运行时计算的，用作指令的参数。 变量由 <code>$</code> 开头的符号表示。 变量基于 Nginx 的状态定义信息，例如当前处理的请求的属性。

有很多预定义变量，例如核心的 HTTP 变量，你也可以使用 <code>set</code>，<code>map</code> 和 <code>geo</code> 指令定义自定义变量。 大多数变量在运行时计算，并包含与特定请求相关的信息。 例如，<code>$remote_addr</code> 包含客户端 IP 地址，<code>$uri</code> 保存当前URI值。

一些常用的变量如下：
<table class="table table-bordered table-responsive">
<thead>
<tr>
<th>变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$uri</code></td>
<td>请求中的当前URI(不带请求参数)，它可以通过内部重定向，或者使用index指令进行修改，<code>$uri</code>不包含主机名,如 <code>/foo/bar.html</code>。</td>
</tr>
<tr>
<td><code>$arg_name</code></td>
<td>请求中的的参数名，即“?”后面的<code>arg_name=arg_value</code>形式的<code>arg_name</code></td>
</tr>
<tr>
<td><code>$hostname</code></td>
<td>主机名</td>
</tr>
<tr>
<td><code>$args</code></td>
<td>请求中的参数值</td>
</tr>
<tr>
<td><code>$query_string</code></td>
<td>同 <code>$args</code></td>
</tr>
<tr>
<td><code>$request</code></td>
<td>代表客户端的请求地址</td>
</tr>
<tr>
<td><code>$request_uri</code></td>
<td>这个变量等于包含一些客户端请求参数的原始URI，它无法修改，不包含主机名，如：<code>/cnphp/test.php?arg=freemouse</code>。</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
一个简单的应用就是从 <code>http</code> 重定向到 <code>https</code> 时带上路径信息：
<pre><code class="hljs bash">server{
       ...
       <span class="hljs-built_in">return</span>      301 https://lufficc.com<span class="hljs-variable">$request_uri</span>;
       ...
}</code></pre>
<h2>返回特定状态码</h2>
如果你的网站上的一些资源永久移除了，最快最简洁的方法就是使用 <code>return</code> 指令直接返回：
<pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /wrong/url {
    <span class="hljs-attribute">return</span> <span class="hljs-number">404</span>;
}</code></pre>
<code>return</code> 的第一个参数是响应代码。可选的第二个参数可以是重定向（对应于代码301，302，303和307）的 URL 或在响应正文中返回的文本。 例如：
<pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /permanently/moved/url {
    <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> http://www.example.com/moved/here;
}</code></pre>
<code>return</code> 指令可以包含在 <code>location</code> 和 <code>server</code> 上下文中：
<pre><code class="hljs bash">server{
      location / {
              <span class="hljs-built_in">return</span> 404;
      }
}</code></pre>
或者：
<pre><code class="hljs bash">server{
      ...
      <span class="hljs-built_in">return</span> 404;
      location / {
          ...            
      }
}</code></pre>
<h2>错误处理</h2>
<code>error_page</code> 命令可以配置特定错误码的错误页面，或者重定向到其他的页面。下面的示例将在 404 错误发生时返回 <code>/404.html</code> 页面。
<pre><code class="hljs nginx"><span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;</code></pre>
<code>error_page</code> 命令定义了如何处理错误，因此不会直接返回，而 <code>return</code> 确实会立即返回。当代理服务器或者 Nginx 处理时产生相应的错误的代码，均会返回相应的错误页面。

在下面的示例中，当 Nginx 找不到页面时，它将使用代码301替换代码404，并将客户端重定向到 <code>http://example.com/new/path.html</code> 。 此配置很有用，比如当客户端仍尝试用旧的 <code>URI</code> 访问页面时，301代码通知浏览器页面已永久移除，并且需要自动替换为返回的新地址。
<pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /old/path.html {
    <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> =<span class="hljs-number">301</span> http:/example.com/new/path.html;
}</code></pre>
<h2>重写 <code>URI</code>s</h2>
<code>rewrite</code> 指令可以多次修改请求的 <code>URI</code>。<code>rewrite</code> 的第一个参数是 <code>URI</code>需要匹配的正则表达式，第二个参数是将要替换的 <code>URI</code>。第三个参数可选，指示是否继续可以重写或者返回重定向代码（301或302）。例如：
<pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /users/ {
    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/users/(.*)$</span> /show?user=<span class="hljs-variable">$1</span> <span class="hljs-literal">break</span>;
}</code></pre>
您可以在 <code>server</code> 和 <code>location</code> 上下文中包括多个 <code>rewrite</code> 指令。 <code>Nginx</code> 按照它们发生的顺序一个一个地执行指令。 当选择 <code>server</code> 时，<code>server</code> 中的 <code>rewrite</code> 指令将执行一次。

在 <code>Nginx</code> 处理一组 <code>rewrite</code> 指令之后，它根据新的 <code>URI</code> 选择 <code>location</code> 。 如果所选 <code>location</code> 仍旧包含 <code>rewrite</code> 指令，它们将依次执行。 如果 <code>URI</code> 匹配所有，则在处理完所有定义的 <code>rewrite</code> 指令后，搜索新的 <code>location</code> 。

以下示例将 <code>rewrite</code> 指令与 <code>return</code> 指令结合使用：
<pre><code class="hljs ruby">server {
    ...
    rewrite ^(<span class="hljs-regexp">/download/</span>.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
    rewrite ^(<span class="hljs-regexp">/download/</span>.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;
    <span class="hljs-keyword">return</span>  <span class="hljs-number">403</span>;
    ...
}</code></pre>
诸如 <code>/download/some/media/file</code> 的 URI 被改为 <code>/download/some/mp3/file.mp3</code> 。 由于 <code>last</code> 标志，后续指令（第二个 <code>rewrite</code> 指令和 <code>return</code> 指令）被跳过，但 Nginx 继续以更改后的 URI 处理请求。 类似地，诸如 <code>/download/some/audio/file</code> 的 URI 被替换为 <code>/download/some/mp3/file.ra</code>。 如果 URI 不匹配 <code>rewrite</code> 指令，Nginx 将403 错误代码返回给客户端。

<code>last</code> 与 <code>break</code>的区别是：
<ul>
 	<li><code>last</code> ： 在当前 <code>server</code> 或 <code>location</code> 上下文中停止执行 <code>rewrite</code> 指令，但是 Nginx 继续搜索与重写的URI匹配的 <code>location</code>，并应用新 <code>location</code> 中的任何 <code>rewrite</code> 指令（这意味着 URI 可能再次改变）。</li>
 	<li><code>break</code> ：停止当前上下文中 <code>rewrite</code> 指令的处理，并取消搜索与新 URI 匹配的 <code>location</code>。 不会执行新 <code>location</code>中的 <code>rewrite</code> 指令。</li>
</ul>
<h2>附录</h2>
<h4>常用正则</h4>
<ul>
 	<li><code>.</code> ： 匹配除换行符以外的任意字符</li>
 	<li><code>?</code> ： 重复0次或1次</li>
 	<li><code>+</code> ： 重复1次或更多次</li>
 	<li><code>*</code>： 重复0次或更多次</li>
 	<li><code>\d</code> ：匹配数字</li>
 	<li><code>^</code> ： 匹配字符串的开始</li>
 	<li><code>$</code> ： 匹配字符串的介绍</li>
 	<li><code>{n}</code> ： 重复n次</li>
 	<li><code>{n,}</code> ： 重复n次或更多次</li>
 	<li><code>[c]</code> ： 匹配单个字符c</li>
 	<li><code>[a-z]</code>： 匹配a-z小写字母的任意一个</li>
</ul>
<h4>全局变量</h4>
<ul>
 	<li><code>$args</code> ： #这个变量等于请求行中的参数，同<code>$query_string</code></li>
 	<li><code>$content_length</code> ： 请求头中的Content-length字段。</li>
 	<li><code>$content_type</code> ： 请求头中的Content-Type字段。</li>
 	<li><code>$document_root</code> ： 当前请求在root指令中指定的值。</li>
 	<li><code>$host</code> ： 请求主机头字段，否则为服务器名称。</li>
 	<li><code>$http_user_agent</code> ： 客户端agent信息</li>
 	<li><code>$http_cookie</code> ： 客户端cookie信息</li>
 	<li><code>$limit_rate</code> ： 这个变量可以限制连接速率。</li>
 	<li><code>$request_method</code> ： 客户端请求的动作，通常为GET或POST。</li>
 	<li><code>$remote_addr</code> ： 客户端的IP地址。</li>
 	<li><code>$remote_port</code> ： 客户端的端口。</li>
 	<li><code>$remote_user</code> ： 已经经过Auth Basic Module验证的用户名。</li>
 	<li><code>$request_filename</code> ： 当前请求的文件路径，由root或alias指令与URI请求生成。</li>
 	<li><code>$scheme</code> ： HTTP方法（如http，https）。</li>
 	<li><code>$server_protocol</code> ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</li>
 	<li><code>$server_addr</code> ： 服务器地址，在完成一次系统调用后可以确定这个值。</li>
 	<li><code>$server_name</code> ： 服务器名称。</li>
 	<li><code>$server_port</code> ： 请求到达服务器的端口号。</li>
 	<li><code>$request_uri</code> ： 包含请求参数的原始URI，不包含主机名，如：<code>/foo/bar.php?arg=baz</code>。</li>
 	<li><code>$uri</code> ： 不带请求参数的当前URI，$uri不包含主机名，如<code>/foo/bar.html</code>。</li>
 	<li><code>$document_uri</code> ： 与$uri相同。</li>
</ul>
例如请求：<code>http://localhost:88/test1/test2/test.php</code>
<code>$host</code>：localhost
<code>$server_port</code>：88
<code>$request_uri</code>：<a href="http://localhost:88/test1/test2/test.php">http://localhost:88/test1/test2/test.php</a>
<code>$document_uri</code>：/test1/test2/test.php
<code>$document_root</code>：/var/www/html
<code>$request_filename</code>：/var/www/html/test1/test2/test.php
<h2>参考</h2>
<ol>
 	<li><a href="https://www.nginx.com/resources/admin-guide/nginx-web-server/">https://www.nginx.com/resources/admin-guide/nginx-web-server/</a></li>
 	<li><a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/">http://seanlook.com/2015/05/17/nginx-location-rewrite/</a></li>
</ol>
