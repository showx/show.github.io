---
layout: post
title: 并发和多线程
date: 2014-05-03 23:12
author: admin
comments: true
categories: []
---
之前对并发，多线程这一块理解不到位，重新学习一下基础。

并发并不是多线程才有，并发的根源来源对语言的设计，很大程度何其内存模型有关。

参考：http://kenwublog.com/explain-java-memory-model-in-detail

内存模型 (memory model)

内存模型描述的是程序中各变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存取出变量这样的低层细节.不同平台间的处理器架构将直接影响内存模型的结构.

&nbsp;

在C或C++中, 可以利用不同操作平台下的内存模型来编写并发程序. 但是, 这带给开发人员的是, 更高的学习成本.
相比之下, java利用了自身虚拟机的优势, 使内存模型不束缚于具体的处理器架构, 真正实现了跨平台.
(针对hotspot jvm, jrockit等不同的jvm, 内存模型也会不相同)

&nbsp;

<strong>内存模型的特征: </strong>
a, Visibility 可视性 (多核,多线程间数据的共享)
b, Ordering 有序性 (对内存进行的操作应该是有序的)

&nbsp;

java 内存模型 ( java memory model )
根据Java Language Specification中的说明, jvm系统中存在一个主内存(Java Heap Memory )，Java中所有变量都储存在主存中，对于所有线程都是共享的。

&nbsp;

每条线程都有自己的工作内存(Working Memory )，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。

&nbsp;

其中, 工作内存里的变量, 在多核处理器下, 将大部分储存于处理器高速缓存中, 高速缓存在不经过内存时, 也是不可见的.

<strong>jmm怎么体现 可视性(Visibility) ?</strong>

在jmm中, 通过并发线程修改变量值, 必须将线程变量同步回主存后, 其他线程才能访问到.

&nbsp;

<strong>jmm怎么体现 有序性(Ordering) ?</strong>

通过java提供的同步机制或volatile 关键字, 来保证内存的访问顺序.

&nbsp;

缓存一致性（cache coherency）

<strong>什么是缓存一致性? </strong>
它是一种管理多处理器系统 的高速缓存区结构，其可以保证数据在高速缓存区到内存的传输中不会丢失或重复。(来自wikipedia)

举例理解: 假如有一个处理器有一个更新了的变量值位于其缓存中，但还没有被写入主内存，这样别的处理器就可能会看不到这个更新的值。

<strong>解决缓存一致性的方法? </strong>
a, 顺序一致性模型:
要求某处理器对所改变的变量值立即进行传播, 并确保该值被所有处理器接受后, 才能继续执行其他指令.

b, 释放一致性模型: (类似jmm cache coherency)

允许处理器将改变的变量值延迟到释放锁时才进行传播.jmm缓存一致性模型 – “happens-before ordering(先行发生排序)”

&nbsp;

一般情况下的示例程序:
<div id="">
<div>
<div>Java代码  <a title="收藏这段代码"><img alt="收藏代码" src="http://san-yun.iteye.com/images/icon_star.png" /></a></div>
</div>
<ol start="1">
	<li>x = 0;</li>
	<li>y = 0;</li>
	<li>i = 0;</li>
	<li>j = 0;</li>
	<li></li>
	<li>// thread A</li>
	<li>y = 1;</li>
	<li>x = 1;</li>
	<li></li>
	<li>// thread B</li>
	<li>i = x;</li>
	<li>j = y;</li>
</ol>
</div>
在如上程序中, 如果线程A,B在无保障情况下运行, 那么i,j各会是什么值呢?

答案是, 不确定. (00,01,10,11都有可能出现)
这里没有使用java同步机制, 所以 jmm 有序性和可视性 都无法得到保障.

&nbsp;

<strong></strong>如何避免这种情况?
排序原则<strong>happens-before ordering( 先行发生排序) </strong>已经做到:
a, 在程序顺序中, 线程中的每一个操作, 发生在当前操作后面将要出现的每一个操作之前.
b, 对象监视器的解锁发生在等待获取对象锁的线程之前.
c, 对volitile关键字修饰的变量写入操作, 发生在对该变量的读取之前.
d, 对一个线程的 Thread.start() 调用 发生在启动的线程中的所有操作之前.
e, 线程中的所有操作 发生在从这个线程的 Thread.join()成功返回的所有其他线程之前.

&nbsp;

为了实现 happends-before ordering原则, java及jdk提供的工具:
a, synchronized关键字
b, volatile关键字
c, final变量
d, java.util.concurrent.locks包(since jdk 1.5)
e, java.util.concurrent.atmoic包(since jdk 1.5)

&nbsp;

使用了happens-before ordering的例子:
<img alt="" src="http://dl.iteye.com/upload/attachment/0068/3536/2840dbe1-bbc7-3887-8391-884cc74dcff3.jpg" />

(1) 获取对象监视器的锁(lock)

(2) 清空工作内存数据, 从主存复制变量到当前工作内存, 即同步数据 (read and load)

(3) 执行代码，改变共享变量值 (use and assign)

(4) 将工作内存数据刷回主存 (store and write)

(5) 释放对象监视器的锁 (unlock)

&nbsp;

注意: 其中4,5两步是同时进行的.这边最核心的就是第二步, 他同步了主内存,即前一个线程对变量改动的结果,可以被当前线程获知!(利用了happens-before ordering原则)

&nbsp;

&nbsp;

经典j2ee设计模式Double-Checked Locking失效问题
双重检查锁定失效问题,一直是JMM无法避免的缺陷之一.了解DCL失效问题, 可以帮助我们深入JMM运行原理.

要展示DCL失效问题, 首先要理解一个重要概念- 延迟加载(lazy loading).

非单例的单线程延迟加载示例:
<div id="">
<div>
<div>Java代码  <a title="收藏这段代码"><img alt="收藏代码" src="http://san-yun.iteye.com/images/icon_star.png" /></a></div>
</div>
<ol start="1">
	<li>Class Foo</li>
	<li>{</li>
	<li>     Private Resource res = null;</li>
	<li>     Public Resource getResource()</li>
	<li>     {</li>
	<li>          If (res == null)</li>
	<li>          {</li>
	<li>            //只有在第一次初始化时,才使用同步方式.</li>
	<li>               synchronized(this)</li>
	<li>          {</li>
	<li>          if(res == null)</li>
	<li>          {</li>
	<li>               res = new Resource();</li>
	<li>          }</li>
	<li>          return res;</li>
	<li>     }</li>
	<li>}</li>
</ol>
</div>
&nbsp;

Double-Checked Locking看起来是非常完美的。但是很遗憾，根据Java的语言规范，上面的代码是不可靠的。

出现上述问题, 最重要的2个原因如下:
1, 编译器优化了程序指令, 以加快cpu处理速度.
2, 多核cpu动态调整指令顺序, 以加快并行运算能力.

问题出现的顺序:
1, 线程A, 发现对象未实例化, 准备开始实例化
2, 由于编译器优化了程序指令, 允许对象在构造函数未调用完前, 将 共享变量的引用指向 部分构造的对象, 虽然对象未完全实例化, 但已经不为null了.
3, 线程B, 发现部分构造的对象已不是null, 则直接返回了该对象.

不过, 一些著名的开源框架, 包括jive,lenya等也都在使用DCL模式, 且未见一些极端异常.
说明, DCL失效问题的出现率还是比较低的.
接下来就是性能与稳定之间的选择了?

&nbsp;

维基百科的DCL解释:

http://en.wikipedia.org/wiki/Double-checked_locking

DCL的完美解决方案:

http://www.theserverside.com/patterns/thread.tss?thread_id=39606

总结:
多线程编程, 针对有写操作的变量, 必须 保证其所有引用点与主存中数据一致(考虑采用同步或volatile) .
