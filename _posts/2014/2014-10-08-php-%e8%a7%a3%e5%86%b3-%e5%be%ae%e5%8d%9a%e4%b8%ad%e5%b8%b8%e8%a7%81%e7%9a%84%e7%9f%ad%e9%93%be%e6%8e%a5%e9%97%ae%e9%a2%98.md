---
layout: post
title: php 解决 微博中常见的短链接问题 
date: 2014-10-08 10:19
author: admin
comments: true
categories: []
---
微博中，有字数的限制，一般为120.在有限的大小内，如果嵌入一个很长的链接的话，那就会很不好。一个会影响美观，另外也影响用户输入的字数。所以，都会做短链接处理。

方法：
function shorturl($input) {
  $base32 = array (
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
    'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
    'y', 'z', '0', '1', '2', '3', '4', '5'
    );

  $hex = md5($input);
  $hexLen = strlen($hex);
  $subHexLen = $hexLen / 8;
  $output = array();

  for ($i = 0; $i < $subHexLen; $i++) {
    $subHex = substr ($hex, $i * 8, 8);
    $int = 0x3FFFFFFF & (1 * ('0x'.$subHex));
//$int = (1 * ('0x'.$subHex));
    $out = '';

    for ($j = 0; $j < 6; $j++) {
      $val = 0x0000001F & $int;
      $out .= $base32[$val];
      $int = $int >> 5;
    }

    $output[] = $out;
  }

  return $output;
}

测试使用：
$input = "weibo.com";
$output = shorturl($input);
print_r($output);

输出结果为：
Array
(
    [0] => odku0h
    [1] => 0lfs2l
    [2] => jnd1s3
    [3] => uncurm
)

在这个结果中，随便取一个即可作为短链接使用。然后，和原来的链接一起，作为key-value 值存储起来，点击
这种短链接的时候，就可以去查询对应的长链接来使用，然后跳转即可。

==================



复制代码 代码示例:
<?php
/**
* 短连接生成算法  
*/
    class Short_Url {  
        #字符表  
        public static $charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";  
  
        public static function short($url) {  
            $key = "alexis";  
            $urlhash = md5($key . $url);  
            $len = strlen($urlhash);  
  
            #将加密后的串分成4段，每段4字节，对每段进行计算，一共可以生成四组短连接  
            for ($i = 0; $i < 4; $i++) {  
                $urlhash_piece = substr($urlhash, $i * $len / 4, $len / 4);  
                #将分段的位与0x3fffffff做位与，0x3fffffff表示二进制数的30个1，即30位以后的加密串都归零  
                $hex = hexdec($urlhash_piece) & 0x3fffffff; #此处需要用到hexdec()将16进制字符串转为10进制数值型，否则运算会不正常  
  
                $short_url = "http://t.cn/";  
                #生成6位短连接  
                for ($j = 0; $j < 6; $j++) {  
                    #将得到的值与0x0000003d,3d为61，即charset的坐标最大值  
                    $short_url .= self::$charset[$hex & 0x0000003d];  
                    #循环完以后将hex右移5位  
                    $hex = $hex >> 5;  
                }  
  
                $short_url_list[] = $short_url;  
            }  
  
            return $short_url_list;  
        }  
    }  
  
    $url = "http://www.www.jbxue.com/jb//";  
    $short = Short_Url::short($url);  
    print_r($short);  
?>
输出结果：
Array ( [0] => http://t.cn/KyfLyH [1] => http://t.cn/bPafHS [2] => http://t.cn/H880aD [3] => http://t.cn/TmvDK0 )

生成的短url存到服务器里，做一个映射，short_url => original_url，输入短url的时候按照映射转回长url，然后访问原始url即可。

代码：
 

复制代码 代码示例:
<?php  
Class TinyURL {  
    static private $key = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; //可以多位 保证每位的字符在URL里面正常显示即可  
    private function  __construct() {}  
    private function  __clone(){}  
      
    static public function encode($value) {  
        $base = strlen( self::$key );  
        $arr = array();  
        while( $value != 0 ) {  
            $arr[] = $value % $base;  
            $value = floor( $value / $base );  
        }  
        $result = "";  
        while( isset($arr[0]) ) $result .= substr(self::$key, array_pop($arr), 1 );  
        return $result;  
    }  
      
    static public function decode($value) {  
        $base = strlen( self::$key );  
        $num = 0;  
        $key = array_flip( str_split(self::$key) );  
        $arr = str_split($value);  
        for($len = count($arr) - 1, $i = 0; $i &lt;= $len; $i++) {  
            $num += pow($base, $i) * $key[$arr[$len-$i]];  
        }  
        return $num;  
    }  
} 
调用示例：
 

复制代码 代码示例:
<?php
$t = 100;  
$time_start =  microtime(true);  
while($t--){  
    var_dump( TinyURL::encode(1000000) );  
    var_dump( TinyURL::decode("4C92") );  
}  
$time_end = microtime(true);  
printf("[内存使用: %.2fMB]\r\n", memory_get_usage() /1024 /1024 );   
printf("[内存最高使用: %.2fMB]\r\n", memory_get_peak_usage()  /1024 /1024) ;   
printf("[执行时间: %.2f毫秒]\r\n", ($time_end - $time_start) * 1000 ); 
以上代码适用于：
自增ID的传统关系型数据库。
需要执行二次SQL，第一次获取自增ID，第二次根据ID生成短链接。[或者3次，额外一次用于判断是否存在此短链接。]

此外，还有一种是根据URL进行Hash运算的算法，这种算法的优点： 
1，无需id，用Key/Value这样的格式即可满足存储。 
2，SQL插入只需一条语句。 
3，生成的数据具有离散性，无法观察生成规律。

缺点： 
1，所以的Hash算法都存在冲突的可能，一旦冲突原始的就会被覆盖。[当然你可以增加额外的逻辑去判断。] 
2，数据规模不好控制，你不知道什么时候才能开始使用新的Hash数据位，但随着数据量的增加，冲突的概率会越来越高。 
此种的代码适用于NoSQL等非关系型数据库，查找快更新快。

====
使用nosql来弄
key->value更方便
