---
layout: post
title: acm
date: 2010-04-23 07:21
author: admin
comments: true
categories: []
---
ACM/ICPC 代码库 吉林大学计算机科学与技术学院 2005 级 2007-2008 文档变更记录 修订日期 修订内容 修订版本 修订人 2007 创建 1.0 jojer（sharang、xwbsw、Liuctic） 2008.10 修订 1.1 Fandywang 1 | 最小费用流 O(V^2 * F) ........................................... 14 目录 | 最佳边割集 ................................................................... 15 | 最佳点割集 ................................................................... 15 | 最小边割集 ................................................................... 15 | 最小点割集（点连通度） ........................................... 16 目录 .............................................. 1 | 最小路径覆盖 O(N^3) ................................................ 16 | 最小点集覆盖 ............................................................... 16 Graph 图论 ........................................ 3 Structure 数据结构 ............................... 17 | DAG 的深度优先搜索标记 ............................................. 3 | 无向图找桥 ..................................................................... 3 | 求某天是星期几 ........................................................... 17 | 无向图连通度(割) ........................................................ 3 | 左偏树 合并复杂度 O(LOG N) ................................... 17 | 最大团问题 DP + DFS ................................................. 3 | 树状数组 ....................................................................... 17 | 欧拉路径 O(E) ............................................................... 3 | 二维树状数组 ............................................................... 17 | DIJKSTRA 数组实现 O（N^2） ..................................... 3 | TRIE 树(K 叉) .............................................................. 17 | DIJKSTRA O(E * LOG E) ............................................. 4 | TRIE 树(左儿子又兄弟) ............................................. 18 | BELLMANFORD 单源最短路 O(VE) ................................. 4 | 后缀数组 O(N * LOG N) ............................................ 18 | SPFA(SHORTEST PATH FASTER ALGORITHM) .............. 4 | 后缀数组 O(N) ............................................................ 18 | 第 K 短路（DIJKSTRA） ................................................. 5 | RMQ 离线算法 O(N*LOGN)+O(1) ............................. 19 | 第 K 短路（A*） ............................................................ 5 | RMQ(RANGE MINIMUM/MAXIMUM QUERY)-ST 算法 | PRIM 求 MST .................................................................... 6 (O(NLOGN + Q)) ............................................................. 19 | 次小生成树 O(V^2) ...................................................... 6 | RMQ 离线算法 O(N*LOGN)+O(1)求解 LCA ............. 19 | 最小生成森林问题(K 颗树)O(MLOGM). ...................... 6 | LCA 离线算法 O(E)+O(1) ........................................ 20 | 有向图最小树形图 ......................................................... 6 | 带权值的并查集 ........................................................... 20 | MINIMAL STEINER TREE ................................................ 6 | 快速排序 ....................................................................... 20 | TARJAN 强连通分量 ........................................................ 7 | 2 台机器工作调度 ........................................................ 20 | 弦图判断 ......................................................................... 7 | 比较高效的大数 ........................................................... 20 | 弦图的 PERFECT ELIMINATION 点排列 .......................... 7 | 普通的大数运算 ........................................................... 21 | 稳定婚姻问题 O(N^2) .................................................. 7 | 最长公共递增子序列 O(N^2) .................................... 22 | 拓扑排序 ......................................................................... 8 | 0-1 分数规划 ............................................................... 22 | 无向图连通分支(DFS/BFS 邻接阵) ............................. 8 | 最长有序子序列（递增/递减/非递增/非递减） .... 22 | 有向图强连通分支(DFS/BFS 邻接阵)O(N^2) ............ 8 | 最长公共子序列 ........................................................... 23 | 有向图最小点基(邻接阵)O(N^2)............................... 9 | 最少找硬币问题（贪心策略-深搜实现） ................. 23 | FLOYD 求最小环 .............................................................. 9 | 棋盘分割 ....................................................................... 23 | 2-SAT 问题 ..................................................................... 9 | 汉诺塔 ........................................................................... 23 | STL 中的 PRIORITY_QUEUE .......................................... 24 Network 网络流 ................................... 11 | 堆栈 ............................................................................... 24 | 区间最大频率 ............................................................... 24 | 二分图匹配（匈牙利算法 DFS 实现） ...................... 11 | 取第 K 个元素................................................................ 25 | 二分图匹配（匈牙利算法 BFS 实现） ...................... 11 | 归并排序求逆序数 ....................................................... 25 | 二分图匹配（HOPCROFT－CARP 的算法） .................. 11 | 逆序数推排列数 ........................................................... 25 | 二分图最佳匹配（KUHN MUNKRAS 算法 O(M*M*N)） 11 | 二分查找 ....................................................................... 25 | 无向图最小割 O(N^3) ............................................... 12 | 二分查找（大于等于 V 的第一个值）........................ 25 | 有上下界的最小(最大)流 .......................................... 12 | 所有数位相加 ............................................................... 25 | DINIC 最大流 O(V^2 * E) ....................................... 12 | HLPP 最大流 O(V^3) ................................................ 13 Number 数论 ...................................... 26 | 最小费用流 O(V * E * F) ....................................... 13 1 |递推求欧拉函数 PHI(I) ............................................... 26 Geometry 计算几何 ................................ 34 |单独求欧拉函数 PHI(X) ............................................... 26 | GCD 最大公约数 .......................................................... 26 | GRAHAM 求凸包 O(N * LOGN) .................................... 34 | 快速 GCD ...................................................................... 26 | 判断线段相交 ............................................................... 34 | 扩展 GCD ...................................................................... 26 | 求多边形重心 ............................................................... 34 | 模线性方程 A * X = B (% N) .................................. 26 | 三角形几个重要的点 ................................................... 34 | 模线性方程组 ............................................................... 26 | 平面最近点对 O(N * LOGN) ...................................... 34 | 筛素数 [1..N] ............................................................ 26 | LIUCTIC 的计算几何库 ................................................ 35 | 高效求小范围素数 [1..N] ........................................ 26 | 求平面上两点之间的距离 ........................................... 35 | 随机素数测试(伪素数原理) ...................................... 26 | (P1-P0)*(P2-P0)的叉积 ....................................... 35 | 组合数学相关 ............................................................... 26 | 确定两条线段是否相交 ............................................... 35 | POLYA 计数 .................................................................... 27 | 判断点 P 是否在线段 L 上 ............................................ 35 | 组合数 C(N, R) ........................................................... 27 | 判断两个点是否相等 ................................................... 35 | 最大 1 矩阵 ................................................................... 27 | 线段相交判断函数 ....................................................... 35 | 约瑟夫环问题（数学方法） ....................................... 27 | 判断点 Q 是否在多边形内 .......................................... 35 | 约瑟夫环问题（数组模拟） ....................................... 27 | 计算多边形的面积 ....................................................... 35 | 取石子游戏 1 ................................................................ 27 | 解二次方程 AX^2+BX+C=0 ........................................ 36 | 集合划分问题 ............................................................... 27 | 计算直线的一般式 AX+BY+C=0 ................................. 36 | 大数平方根（字符串数组表示） ............................... 28 | 点到直线距离 ............................................................... 36 | 大数取模的二进制方法 ............................................... 28 | 直线与圆的交点，已知直线与圆相交 ....................... 36 | 线性方程组 A[][]X[]=B[] ....................................... 28 | 点是否在射线的正向 ................................................... 36 | 追赶法解周期性方程 ................................................... 28 | 射线与圆的第一个交点 ............................................... 36 | 阶乘最后非零位,复杂度 O(NLOGN) ........................... 29 | 求点 P1 关于直线 LN 的对称点 P2 .............................. 36 | 两直线夹角（弧度） ................................................... 36 递归方法求解排列组合问题 ......................... 30 ACM/ICPC 竞赛之 STL ............................... 37 | 类循环排列 ................................................................... 30 | 全排列 ........................................................................... 30 ACM/ICPC 竞赛之 STL 简介 .......................................... 37 | 不重复排列 ................................................................... 30 ACM/ICPC 竞赛之 STL--PAIR ...................................... 37 | 全组合 ........................................................................... 31 ACM/ICPC 竞赛之 STL--VECTOR .................................. 37 | 不重复组合 ................................................................... 31 ACM/ICPC 竞赛之 STL--ITERATOR 简介 ...................... 38 | 应用 ............................................................................... 31 ACM/ICPC 竞赛之 STL--STRING .................................. 38 ACM/ICPC 竞赛之 STL--STACK/QUEUE ........................ 38 模式串匹配问题总结 ............................... ACM/ICPC 竞赛之 STL-- 3 MAP 2 ........................................ 40 ACM/ICPC 竞赛之 STL--ALGORITHM ............................. 40 | 字符串 HASH .................................................................. 32 STL IN ACM ..................................................................... 41 | KMP 匹配算法 O(M+N) ............................................... 32 头文件 ............................................................................... 42 | KARP-RABIN 字符串匹配 ............................................. 32 | 基于 KARP-RABIN 的字符块匹配................................. 32 线段树 ........................................... 43 | 函数名: STRSTR ........................................................... 32 | BM 算法的改进的算法 SUNDAY ALGORITHM ................ 32 求矩形并的面积（线段树+离散化+扫描线） ............... 43 | 最短公共祖先（两个长字符串） ............................... 33 求矩形并的周长（线段树+离散化+扫描线） ............... 44 | 最短公共祖先（多个短字符串） ............................... 33 2 /*==================================================*\ | 最大团问题 DP + DFS Graph 图论 | INIT: g[][]邻接矩阵; | CALL: res = clique(n); \*==================================================*/ int g[V][V], dp[V], stk[V][V], mx; int dfs(int n, int ns, int dep){ if (0 == ns) { /*==================================================*\ if (dep &gt; mx) mx = dep; | DAG 的深度优先搜索标记 return 1; | INIT: edge[][]邻接矩阵; pre[], post[], tag全置0; } | CALL: dfstag(i, n); pre/post:开始/结束时间 int i, j, k, p, cnt; \*==================================================*/ for (i = 0; i &lt; ns; i++) { int edge[V][V], pre[V], post[V], tag; k = stk[dep][i]; cnt = 0; void dfstag(int cur, int n) if (dep + n - k &lt;= mx) return 0; { // vertex: 0 ~ n-1 if (dep + dp[k] &lt;= mx) return 0; pre[cur] = ++tag; for (j = i + 1; j &lt; ns; j++) { for (int i=0; i pre[cur]) } printf("Down Edge!\n"); int clique(int n){ else printf("Cross Edge!\n"); int i, j, ns; } for (mx = 0, i = n - 1; i &gt;= 0; i--) { } // vertex: 0 ~ n-1 post[cur] = ++tag; for (ns = 0, j = i + 1; j &lt; n; j++) } if (g[i][j]) stk[1][ ns++ ] = j; /*==================================================*\ dfs(n, ns, 1); dp[i] = mx; | 无向图找桥 } | INIT: edge[][]邻接矩阵;vis[],pre[],anc[],bridge 置0; return mx; | CALL: dfs(0, -1, 1, n); } \*==================================================*/ /*==================================================*\ int bridge, edge[V][V], anc[V], pre[V], vis[V]; | 欧拉路径 O(E) void dfs(int cur, int father, int dep, int n) | INIT: adj[][]置为图的邻接表; cnt[a]为a点的邻接点个数; { // vertex: 0 ~ n-1 | CALL: elpath(0); 注意:不要有自向边 if (bridge) return; \*==================================================*/ vis[cur] = 1; pre[cur] = anc[cur] = dep; int adj[V][V], idx[V][V], cnt[V], stk[V], top; for (int i=0; i 0; v = w) { if (pre[i] &lt; anc[cur]) stk[ top++ ] = v; anc[cur] = pre[i];//back edge w = adj[v][ --cnt[v] ]; } adj[w][ idx[w][v] ] = adj[w][ --cnt[w] ]; if (0 == vis[i]) { //tree edge // 处理的是无向图?边是双向的，删除v-&gt;w后，还要处理删除w-&gt;v dfs(i, cur, dep+1, n); } if (bridge) return; return v; if (anc[i] &lt; anc[cur]) anc[cur] = anc[i]; } if (anc[i] &gt; pre[cur]) { bridge = 1; return; } void elpath (int b, int n){ // begin from b } int i, j; } for (i = 0; i &lt; n; ++i) // vertex: 0 ~ n-1 vis[cur] = 2; for (j = 0; j &lt; cnt[i]; ++j) } idx[i][ adj[i][j] ] = j; /*==================================================*\ printf("%d", b); | 无向图连通度(割) for (top = 0; path(b) == b &amp;&amp; top != 0; ) { | INIT: edge[][]邻接矩阵;vis[],pre[],anc[],deg[]置为0; b = stk[ --top ]; | CALL: dfs(0, -1, 1, n); printf("-%d", b); | k=deg[0], deg[i]+1(i=1卬-1)为删除该节点后得到的连通图个数 } | 注意:0作为根比较特殊! printf("\n"); \*==================================================*/ } int edge[V][V], anc[V], pre[V], vis[V], deg[V]; /*==================================================*\ void dfs(int cur, int father, int dep, int n) | Dijkstra 数组实现 O（N^2） {// vertex: 0 ~ n-1 | Dijkstra --- 数组实现(在此基础上可直接改为STL的Queue实现) int cnt = 0; | lowcost[] --- beg到其他点的最近距离 vis[cur] = 1; pre[cur] = anc[cur] = dep; | path[] -- beg为根展开的树，记录父亲结点 for (int i=0; i1) || lowcost[i] = cost[beg][i]; path[i] = beg; (cnt!=0 &amp;&amp; anc[i]&gt;=pre[cur])) } ++deg[cur]; // link degree of a vertex lowcost[beg] = 0; } path[beg] = -1; // 树根的标记 } int pre = beg; vis[cur] = 2; for (i=1; ir.c; } O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。 }; 原理：只有那些在前一遍松弛中改变了距离估计值的点，才可能引起他们的邻 void dijkstra(int n, const int src){ 接点的距离估计值的改变。 qnode mv; 判断负权回路：记录每个结点进队次数，超过|V|次表示有负权。 int i, j, k, pre; \*==================================================*/ priority_queue que; // POJ 3159 Candies vis[src] = 1; dist[src] = 0; const int INF = 0x3F3F3F3F; que.push(qnode(src, 0)); const int V = 30001; for (pre = src, i=1; i dist[u] + c ) { void init(int nv, int ne){ dist[v] = dist[u] + c; return 1; int i, u, v; typec c; } e = 0; return 0; memset(head, -1, sizeof(head)); } memset(vis, 0, sizeof(vis)); inline void addedge(int u, int v, int c){ memset(prev, -1, sizeof(prev)); pnt[e] = v; cost[e] = c; nxt[e] = head[u]; head[u] = e++; for (i = 0; i &lt; nv; i++) dist[i] = inf; } for (i = 0; i &lt; ne; ++i) { int SPFA(int src, int n) scanf("%d%d%d", &amp;u, &amp;v, &amp;c);// %d: type of cost { // 此处用堆栈实现，有些时候比队列要快 addedge(u, v, c); // vertex: 0 ~ n-1, 单向边 int i; } for( i=1; i &lt;= n; ++i ){ // 顶点1...n } vis[i] = 0; dist[i] = INF; /*==================================================*\ } | BellmanFord 单源最短路 O(VE) dist[src] = 0; | 能在一般情况下，包括存在负权边的情况下，解决单源最短路径问题 int Q[E], top = 1; | INIT: edge[E][3]为边表 Q[0] = src; vis[src] = true; | CALL: bellman(src);有负环返回0;dist[i]为src到i的最短距 while( top ){ | 可以解决差分约束系统: 需要首先构造约束图，构造不等式时&gt;=表示求最 int u, v; 小值, 作为最长路，&lt;=表示求最大值, 作为最短路 （v-u &lt;= c:a[u][v] = u = Q[--top]; vis[u] = false; c） for( i=head[u]; i != -1; i=nxt[i] ){ \*==================================================*/ v = pnt[i]; #define typec int // type of cost if( 1 == relax(u, v, cost[i]) &amp;&amp; !vis[v] ) { const typec inf=0x3f3f3f3f; // max of cost Q[top++] = v; vis[v] = true; int n, m, pre[V], edge[E][3]; } typec dist[V]; } int relax (int u, int v, typec c){ } if (dist[v] &gt; dist[u] + c) { return dist[n]; dist[v] = dist[u] + c; } 4 // 队列实现，而且有负权回路判断—POJ 3169 Layout for (int i=0;i b) swap(t, a, b); if (k==n &amp;&amp; v[n]==x-1) break; addedge(a, b, c); for (int i=1;i&lt;=n;i++){ } if (v[i]=c ==&gt; 小-大&lt;=-c, 有向边(大, 小):-c dist[i][x]=dist[k][v[k]]+g[k][i]; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); for (int j=x;j&gt;0;j--) if( a &lt; b ) swap(t, a, b); if (dist[i][j] dist[u] + c ) { return 0; dist[v] = dist[u] + c; return 1; } } /*==================================================*\ return 0; | 第 K 短路（A*） } | A* 估价函数 fi为到当前点走过的路经长度， hi为该点到终点的长度 inline void addedge(int u, int v, int c){ | gi=hi+fi； pnt[e] = v; cost[e] = c; nxt[e] = head[u]; head[u] = e++; \*==================================================*/ } //WHU1603 int SPFA(int src, int n){// 此处用队列实现 int n,m,x,ct; int i; int g[1010][1010],gr[1010][1010]; memset(cnt, 0, sizeof(cnt)); // 入队次数 int dist[1010],v[1010]; memset(vis, false, sizeof(vis)); const int INF=1000000000; for( i=1; i &lt;= n; ++i ) dist[i] = INF; struct node{ dist[src] = 0; int id,fi,gi; queue Q; friend bool operator &lt;(node a,node b){ Q.push(src); vis[src] = true; ++cnt[src]; if (a.gi==b.gi) return a.fi&gt;b.fi; while( !Q.empty() ){ return a.gi&gt;b.gi; int u, v; } u = Q.front(); Q.pop(); vis[u] = false; }s[2000010]; for( i=head[u]; i != -1; i=nxt[i] ){ int init(){ v = pnt[i]; for (int i=0;i&lt;=n;i++){ if( 1 == relax(u, v, cost[i]) &amp;&amp; !vis[v] ) { dist[i]=INF; Q.push(v); vis[v] = true; v[i]=1; if( (++cnt[v]) &gt; n ) return -1; // cnt[i] } 为入队列次数，用来判断是否存在负权回路 dist[n-1]=0; } for (int i=0;i eg[j].c) { \*==================================================*/ dis[k] = eg[j].c; #define typec int // type of cost to[k] = i; const typec inf = 0x3f3f3f3f; // max of cost } int vis[V]; typec lowc[V]; } typec prim(typec cost[][V], int n) // vertex: 0 ~ n-1 to[root] = -1; dis[root] = 0; tag[root] = root; { for (i = 0; i &lt; nv; ++i) if (cp[i] == i &amp;&amp; -1 == tag[i]){ int i, j, p; j = i; typec minc, res = 0; for ( ; j != -1 &amp;&amp; tag[j] == -1; j = to[j]) memset(vis, 0, sizeof(vis)); tag[j] = i; vis[0] = 1; if (j == -1) return 0; for (i=1; i lowc[j]) { } minc = lowc[j]; p = j; if (circle) { } for (j = 0; j &lt; ne; ++j) { if (inf == minc) return -1; // 原图不连通 i = iroot(eg[j].u); k = iroot(eg[j].v); res += minc; vis[p] = 1; if (k != i &amp;&amp; tag[k] == -2) eg[j].c -= dis[k]; for (j=0; j cost[p][j]) for (i = 0; i &lt; nv; ++i) if (tag[i] == -2) { lowc[j] = cost[p][j]; res += dis[i]; tag[i] = 0; } for (j = to[i]; j != i; j = to[j]) { return res; res += dis[j]; cp[j] = i; tag[j] = 0; } } /*==================================================*\ } | 次小生成树 O(V^2) if (0 == dirtree(root, nv, ne)) return 0; \*==================================================*/ } else { 结论 次小生成树可由最小生成树换一条边得到. for (i = 0; i &lt; nv; ++i) if (cp[i] == i) res += dis[i]; 证明: 可以证明下面一个强些的结论： } T是某一棵最小生成树，T0是任一棵异于T的树，通过变换T0 --&gt; T1 --&gt; return 1; // 若返回0代表原图不连通 T2 --&gt; ... --&gt; Tn (T) 变成最小生成树.所谓的变换是，每次把T_i中的 } 某条边换成T中的一条边, 而且树T_(i+1)的权小于等于T_i的权. /*==================================================*\ 具体操作是： | Minimal Steiner Tree step 1. 在T_i中任取一条不在T中的边u_v. | G(V, E), A是V的一个子集, 求至少包含A中所有点的最小子树. step 2. 把边u_v去掉，就剩下两个连通分量A和B，在T中，必有唯一的 | 时间复杂度: O(N^3 + N * 2^A * (2^A + N)) 边u'_v' 连结A和B. | INIT: d[][]距离矩阵; id[]置为集合A中点的标号; step 3. 显然u'_v'的权比u_v小 (否则,u_v就应该在T中).把u'_v' | CALL: steiner(int n, int a); 替换u_v即得树T_(i+1). | main()函数解决的题目: Ticket to Ride, NWERC 2006/2007 特别地：取Tn为任一棵次小生成树，T_(n-1) 也就是次小生成树且跟T | 给4个点对(a1, b1) ... (a4, b4), 差一条边. 结论得证. | 求min(sigma(dist[ai][bi])),其中重复的路段只能算一次. | 这题要找出一个steiner森林, 最后要对森林中树的个数进行枚举 算法：只要充分利用以上结论, 即得V^2的算法. 具体如下： \*==================================================*/ step 1. 先用prim求出最小生成树T. 在prim的同时，用一个矩阵 #define typec int // type of cost max[u][v] 记录在T中连结任意两点u,v的唯一的路中权值最大的那条边的 const typec inf = 0x3f3f3f3f; // max of cost 权值. (注意这里). 这是很容易做到的，因为prim是每次增加一个结点s, 而 int vis[V], id[A]; //id[]: A中点的标号 设已经标号了的结点集合为W, 则W中所有的结点到s的路中的最大权值的边就 typec d[V][V], dp[1&lt; d[i][k] + d[k][j]) void mcs(int n){ d[i][j] = d[i][k] + d[k][j]; int i, j, k; for (i = 0; i &lt; a; i++) { // vertex: 0 ~ n-1 memset(tag, 0, sizeof(tag)); for (j = 0; j &lt; n; j++) memset(order, -1, sizeof(order)); dp[1 &lt;&lt; i][j] = d[j][ id[i] ]; for (i = n - 1; i &gt;= 0; i--) { // vertex: 0 ~ n-1 } for (j = 0; order[j] &gt;= 0; j++) ; for (i = 1; i &lt; top; i++) { for (k = j + 1; k &lt; n; k++) if ( 0 == (i &amp; (i - 1)) ) continue; if (order[k] &lt; 0 &amp;&amp; tag[k] &gt; tag[j]) j = k; memset(vis, 0, sizeof(vis)); order[j] = i, inv[i] = j; for (k = 0; k &lt; n; k++) { // init for (k = 0; k &lt; n; k++) if (g[j][k]) tag[k]++; for (dp[i][k] = inf, j = 1; j &lt; i; j++) } if ((i | j) == i &amp;&amp; } dp[i][k] &gt; dp[j][k] + dp[i - j][k]) int peo(int n){ dp[i][k] = dp[j][k] + dp[i - j][k]; int i, j, k, w, min; } for (i = n - 2; i &gt;= 0; i--) { for (j = 0; mx = inf, j &lt; n; j++) { // update j = inv[i], w = -1, min = n; for (k = 0; k &lt; n; k++) for (k = 0; k &lt; n; k++) if (dp[i][k] &lt;= mx &amp;&amp; 0 == vis[k]) if (g[j][k] &amp;&amp; order[k] &gt; order[j] &amp;&amp; mx = dp[i][mk = k]; order[k] &lt; min) for (k = 0, vis[mk] = 1; k &lt; n; k++) min = order[k], w=k; if (dp[i][mk] &gt; dp[i][k] + d[k][mk]) if (w &lt; 0) continue; dp[i][mk] = dp[i][k] + d[k][mk]; for (k = 0; k &lt; n; k++) } if (g[j][k] &amp;&amp; order[k] &gt; order[w] &amp;&amp; !g[k][w]) } return 0; // no } } int main(void){ return 1; // yes int n, a = 8; } // TODO: read data; /*==================================================*\ steiner(n, a); | 弦图的 perfect elimination 点排列 // enum to find the result | INIT: g[][]置为邻接矩阵; for (i = 0, b = inf; z = 0, i &lt; 256; b&gt;z ? b=z : b, i++) | CALL: cardinality(n); tag[i]为排列中第i个点的标号; for (j = 0; y = 0, j &lt; 4; z += !!y * dp[y][x], j++) | The graph with the property mentioned above for (k = 0; k &lt; 8; k += 2) | is called chordal graph. A permutation s = [v1 , v2, if ((i &gt;&gt; k &amp; 3) == j) | ..., vn] of the vertices of such graph is called a y += 3 &lt;&lt; k, x = id[k]; | perfect elimination order if each vi is a simplicial // TODO: cout &lt;&lt; b &lt;&lt; endl; | vertex of the subgraph of G induced by {vi ,..., vn}. return 0; | A vertex is called simplicial if its adjacency set } | induces a complete subgraph, that is, a clique (not /*==================================================*\ | necessarily maximal). The perfect elimination order | Tarjan 强连通分量 | of a chordal graph can be computed as the following: | INIT: vec[]为邻接表; stop, cnt, scnt置0; pre[]置-1; \*==================================================*/ | CALL: for(i=0; i vec[V]; set label[v] to zero int id[V], pre[V], low[V], s[V], stop, cnt, scnt; end for void tarjan(int v, int n) // vertex: 0 ~ n-1 for all i from n downto 1 do { choose an unnumbered vertex v with largest label int t, minc = low[v] = pre[v] = cnt++; set s(v) to i{number vertex v} vector::iterator pv; for all unnumbered vertices w adjacent to vertex v do s[stop++] = v; increment label[w] by one for (pv = vec[v].begin(); pv != vec[v].end(); ++pv) { end for if(-1 == pre[*pv]) tarjan(*pv, n); end for if(low[*pv] &lt; minc) minc=low[*pv]; end procedure } if(minc &lt; low[v]) { int tag[V], g[V][V], deg[V], vis[V]; low[v] = minc; return; void cardinality(int n) } { do { int i, j, k; id[t = s[--stop]] = scnt; low[t] = n; memset(deg, 0, sizeof(deg)); } while(t != v); memset(vis, 0, sizeof(vis)); ++scnt; // 强连通分量的个数 for (i = n - 1; i &gt;= 0; i--) { } for (j = 0, k = -1; j &lt; n; j++) if (0 == vis[j]) { /*==================================================*\ if (k == -1 || deg[j] &gt; deg[k]) k = j; | 弦图判断 } | INIT: g[][]置为邻接矩阵; vis[k] = 1, tag[i] = k; | CALL: mcs(n); peo(n); for (j = 0; jnum且与x相邻的点集为C int opp, tag; | 在C中找出编号最小的节点y, int list[N]; // man使用 | 若C中存在点z!=y, 使得y与z之间无边, 则此图不是弦图. int priority[N]; // woman使用, 有必要的话可以和list合并， | } 以节省空间 | 检查完了, 则此图是弦图. void Init(){ state = tag = 0; } \*==================================================*/ }man[N], woman[N]; 7 struct R{ } int opp; int own; for( i=0; i &lt; n; ++i ) }requst[N]; if( top == -1 ) { printf("存在回路\n"); return ; } int n; else{ void Input(void); int j = top; top = count[top]; void Output(void); printf("%d", j); void stableMatching(void); for( int k=0; k &lt; n; ++k ) int main(void){ if( edge[j][k] &amp;&amp; (--count[k]) == 0 ){ //... count[k] = top; top = k; Input(); } stableMatching(); } Output(); } //... /*==================================================*\ return 0; | 无向图连通分支(dfs/bfs 邻接阵) } | DFS / BFS / 并查集 void Input(void){ \*==================================================*/ scanf("%d\n", &amp;n); /*==================================================*\ int i, j, ch; | 有向图强连通分支(dfs/bfs 邻接阵)O(n^2) for( i=0; i &lt; n; ++i ) { \*==================================================*/ man[i].Init(); //返回分支数,id返回1..分支数的值 for( j=0; j &lt; n; ++j ){ //按照man的意愿递减排序 //传入图的大小n和邻接阵mat,不相邻点边权0 scanf("%d", &amp;ch); man[i].list[j] = ch-1; #define MAXN 100 } void search(int n,int mat[][MAXN],int* dfn,int* low,int } now,int&amp; cnt,int&amp; tag,int* id,int* st,int&amp; sp){ for( i=0; i &lt; n; ++i ) { int i,j; woman[i].Init(); dfn[st[sp++]=now]=low[now]=++cnt; for( j=0; j &lt; n; ++j ){ //按照woman的意愿递减排序， for (i=0;i int ret=0,a[MAXN],b[MAXN],c[MAXN],d[MAXN],i,j,k,t; woman[requst[i].opp].priority[requst[i].own] ){ // for (k=0;k dist[i][j]+g[k][i]+g[k][j] ){ //返回点基大小和点基 Min = //传入图的大小n和邻接阵mat,不相邻点边权0 dist[i][j]+g[k][i]+g[k][j]; //需要调用强连通分支 solve(i, j, k); // 记录最小环 #define MAXN 100 } int base_vertex(int n,int mat[][MAXN],int* sets){ for ( i=0; i &lt; n; i++ ) int ret=0,id[MAXN],v[MAXN],i,j; if ( dist[i][k] &lt; INF ) j=find_components(n,mat,id); for ( j=0; j &lt; n; j++ ) for (i=0;i dist[i][k]+dist[k][j] ){ for (j=0;j= 0; ct-- ){ } printf("%d", out[ct]+1); /*==================================================*\ if ( ct ) printf(" "); | Floyd 求最小环 } \*==================================================*/ } 朴素算法 else printf("No solution."); 令e(u,v)表示u和v之间的连边, 令min(u,v)表示删除u和v之间的连边之后 printf("\n"); u和v之间的最短路, 最小环则是min(u, v) + e(u, v). 时间复杂度是 } O(EV^2). return 0; 改进算法 } 在floyd的同时，顺便算出最小环 /*==================================================*\ g[i][j]=i, j之间的边长 | 2-sat 问题 dist:=g; * N个集团，每个集团2个人，现在要想选出尽量多的人， for k:=1 to n do * 且每个集团只能选出一个人。如果两人有矛盾，他们不能同时被选中 begin * 问最多能选出多少人 for i:=1 to k-1 do \*==================================================*/ for j:=i+1 to k-1 do const int MAXN=3010; answer:=min(answer, dist[i][j]+g[i][k]+g[k][j]); int n,m; for i:=1 to n do int g[3010][3010],ct[3010],f[3010]; for j:=1 to n do int x[3010],y[3010]; int prev[MAXN], low[MAXN], stk[MAXN], sc[MAXN]; dist[i][j]:=min(dist[i][j],dist[i][k]+dist[k][j]); int cnt[MAXN]; end; int cnt0, ptr, cnt1; 最小环改进算法的证明 一个环中的最结点为 k(编号最大), 与他相连的两个点为i, j, 这个环的最 void dfs(int w){ 短长度为g[i][k]+g[k][j]+i到j的路径中所有结点编号都小于k的最短路 int min(0); 径长度. 根据floyd的原理, 在最外层循环做了k-1次之后, dist[i][j]则 prev[w] = cnt0++; 代表了i到j的路径中所有结点编号都小于k的最短路径 low[w] = prev[w]; 综上所述,该算法一定能找到图中最小环. min = low[w]; const int INF = 1000000000; stk[ptr++] = w; const int N = 110; for(int i = 0; i &lt; ct[w]; ++i){ int n, m; // n:节点个数, m:边的个数 int t = g[w][i]; int g[N][N]; // 无向图 if(prev[t] == -1) int dist[N][N]; // 最短路径 dfs(t); int r[N][N]; // r[i][j]: i到j的最短路径的第一步 if(low[t] &lt; min) int out[N], ct; // 记录最小环 min = low[t]; int solve(int i, int j, int k){// 记录最小环 } ct = 0; if(min &lt; low[w]){ while ( j != i ){ low[w] = min; out[ct++] = j; return; j = r[i][j]; } } do{ out[ct++] = i; out[ct++] = k; int v = stk[--ptr]; return 0; sc[v] = cnt1; } low[v] = MAXN; int main(void){ }while(stk[ptr] != w); while( scanf("%d%d", &amp;n, &amp;m) != EOF ){ ++cnt1; int i, j, k; } for ( i=0; i &lt; n; i++ ) void Tarjan(int N){ for ( j=0; j &lt; n; j++ ){ //传入N为点数，结果保存在sc数组中，同一标号的点在同一个强连通 g[i][j] = INF; r[i][j] = i; 分量内， } //强连通分量数为cnt1 for ( i=0; i &lt; m; i++ ){ cnt0 = cnt1 = ptr = 0; int x, y, l; int i; scanf("%d%d%d", &amp;x, &amp;y, &amp;l); for(i = 0; i &lt; N; ++i) --x; --y; prev[i] = low[i] = -1; if ( l &lt; g[x][y] ) g[x][y] = g[y][x] = l; for(i = 0; i &lt; N; ++i) } if(prev[i] == -1) memmove(dist, g, sizeof(dist)); dfs(i); int Min = INF; // 最小环 } for ( k=0; k &lt; n; k++ ){//Floyd int solve(){ for ( i=0; i &lt; k; i++ )// 一个环中的最大结点为k(编 Tarjan(n); 号最大) for (int i=0;i Q; for(v = 0; v &lt; vN; v++) dis = INF; if(g[u][v] &amp;&amp; !chk[v]) memset(dx, -1, sizeof(dx)); { memset(dy, -1, sizeof(dy)); chk[v] = true; for (int i = 0; i &lt; Nx; i++) if(yM[v] == -1 || SearchPath(yM[v])) if (Mx[i] == -1){ { Q.push(i); dx[i] = 0; yM[v] = u; xM[u] = v; } return true ; while (!Q.empty()) { } int u = Q.front(); Q.pop(); } if (dx[u] &gt; dis) break; return false ; for (int v = 0; v &lt; Ny; v++) } if (g[u][v] &amp;&amp; dy[v] == -1) { int MaxMatch(){ dy[v] = dx[u]+1; int u, ret = 0 ; if (My[v] == -1) dis = dy[v]; memset(xM, -1, sizeof (xM)); else{ memset(yM, -1, sizeof (yM)); dx[My[v]] = dy[v]+1; for(u = 0; u &lt; uN; u++) Q.push(My[v]); if(xM[u] == -1){ } memset(chk, false, sizeof (chk)); } if(SearchPath(u)) ret++; } } return dis != INF; return ret; } } bool DFS(int u){ /*==================================================*\ for (int v = 0; v &lt; Ny; v++) | 二分图匹配（匈牙利算法 BFS 实现） if (!vst[v] &amp;&amp; g[u][v] &amp;&amp; dy[v] == dx[u]+1) { | INIT: g[][]邻接矩阵; vst[v] = 1; | CALL: res = MaxMatch();Nx, Ny初始化！！！ if (My[v] != -1 &amp;&amp; dy[v] == dis) continue; | 优点：适用于稀疏二分图，边较少，增广路较短。 if (My[v] == -1 || DFS(My[v])) { | 匈牙利算法的理论复杂度是O(VE) My[v] = u; Mx[u] = v; \*==================================================*/ return 1; const int MAXN = 1000; } int g[MAXN][MAXN], Mx[MAXN], My[MAXN], Nx, Ny; } int chk[MAXN], Q[MAXN], prev[MAXN]; return 0; int MaxMatch(void) { } int res = 0; int MaxMatch(void){ int qs, qe; int res = 0; memset(Mx, -1, sizeof(Mx)); memset(Mx, -1, sizeof(Mx)); memset(My, -1, sizeof(My)); memset(My, -1, sizeof(My)); memset(chk, -1, sizeof(chk)); while (searchP()) { for (int i = 0; i &lt; Nx; i++){ memset(vst, 0, sizeof(vst)); if (Mx[i] == -1){ for (int i = 0; i &lt; Nx; i++) qs = qe = 0; if (Mx[i] == -1 &amp;&amp; DFS(i)) res++; Q[qe++] = i; } prev[i] = -1; return res; } bool flag = 0; /*=================================================*\ while (qs &lt; qe &amp;&amp; !flag){ | 二分图最佳匹配（kuhn munkras 算法 O(m*m*n)） int u = Q[qs]; | 邻接距阵形式,复杂度O(m*m*n) 返回最佳匹配值,传入二分图大小m,n for (int v = 0; v &lt; Ny &amp;&amp; !flag; v++) | 邻接距阵mat,表示权, match1,match2返回一个最佳匹 ,未匹配顶点 if (g[u][v] &amp;&amp; chk[v] != i) { | match值为-1, 一定注意m&lt;=n,否则循环无法终止,最小权匹配可将权值 chk[v] = i; Q[qe++] = My[v]; | 取相反数 if (My[v] &gt;= 0) prev[My[v]] = u; | 初始化：for( i=0 ; i &lt; MAXN ; ++i ) else { for( j=0 ; j &lt; MAXN ; ++j ) mat[i][j] = -inf; flag = 1; | 对于存在的边：mat[i][j] = val ; // 注意，不能有负值 int d = u, e = v; \*==================================================*/ while (d != -1) { #include int t = Mx[d]; #define MAXN 310 Mx[d] = e; My[e] = d; #define inf 1000000000 d = prev[d]; e = t; #define _clr(x) memset(x,-1,sizeof(int)*MAXN) } 11 int kuhn_munkras(int m,int n,int mat[][MAXN],int* | 有上下界的最小(最大)流 match1,int* match2){ | INIT: up[][]为容量上界; low[][]为容量下界; int | CALL: mf = limitflow(n,src,sink); flow[][]为流量分配; s[MAXN],t[MAXN],l1[MAXN],l2[MAXN],p,q,ret=0,i,j,k; | 另附: 循环流问题 for (i=0;il1[i]?mat[i][j]:l1[i]; | f满足: f(v, V) = f(V, v). V中任意顶点v, if( l1[i] == -inf ) return -1;// 无法匹配！ | l(a)&lt;=f(a)&lt;=c(a), 则称f为网络N的循环流. } | 解法: 添加一个源s和汇t，对于每个下限容量l不为0的边(u, v), for (i=0;i=0;j=p) int p, q, t, i, j; do{ match2[j]=k=t[j],p=match1[k],match1[k]=j; for (i = 0; i &lt; n; pv[i++] = 0) ; } pv[t = src] = src + 1; d[t] = inf; if (match1[i]&lt;0){ for (p=q=0; p&lt;=q &amp;&amp; !pv[sink]; t=que[p++]) for (i--,p=inf,k=0;k&lt;=q;k++) for (i=0; i0) (t[j]&lt;0&amp;&amp;l1[s[k]]+l2[j]-mat[s[k]][j]0) for (j=0;j0)flow[pv[i]-1][i]+=d[sink],i=pv[i]-1; {// if处理无匹配的情况！！ else flow[i][-pv[i]-1]-=d[sink], i=-pv[i]-1; if( match[i] &lt; 0 ) return -1; } if( mat[i][match[i]] &lt;= -inf ) return -1; } while (pv[sink]); ret+=mat[i][match1[i]]; } } int limitflow(int n, int src, int sink) return ret; { } int i, j, sk, ks; /*==================================================*\ if (src == sink) return inf; | 无向图最小割 O(N^3) up[n][n+1] = up[n+1][n] = up[n][n] = up[n+1][n+1] = 0; | INIT: 初始化邻接矩阵g[][]; for (i = 0; i &lt; n; i++) { | CALL: res = mincut(n); up[n][i] = up[i][n] = up[n+1][i] = up[i][n+1] = 0; | 注: Stoer-Wagner Minimum Cut; for (j = 0; j &lt; n; j++) { | 找边的最小集合，若其被删去则图变得不连通（我们把这种形式称为最小 up[i][j] -= low[i][j]; | 割问题） up[n][i] += low[j][i]; \*==================================================*/ up[i][n+1] += low[i][j]; #define typec int // type of res } const typec inf = 0x3f3f3f3f; // max of res } const typec maxw = 1000; // maximum edge weight sk = up[src][sink]; ks = up[sink][src]; typec g[V][V], w[V]; up[src][sink] = up[sink][src] = inf; int a[V], v[V], na[V]; maxflow(n+2, n, n+1); typec mincut(int n){ for (i = 0; i &lt; n; i++) int i, j, pv, zj; if (flow[n][i] &lt; up[n][i]) return -1; typec best = maxw * n * n; flow[src][sink] = flow[sink][src] = 0; for (i = 0; i &lt; n; i++) v[i] = i; // vertex: 0 ~ n-1 up[src][sink] = sk; up[sink][src] = ks; while (n &gt; 1) { // ! min: src &lt;- sink; max: src -&gt; sink; for (a[v[0]] = 1, i = 1; i &lt; n; i++) { maxflow(n, sink, src); a[v[i]] = 0; na[i - 1] = i; for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) { w[i] = g[v[0]][v[i]]; up[i][j] += low[i][j]; flow[i][j] += low[i][j]; } } for (pv = v[0], i = 1; i &lt; n; i++ ) { for (j = i = 0; i &lt; n; j += flow[src][i++]) ; for (zj = -1, j = 1; j &lt; n; j++ ) return j; if (!a[v[j]] &amp;&amp; (zj &lt; 0 || w[j] &gt; w[zj])) } zj = j; /*==================================================*\ a[v[zj]] = 1; | Dinic 最大流 O(V^2 * E) if (i == n - 1) { | INIT: ne=2; head[]置为0; addedge()加入所有弧; if (best &gt; w[zj]) best = w[zj]; | CALL: flow(n, s, t); for (i = 0; i &lt; n; i++) \*==================================================*/ g[v[i]][pv] = g[pv][v[i]] += #define typec int // type of cost g[v[zj]][v[i]]; const typec inf = 0x3f3f3f3f; // max of cost v[zj] = v[--n]; struct edge { int x, y, nxt; typec c; } bf[E]; break; int ne, head[N], cur[N], ps[N], dep[N]; } void addedge(int x, int y, typec c) pv = v[zj]; { // add an arc(x -&gt; y, c); vertex: 0 ~ n-1; for (j = 1; j &lt; n; j++) if(!a[v[j]]) bf[ne].x = x; bf[ne].y = y; bf[ne].c = c; w[j] += g[v[zj]][v[j]]; bf[ne].nxt = head[x]; head[x] = ne++; } bf[ne].x = y; bf[ne].y = x; bf[ne].c = 0; } bf[ne].nxt = head[y]; head[y] = ne++; return best; } } typec flow(int n, int s, int t) /*==================================================*\ { typec tr, res = 0; 12 int i, j, k, f, r, top; int v, s, t, h[N], hn[2 * N], cur[N]; while (1) { void push(int); memset(dep, -1, n * sizeof(int)); void relabel(int); for (f = dep[ps[0] = s] = 0, r = 1; f != r; ) void build(int, int); for (i = ps[f++], j = head[i]; j; j = bf[j].nxt) typef maxflow(int, int); { }; if (bf[j].c &amp;&amp; -1 == dep[k = bf[j].y]){ void network::push(int u) { dep[k] = dep[i] + 1; ps[r++] = k; edge* te = net[u][cur[u]]; if (k == t) { f = r; break; } typef ex = minf(te-&gt;cap(u), e[u]); } int p = te-&gt;other(u); } if (e[p] == 0 &amp;&amp; p != t) list.insert(p, h[p]); if (-1 == dep[t]) break; te-&gt;addflow(u, ex); e[u] -= ex; e[p] += ex; } memcpy(cur, head, n * sizeof(int)); void network::relabel(int u) { for (i = s, top = 0; ; ) { int i, p, mh = 2 * v, oh = h[u]; if (i == t) { for (i = net[u].size()-1; i &gt;= 0; i--) { for (k = 0, tr = inf; k &lt; top; ++k) p = net[u][i]-&gt;other(u); if (bf[ps[k]].c &lt; tr) if (net[u][i]-&gt;cap(u) != 0 &amp;&amp; mh &gt; h[p] + 1) tr = bf[ps[f = k]].c; mh = h[p] + 1; for (k = 0; k &lt; top; ++k) } bf[ps[k]].c -= tr, bf[ps[k]^1].c += tr; hn[h[u]]--; hn[mh]++; h[u] = mh; res += tr; i = bf[ps[top = f]].x; cur[u] = net[u].size()-1; } for (j=cur[i]; cur[i]; j = cur[i] = bf[cur[i]].nxt) if (hn[oh] != 0 || oh &gt;= v + 1) return; if (bf[j].c &amp;&amp; dep[i]+1 == dep[bf[j].y]) break; for (i = 0; i &lt; v; i++) if (cur[i]) { if (h[i] &gt; oh &amp;&amp; h[i] &lt;= v &amp;&amp; i != s) { ps[top++] = cur[i]; hn[h[i]]--; hn[v+1]++; h[i] = v + 1; i = bf[cur[i]].y; } } } else { typef network::maxflow(int ss, int tt) { if (0 == top) break; s = ss; t = tt; dep[i] = -1; i = bf[ps[--top]].x; int i, p, u; typef ec; } } for (i = 0; i &lt; v; i++) net[i].clear(); } for (i = eg.size()-1; i &gt;= 0; i--) { return res; net[eg[i].u].push_back(&amp;eg[i]); } net[eg[i].v].push_back(&amp;eg[i]); /*=================================================*\ } | HLPP 最大流 O(V^3) | INIT: network g; g.build(nv, ne); memset(h, 0, sizeof(h)); memset(hn, 0, sizeof(hn)); | CALL: res = g.maxflow(s, t); memset(e, 0, sizeof(e)); e[s] = inf; | 注意: 不要加入指向源点的边, 可能死循环. for (i = 0; i &lt; v; i++) h[i] = v; \*==================================================*/ queue q; q.push(t); h[t] = 0; #define typef int // type of flow while (!q.empty()) { const typef inf = 0x3f3f3f3f; // max of flow p = q.front(); q.pop(); typef minf(typef a, typef b) { return a &lt; b ? a : b; } for (i = net[p].size()-1; i &gt;= 0; i--) { u = net[p][i]-&gt;other(p); struct edge { ec = net[p][i]-&gt;cap(u); int u, v; typef cuv, cvu, flow; if (ec != 0 &amp;&amp; h[u] == v &amp;&amp; u != s) { edge (int x=0, int y=0, typef cu=0, h[u] = h[p] + 1; q.push(u); typef cv=0, typef f=0) } : u(x), v(y), cuv(cu), cvu(cv), flow(f) {} } int other(int p) { return p == u ? v : u; } } typef cap(int p) { for (i = 0; i &lt; v; i++) hn[h[i]]++; return p == u ? cuv-flow : cvu+flow; } for (i = 0; i &lt; v; i++) cur[i] = net[i].size()-1; void addflow(int p, typef f) { flow += (p == u ? f : -f); } list.clear(v); }; for (; cur[s] &gt;= 0; cur[s]--) push(s); struct vlist { while (!list.empty()) { int lv, next[N], idx[2 * N], v; for (u = list.remove(); e[u] &gt; 0; ) { void clear(int cv) { if (cur[u] &lt; 0) relabel(u); v = cv; lv = -1; else if (net[u][cur[u]]-&gt;cap(u) &gt; 0 &amp;&amp; memset(idx, -1, sizeof(idx)); h[u] == h[net[u][cur[u]]-&gt;other(u)]+1) } push(u); void insert(int n, int h) { else cur[u]--; next[n] = idx[h]; idx[h] = n; } if (lv &lt; h) lv = h; } } return e[t]; int remove() { } int r = idx[lv]; idx[lv] = next[idx[lv]]; void network::build(int n, int m) { while (lv &gt;= 0 &amp;&amp; idx[lv] == -1) lv--; v = n; eg.clear(); return r; int a, b, i; typef l; } for (i = 0; i &lt; m; i++) { bool empty() { return lv &lt; 0; } cin &gt;&gt; a &gt;&gt; b &gt;&gt; l; }; eg.push_back(edge(a, b, l, 0)); // vertex: 0 ~ n-1 } struct network { } vector eg; /*==================================================*\ vector net[N]; | 最小费用流 O(V * E * f) vlist list; | INIT: network g; g.build(v, e); typef e[N]; | CALL: g.mincost(s, t); flow=g.flow; cost=g.cost; 13 | 注意: SPFA增广, 实际复杂度远远小于O(V * E); int u, v; typef cuv, cvu, flow; typec cost; \*==================================================*/ edge (int x, int y, typef cu, typef cv, typec cc) #define typef int // type of flow :u(x), v(y), cuv(cu), cvu(cv), flow(0), cost(cc){} #define typec int // type of dis int other(int p) { return p == u ? v : u; } const typef inff = 0x3f3f3f3f; // max of flow typef cap(int p) { return p == u ? cuv-flow : cvu+flow; } const typec infc = 0x3f3f3f3f; // max of dis typec ecost(int p) { struct network if (flow == 0) return cost; { else if(flow &gt; 0) return p == u ? cost : -cost; int nv, ne, pnt[E], nxt[E]; else return p == u ? -cost : cost; int vis[N], que[N], head[N], pv[N], pe[N]; } typef flow, cap[E]; typec cost, dis[E], d[N]; void addFlow(int p, typef f) { flow += (p == u ? f : -f); } void addedge(int u, int v, typef c, typec w) { }; pnt[ne] = v; cap[ne] = c; dis[ne] = +w; nxt[ne] = head[u]; head[u] = (ne++); struct network { pnt[ne] = u; cap[ne] = 0; vector eg; dis[ne] = -w; nxt[ne] = head[v]; head[v] = (ne++); vector net[N]; } edge *prev[N]; int mincost(int src, int sink) { int v, s, t, pre[N], vis[N]; int i, k, f, r; typef mxf; typef flow; typec cost, dis[N], phi[N]; for (flow = 0, cost = 0; ; ) { bool dijkstra(); memset(pv, -1, sizeof(pv)); void build(int nv, int ne); memset(vis, 0, sizeof(vis)); typec mincost(int, int); for (i = 0; i &lt; nv; ++i) d[i] = infc; }; d[src] = 0; pv[src] = src; vis[src] = 1; bool network::dijkstra() { // 使用O(E * logV)的Dij可降低整体复杂度至 O(E * logV * f) for (f = 0, r = 1, que[0] = src; r != f; ) { int i, j, p, u; typec md, cw; i = que[f++]; vis[i] = 0; for (i = 0; i &lt; v; i++) dis[i] = infc; if (N == f) f = 0; dis[s] = 0; prev[s] = 0; pre[s] = -1; for (k = head[i]; k != -1; k = nxt[k]) memset(vis, 0, v * sizeof(int)); if(cap[k] &amp;&amp; dis[k]+d[i] &lt; d[pnt[k]]) for (i = 1; i &lt; v; i++) { { for (md = infc, j = 0; j &lt; v; j++) d[pnt[k]] = dis[k] + d[i]; if (!vis[j] &amp;&amp; md &gt; dis[j]) { if (0 == vis[pnt[k]]) { md = dis[j]; u = j; vis[pnt[k]] = 1; } que[r++] = pnt[k]; if (md == infc) break; if (N == r) r = 0; for (vis[u] = 1, j = net[u].size()-1; j &gt;= 0; j--) } { pv[pnt[k]]=i; pe[pnt[k]]=k; edge *ce = net[u][j]; } if(ce-&gt;cap(u) &gt; 0) { } p = ce-&gt;other(u); if (-1 == pv[sink]) break; cw = ce-&gt;ecost(u) + phi[u] - phi[p]; // !! assert(cw &gt;= 0); for (k = sink, mxf = inff; k != src; k = pv[k]) if(dis[p] &gt; dis[u]+cw) { if (cap[pe[k]] &lt; mxf) mxf = cap[pe[k]]; dis[p] = dis[u] + cw; flow += mxf; cost += d[sink] * mxf; prev[p] = ce; pre[p] = u; } for (k = sink; k != src; k = pv[k]) { } cap[pe[k]] -= mxf; cap[pe[k] ^ 1] += mxf; } } } } return infc != dis[t]; return cost; } } typec network::mincost(int ss, int tt) { void build(int v, int e) { s = ss; t = tt; nv = v; ne = 0; int i, c; typef ex; memset(head, -1, sizeof(head)); int x, y; typef f; typec w; flow = cost = 0; for (int i = 0; i &lt; e; ++i) { memset(phi, 0, sizeof(phi)); cin &gt;&gt; x &gt;&gt; y &gt;&gt; f &gt;&gt; w; // vertex: 0 ~ n-1 // !! 若原图含有负消费的边, 在此处运行Bellmanford addedge(x, y, f, w);// add arc (u-&gt;v, f, w) // 将phi[i](0&lt;=i&lt;=n-1)置为mindist(s, i). } } for (i = 0; i &lt; v; i++) net[i].clear(); } g; for (i = eg.size()-1; i &gt;= 0; i--) { /*==================================================*\ net[eg[i].u].push_back(&amp;eg[i]); | 最小费用流 O(V^2 * f) net[eg[i].v].push_back(&amp;eg[i]); | INIT: network g; g.build(nv, ne); } | CALL: g.mincost(s, t); flow=g.flow; cost=g.cost; | 注意: 网络中弧的cost需为非负. 若存在负权, 进行如下转化: while(dijkstra()) { | 首先如果原图有负环, 则不存在最小费用流. 那么可以用Johnson for (ex = inff, c = t; c != s; c = pre[c]) | 重标号技术把所有边变成正权, 以后每次增广后进行维护, 算法如 if (ex &gt; prev[c]-&gt;cap(pre[c])) | 下: ex = prev[c]-&gt;cap(pre[c]); | 1. 用bellman-ford求s到各点的距离phi[]; for (c = t; c != s; c = pre[c]) | 2. 以后每求一次最短 , 设s到各点的最短距离为dis[]: prev[c]-&gt;addFlow(pre[c], ex); | for i=1 to v do flow += ex; cost += ex * (dis[t] + phi[t]); | phi[v] += dis[v]; for (i = 0; i &lt; v; i++) phi[i] += dis[i]; | 下面的代码已经做了第二步, 如果原图有负权, 添加第一步即可. } \*==================================================*/ return cost; #define typef int // type of flow } #define typec int // type of cost void network::build(int nv, int ne) { const typef inff = 0x3f3f3f3f; // max of flow eg.clear(); v = nv; const typec infc = 0x3f3f3f3f; // max of cost int x, y; typef f; typec c; for (int i = 0; i &lt; ne; ++i) { struct edge { cin &gt;&gt; x &gt;&gt; y &gt;&gt; f &gt;&gt; c; 14 eg.push_back(edge(x, y, f, 0, c)); } } } } /*=================================================*\ int best_vertex_cut(int n,int mat[][MAXN],int* cost,int | 最佳边割集 source,int sink,int* set,int&amp; mincost){ \*==================================================*/ int m0[MAXN][MAXN],m[MAXN][MAXN],i,j,k,ret=0,last; #define MAXN 100 if (source==sink||mat[source][sink]) #define inf 1000000000 return -1; for (i=0;ic[j])) m0[n+i][i]=cost[i]; j=i; for (i=0;ic[i]&amp;&amp;c[j]&gt;c[i]) for (k=0;kc[j])) if j=i; (max_flow(n,m,source,sink)==last-mat[k][l]){ if (j&lt;0) return ret; set[ret][0]=k; if (j==sink) break; set[ret++][1]=l; for (v[j]=1,i=0;ic[i]&amp;&amp;c[j]&gt;c[i]) last-=mat[k][l]; } c[i]=mat[j][i]c[j])) for (j=0;jc[i]&amp;&amp;c[j]&gt;c[i]) if (m0[k][l]){ for (i=0;ic[j])) j=i; if (j&lt;0) return ret; if (j==sink) break; for (v[j]=1,i=0;ic[i]&amp;&amp;c[j]&gt;c[i]) c[i]=mat[j][i] 0; s += ar[i], i -= lowb(i)); if (i == na) return i; return s; while (tr[i].f != na) i = tr[i].f; } return i; /*==================================================*\ } | 二维树状数组 int merge(int rx, int ry){ // two root: rx, ry | INIT: c[][]置为0; Row,Col要赋初值 if (rx == na) return ry; \*==================================================*/ if (ry == na) return rx; const int N = 10000; if (tr[rx].key &gt; tr[ry].key) swap(rx, ry); int c[N][N]; int Row, Col; int r = merge(tr[rx].r, ry); inline int Lowbit(const int &amp;x){// x &gt; 0 tr[rx].r = r; tr[r].f = rx; return x&amp;(-x); if (tr[r].dist &gt; tr[tr[rx].l].dist) } swap(tr[rx].l, tr[rx].r); int Sum(int i, int j){ if (tr[rx].r == na) tr[rx].dist = 0; int tempj, sum = 0; else tr[rx].dist = tr[tr[rx].r].dist + 1; while( i &gt; 0 ){ return rx; // return new root tempj = j; } while( tempj &gt; 0 ){ int ins(int i, typec key, int root){ // add a new node(i, key) sum += c[i][tempj]; tr[i].key = key; tempj -= Lowbit(tempj); tr[i].l = tr[i].r = tr[i].f = na; } tr[i].dist = 0; i -= Lowbit(i); return root = merge(root, i); // return new root } } return sum; int del(int i) { // delete node i } if (i == na) return i; void Update(int i, int j, int num){ int x, y, l, r; int tempj; l = tr[i].l; r = tr[i].r; y = tr[i].f; while( i &lt;= Row ){ tr[i].l = tr[i].r = tr[i].f = na; tempj = j; tr[x = merge(l, r)].f = y; while( tempj &lt;= Col ){ if (y != na &amp;&amp; tr[y].l == i) tr[y].l = x; c[i][tempj] += num; if (y != na &amp;&amp; tr[y].r == i) tr[y].r = x; tempj += Lowbit(tempj); for ( ; y != na; x = y, y = tr[y].f) { } if (tr[tr[y].l].dist &lt; tr[tr[y].r].dist) i += Lowbit(i); swap(tr[y].l, tr[y].r); } if (tr[tr[y].r].dist + 1 == tr[y].dist) break; } tr[y].dist = tr[tr[y].r].dist + 1; /*==================================================*\ } | Trie 树(k 叉) if (x != na) return iroot(x); // return new root | INIT: init(); else return iroot(y); | 注: tree[i][tk]&gt;0时表示单词存在, 当然也可赋予它更多含义; } \*==================================================*/ node top(int root){ const int tk = 26, tb = 'a'; // tk叉; 起始字母为tb; 17 int top, tree[N][tk + 1]; // N: 最大结点个数 if (tree[rt].c == *s) break; void init(){ if (rt == 0) break; top = 1; } memset(tree[0], 0, sizeof(tree[0])); return lv; } } int search(char *s){ // 失败返回0 /*==================================================*\ for (int rt = 0; rt = tree[rt][*s - tb]; ) | 后缀数组 O(N * log N) if (*(++s) == 0) return tree[rt][tk]; | INIT: n = strlen(s) + 1; return 0; | CALL: makesa(); lcp(); } | 注: height[i] = lcp(sa[i], sa[i-1]); void insert(char *s, int rank = 1){ \*==================================================*/ int rt, nxt; char s[N]; // N &gt; 256 for (rt = 0; *s; rt = nxt, ++s) { int n, sa[N], height[N], rank[N], tmp[N], top[N]; nxt = tree[rt][*s - tb]; void makesa(){ // O(N * log N) if (0 == nxt) { int i, j, len, na; tree[rt][*s - tb] = nxt = top; na = (n &lt; 256 ? 256 : n); memset(tree[top], 0, sizeof(tree[top])); memset(top, 0, na * sizeof(int)); top++; for (i = 0; i &lt; n ; i++) top[ rank[i] = s[i] &amp; 0xff ]++; } for (i = 1; i &lt; na; i++) top[i] += top[i - 1]; } for (i = 0; i &lt; n ; i++) sa[ --top[ rank[i] ] ] = i; tree[rt][tk] = rank;//1表示存在0表示不存在，也可以赋予其其他含义 for (len = 1; len &lt; n; len &lt;&lt;= 1) { } for (i = 0; i &lt; n; i++) { void delete(char *s){ // 只做标记, 假定s一定存在 j = sa[i] - len; if (j &lt; 0) j += n; int rt = 0; tmp[ top[ rank[j] ]++ ] = j; for ( ; *s; ++s) rt = tree[rt][*s - tb]; } tree[rt][tk]=0; sa[ tmp[ top[0] = 0 ] ] = j = 0; } for (i = 1; i &lt; n; i++) { int prefix(char *s){ // 最长前 if (rank[ tmp[i] ] != rank[ tmp[i-1] ] || int rt = 0, lv; rank[ tmp[i]+len ]!=rank[ tmp[i-1]+len ]) for (lv = 0; *s; ++s, ++lv) { top[++j] = i; rt = tree[rt][*s - tb]; sa[ tmp[i] ] = j; if (rt == 0) break; } } memcpy(rank, sa , n * sizeof(int)); return lv; memcpy(sa , tmp, n * sizeof(int)); } if (j &gt;= n - 1) break; /*==================================================*\ } | Trie 树(左儿子右兄弟) } | INIT: init(); void lcp(){ // O(4 * N) \*==================================================*/ int i, j, k; int top; for (j = rank[height[i=k=0]=0]; i &lt; n - 1; i++, k++) struct trie { char c; int l, r, rk; } tree[N]; while (k &gt;= 0 &amp;&amp; s[i] != s[ sa[j-1] + k ]) void init(){ height[j] = (k--), j = rank[ sa[j] + 1 ]; top = 1; } memset(tree, 0, sizeof(tree[0])); /*==================================================*\ } | 后缀数组 O(N) int search(char *s) { // 失败返回0 | INIT: n = strlen(s) + 1; int rt; | CALL: makesa()求sa[]; for (rt = 0; *s; ++s) { \*==================================================*/ for (rt = tree[rt].l; rt; rt = tree[rt].r) char s[N]; if (tree[rt].c == *s) break; int n, sa[4*N], rank[N], height[N]; if (rt == 0) return 0; int buf[4*N], ct[N], sx[N], sax[N]; } return tree[rt].rk; inline bool leq(int a, int b, int x, int y) } { return (a &lt; x || a == x &amp;&amp; b &lt;= y); } void insert(char *s, int rk = 1){ //rk: 权或者标记 inline bool leq(int a, int b, int c, int x, int y, int z) int i, rt; { return (a &lt; x || a == x &amp;&amp; leq(b, c, y, z)); } for (rt = 0; *s; ++s, rt=i) { inline int geti(int t, int nx, int sa[]) for (i = tree[rt].l; i; i = tree[i].r) { return (sa[t]= 2. int rt; int i, j, e, p, t; for (rt = 0; *s; ++s) { int name = 0, cx = -1, cy = -1, cz = -1; for (rt = tree[rt].l; rt; rt = tree[rt].r) int nx = (n+2)/3, ny = (n+1)/3, nz = n/3, nxz = nx+nz; if (tree[rt].c == *s) break; int *syz = s + n + 3, *sayz = sa + n + 3; } tree[rt].rk = 0; for (i=0, j=0; i &lt; n + (nx - ny); i++) } if (i%3 != 0) syz[j++] = i; int prefix(char *s){ // 最长前 radix(syz , sayz, s+2, nxz, k); int rt = 0, lv; radix(sayz, syz , s+1, nxz, k); for (lv = 0; *s; ++s, ++lv) { radix(syz , sayz, s , nxz, k); for (rt = tree[rt].l; rt; rt = tree[rt].r) for (i = 0; i &lt; nxz; i++) { 18 if (s[ sayz[i] ] != cx || s[ sayz[i] + 1 ] != cy || } s[ sayz[i] + 2 ] != cz) { return 0; name++; cx = s[ sayz[i] ]; } cy = s[ sayz[i] + 1 ]; cz = s[ sayz[i] + 2 ]; void ReadIn(const int &amp;n){ } int i; if (sayz[i] % 3 == 1) syz[ sayz[i] / 3 ] = name; for( i=0; i &lt; n; ++i ) scanf("%d", &amp;a[i]); else syz[ sayz[i]/3 + nx ] = name; } } inline int max(const int &amp;arg1, const int &amp;arg2){ if (name &lt; nxz) { return arg1 &gt; arg2 ? arg1 : arg2; suffix(syz, sayz, nxz, name); } for (i = 0; i &lt; nxz; i++) syz[sayz[i]] = i + 1; void InitRMQ(const int &amp;n){ } else { int i, j; for (i = 0; i &lt; nxz; i++) sayz[syz[i] - 1] = i; for( d[0]=1, i=1; i &lt; 21; ++i ) d[i] = 2*d[i-1]; } for( i=0; i &lt; n; ++i ) st[i][0] = a[i]; for (i = j = 0; i &lt; nxz; i++) int k = int( log(double(n))/log(2) ) + 1; if (sayz[i] &lt; nx) sx[j++] = 3 * sayz[i]; for( j=1; j &lt; k; ++j ) radix(sx, sax, s, nx, k); for( i=0; i &lt; n; ++i ){ for (p=0, t=nx-ny, e=0; e &lt; n; e++) { if( i+d[j-1]-1 &lt; n ){ i = geti(t, nx, sayz); j = sax[p]; st[i][j] = max(st[i][j-1], if ( sayz[t] &lt; nx ? st[i+d[j-1]][j-1]); leq(s[i], syz[sayz[t]+nx], s[j], syz[j/3]) : } leq(s[i], s[i+1], syz[sayz[t]-nx+1], else break; // st[i][j] = st[i][j-1]; s[j], s[j+1], syz[j/3+nx]) ) { } sa[e] = i; } if (++t == nxz) { void Query(const int &amp;Q){ for (e++; p &lt; nx; p++, e++) int i; sa[e] = sax[p]; for( i=0; i &lt; Q; ++i ){ } int x, y, k; // x, y均为下标:0...n-1 } scanf("%d%d", &amp;x, &amp;y); else { k = int( log(double(y-x+1))/log(2.0) ); sa[e] = j; printf("%d\n", max(st[x][k], st[y-d[k]+1][k])); if (++p == nx) for (++e; t &lt; nxz; ++t, ++e) } sa[e] = geti(t, nx, sayz); } } /*==================================================*\ } | RMQ 离线算法 O(N*logN)+O(1)求解 LCA } | INIT: val[]置为待查询数组; initrmq(n); void makesa(){ \*==================================================*/ memset(buf, 0, 4 * n * sizeof(int)); const int N = 10001; // 1&lt;&lt;20; memset(sa, 0, 4 * n * sizeof(int)); int pnt[N], next[N], head[N]; // 邻接表 for (int i=0; i&gt; 1); j &lt; n; ++j, ++sk) { x = R[x]; y = R[y]; st[i][j] = st[i-1][j]; if( x &gt; y ){ if (sk &lt; n &amp;&amp; st[i][j] &gt; st[i-1][sk]) int tmp = x; x = y; y = tmp; st[i][j] = st[i-1][sk]; } } printf("%d\n", E[ Query(x, y) ]); for (j=(k&gt;&gt;1)+1; j &lt;= k; ++j) ln[j] = ln[k&gt;&gt;1] + 1; } } } for (j=(k&gt;&gt;1)+1; j &lt;= k; ++j) ln[j] = ln[k&gt;&gt;1] + 1; void DFS(int u, int d){ } visited[u] = 1; int query(int x, int y) // min of { val[x] ... val[y] } R[u] = id; E[id] = u; dep[id++] = d; { for( int i=head[u]; i != -1; i=next[i] ) int bl = ln[y - x + 1]; if( visited[ pnt[i] ] == 0 ){ return min(st[bl][x], st[bl][y-(1&lt;min int k = int( log(double(n))/log(2.0) ) + 1; | Call: ReadIn(n); InitRMQ(n); Query(Q); for( j=1; j &lt; k; ++j ) \*==================================================*/ for ( i=0; i &lt; id; ++i ){ const int N = 200001; if( i+d[j-1]-1 &lt; id ){ int a[N], d[20]; st[i][j] = dep[ st[i][j-1] ] &gt; int st[N][20]; dep[ st[i+d[j-1]][j-1] ] ? st[i+d[j-1]][j-1] : st[i][j-1]; int main(void){ } int n, Q; else break; // st[i][j] = st[i][j-1]; while( scanf("%d%d", &amp;n, &amp;Q) != EOF ) { } ReadIn(n); InitRMQ(n); Query(Q); } 19 int Query(int x, int y){ (1) 把作业按工序加工时间分成两个子集, int k; // x, y均为下标:0...n-1 第一个集合中在S1上做的时间比在S2上少, k = int( log(double(y-x+1))/log(2.0) ); 其它的作业放到第二个集合. return dep[ st[x][k] ] &gt; dep[ st[y-d[k]+1][k] ] ? 先完成第一个集合里面的作业, 再完成第二个集合里的作业. st[y-d[k]+1][k] : st[x][k]; (2) 对于第一个集合, 其中的作业顺序是按在S1上的时间的不减排列; } 对于第二个集合, 其中的作业顺序是按在S2上的时间的不增排列. /*==================================================*\ /*==================================================*\ | LCA 离线算法 O(E)+O(1) | 比较高效的大数 | INIT: id[]置为-1; g[]置为邻接矩阵; | &lt; , &lt;= , + , - , * , / , %(修改/的最后一行可 ) | CALL: for (i=0; i 0; r /= base) v[ln++] = r % base; if (id[i] == i) return i; } return id[i] = get(id[i]); bint&amp; operator = (const bint&amp; r) { } memcpy(this, &amp;r, (r.ln + 1) * sizeof(int));// ! void unin(int i, int j){ return *this; id[get(i)] = get(j); } } } ; void dfs(int rt, int n) { // 使用邻接表可优化为 O(E)+O(1) bool operator &lt; (const bint&amp; a, const bint&amp; b){ int i; int i; id[rt] = rt; if (a.ln != b.ln) return a.ln &lt; b.ln; for (i = 0; i &lt; n; ++i) if (g[rt][i] &amp;&amp; -1 == id[i]) { for (i = a.ln - 1; i &gt;= 0 &amp;&amp; a.v[i] == b.v[i]; i--); dfs(i, n); unin(i, rt); return i &lt; 0 ? 0 : a.v[i] &lt; b.v[i]; } } for (i = 0; i &lt; n; ++i) if (-1 != id[i]) bool operator &lt;= (const bint&amp; a, const bint&amp; b){ lcs[rt][i] = lcs[i][rt] = get(i); return !(b &lt; a); } } /*==================================================*\ bint operator + (const bint&amp; a, const bint&amp; b){ | 带权值的并查集 bint res; int i, cy = 0; | INIT: makeset(n); for (i = 0; i &lt; a.ln || i &lt; b.ln || cy &gt; 0; i++) { | CALL: findset(x); unin(x, y); if (i &lt; a.ln) cy += a.v[i]; \*==================================================*/ if (i &lt; b.ln) cy += b.v[i]; struct lset{ res.v[i] = cy % base; cy /= base; int p[N], rank[N], sz; } void link(int x, int y) { res.ln = i; if (x == y) return; return res; if (rank[x] &gt; rank[y]) p[y] = x; } else p[x] = y; bint operator - (const bint&amp; a, const bint&amp; b){ if (rank[x] == rank[y]) rank[y]++; bint res; int i, cy = 0; } for (res.ln = a.ln, i = 0; i &lt; res.ln; i++) { void makeset(int n) { res.v[i] = a.v[i] - cy; sz = n; if (i &lt; b.ln) res.v[i] -= b.v[i]; for (int i=0;i 0 &amp;&amp; res.v[res.ln - 1] == 0) res.ln--; int findset(int x) { return res; if (x != p[x]) p[x] = findset(p[x]); } return p[x]; bint operator * (const bint&amp; a, const bint&amp; b){ } bint res; res.ln = 0; void unin(int x, int y) { if (0 == b.ln) { res.v[0] = 0; return res; } link(findset(x), findset(y)); int i, j, cy; } for (i = 0; i &lt; a.ln; i++) { void compress() { for (j=cy=0; j &lt; b.ln || cy &gt; 0; j++, cy/= base) { for (int i = 0; i &lt; sz; i++) findset(i); if (j &lt; b.ln) cy += a.v[i] * b.v[j]; } if (i + j &lt; res.ln) cy += res.v[i + j]; }; if (i + j &gt;= res.ln) res.v[res.ln++] = cy % base; /*==================================================*\ else res.v[i + j] = cy % base; | 快速排序 } \*==================================================*/ } void ksort(int l, int h, int a[]){ return res; if (h &lt; l + 2) return; } int e = h, p = l; bint operator / (const bint&amp; a, const bint&amp; b) while (l &lt; h) { { // ! b != 0 while (++l &lt; e &amp;&amp; a[l] &lt;= a[p]); bint tmp, mod, res; while (--h &gt; p &amp;&amp; a[h] &gt;= a[p]); int i, lf, rg, mid; if (l &lt; h) swap(a[l], a[h]); mod.v[0] = mod.ln = 0; } for (i = a.ln - 1; i &gt;= 0; i--) { swap(a[h], a[p]); mod = mod * base + a.v[i]; ksort(p, h, a); ksort(l, e, a); for (lf = 0, rg = base -1; lf &lt; rg; ) { } mid = (lf + rg + 1) / 2; /*==================================================*\ if (b * mid &lt;= mod) lf = mid; | 2 台机器工作调度 else rg = mid - 1; \*==================================================*/ } 2台机器, n件任务, 必须先在S1上做, 再在S2上做. 任务之间先做后 res.v[i] = lf; 做任意. 求最早的完工时间. 这是一个经典问题: 2台机器的情况下有多 mod = mod - b * lf; 项式算法(Johnson算法), 3台或以上的机器是NP-hard的. Johnson算法: } 20 res.ln = a.ln; tmp = str1[i1--]-'0'+carry; while (res.ln &gt; 0 &amp;&amp; res.v[res.ln - 1] == 0) res.ln--; carry = tmp/10; return res; // return mod 就是%运算 str3[j++] = tmp%10+'0'; } } int digits(bint&amp; a) // 返回位数 while( i2 &gt;= 0 ){ { tmp = str2[i2--]-'0'+carry; if (a.ln == 0) return 0; carry = tmp/10; int l = ( a.ln - 1 ) * 4; str3[j++] = tmp%10+'0'; for (int t = a.v[a.ln - 1]; t; ++l, t/=10) ; } return l; if( carry ) str3[j++] = carry+'0'; } str3[j] = '\0'; bool read(bint&amp; b, char buf[]) // 读取失败返回0 { for( i=0, --j; i &lt; j; ++i, --j ){ if (1 != scanf("%s", buf)) return 0; ch = str3[i]; str3[i] = str3[j]; str3[j] = ch; int w, u, ln = strlen(buf); } memset(&amp;b, 0, sizeof(bint)); } if ('0' == buf[0] &amp;&amp; 0 == buf[1]) return 1; for (w = 1, u = 0; ln; ) { void Minus(char *str1, char *str2, char *str3) u += (buf[--ln] - '0') * w; {// str3 = str1-str2 (str1 &gt; str2) if (w * 10 == base) { int i, j, i1, i2, tmp, carry; b.v[b.ln++] = u; u = 0; w = 1; int len1 = strlen(str1), len2 = strlen(str2); } char ch; else w *= 10; } i1 = len1-1; i2 = len2-1; if (w != 1) b.v[b.ln++] = u; j = carry = 0; return 1; } while( i2 &gt;= 0 ){ void write(const bint&amp; v){ tmp = str1[i1]-str2[i2]-carry; int i; if( tmp &lt; 0 ) { printf("%d", v.ln == 0 ? 0 : v.v[v.ln - 1]); str3[j] = tmp+10+'0'; carry = 1; for (i = v.ln - 2; i &gt;= 0; i--) } printf("%04d", v.v[i]); // ! 4 == width else { printf("\n"); str3[j] = tmp+'0'; carry = 0; } } /*==================================================*\ --i1; --i2; ++j; | 普通的大数运算 } \*==================================================*/ while( i1 &gt;= 0 ){ const int MAXSIZE = 200; tmp = str1[i1]-'0'-carry; void Add(char *str1, char *str2, char *str3); if( tmp &lt; 0 ) { void Minus(char *str1, char *str2, char *str3); str3[j] = tmp+10+'0'; carry = 1; void Mul(char *str1, char *str2, char *str3); } void Div(char *str1, char *str2, char *str3); else{ int main(void){ str3[j] = tmp+'0'; carry = 0; char str1[MAXSIZE], str2[MAXSIZE], str3[MAXSIZE]; } while( scanf("%s %s", str1, str2) == 2 ){ --i1; ++j; if( strcmp(str1, "0") ){ } memset(str3, '0', sizeof(str3)); // !!!!! --j; Add(str1, str2, str3); while( str3[j] == '0' &amp;&amp; j &gt; 0 ) --j; printf("%s\n", str3); str3[++j] = '\0'; memset(str3, '0', sizeof(str3)); Minus(str1, str2, str3); for( i=0, --j; i &lt; j; ++i, --j ){ printf("%s\n", str3); ch = str3[i]; str3[i] = str3[j]; str3[j] = ch; memset(str3, '0', sizeof(str3)); } Mul(str1, str2, str3); } printf("%s\n", str3); void Mul(char *str1, char *str2, char *str3){ memset(str3, '0', sizeof(str3)); int i, j, i1, i2, tmp, carry, jj; Div(str1, str2, str3); int len1 = strlen(str1), len2 = strlen(str2); printf("%s\n", str3); char ch; } else { jj = carry = 0; if( strcmp(str2, "0") ) printf("%s\n-%s\n0\n0\n", str2, str2); for( i1=len1-1; i1 &gt;= 0; --i1 ){ else printf("0\n0\n0\n0\n"); j = jj; } for( i2=len2-1; i2 &gt;= 0; --i2, ++j ){ } tmp = return 0; (str3[j]-'0')+(str1[i1]-'0')*(str2[i2]-'0')+carry; } if( tmp &gt; 9 ){ void Add(char *str1, char *str2, char *str3) carry = tmp/10; str3[j] = tmp%10+'0'; {// str3 = str1 + str2; } int i, j, i1, i2, tmp, carry; else { int len1 = strlen(str1), len2 = strlen(str2); str3[j] = tmp+'0'; carry = 0; char ch; } } i1 = len1-1; i2 = len2-1; if( carry ) { j = carry = 0; str3[j] = carry+'0'; carry = 0; ++j; } for( ; i1 &gt;= 0 &amp;&amp; i2 &gt;= 0; ++j, --i1, --i2 ){ ++jj; tmp = str1[i1]-'0'+str2[i2]-'0'+carry; } carry = tmp/10; --j; str3[j] = tmp%10+'0'; while( str3[j] == '0' &amp;&amp; j &gt; 0 ) --j; } str3[++j] = '\0'; while( i1 &gt;= 0 ){ 21 for( i=0, --j; i &lt; j; ++i, --j ){ d[i] = str1[i1+1]; lend = i+1; ch = str3[i]; str3[i] = str3[j]; str3[j] = ch; ++j; } }//else } }//for i = tag = 0; void Div(char *str1, char *str2, char *str3){ while( c[i] == 0 ) ++i; int i1, i2, i, j, jj, tag, carry, cf, c[MAXSIZE]; for( ; i &lt; j; ++i, ++tag ) str3[tag] = c[i]+'0'; int len1 = strlen(str1), len2 = strlen(str2), lend; str3[tag] = '\0'; char d[MAXSIZE]; } /*==================================================*\ memset(c, 0, sizeof(c)); | 最长公共递增子序列 O(n^2) memcpy(d, str1, len2); | f记录路径，DP记录长度, 用a对b扫描，逐步最优化。 ZOJ2432 lend = len2; j = 0; \*==================================================*/ int f[N][N], dp[N]; for( i1=len2-1; i1 &lt; len1; ++i1 ){ int gcis(int a[], int la, int b[], int lb, int ans[]) if( lend &lt; len2 ){ { // a[1卨a], b[1卨b] d[lend] = str1[i1+1]; c[j] = 0; int i, j, k, mx; ++j; ++lend; memset(f, 0, sizeof(f)); } memset(dp, 0, sizeof(dp)); else if( lend == len2 ){ for (i = 1; i &lt;= la; i++) { jj = 1; memcpy(f[i], f[i-1], sizeof(f[0])); for( i=0; i &lt; lend; ++i ){ for (k = 0, j = 1; j &lt;= lb; j++) { if( d[i] &gt; str2[i] ) break; if (b[j-1] &lt; a[i-1] &amp;&amp; dp[j] &gt; dp[k]) k = j; else if( d[i] &lt; str2[i] ){ if (b[j-1] == a[i-1] &amp;&amp; dp[k] + 1 &gt; dp[j]) { jj = 0; break; dp[j] = dp[k] + 1, } f[i][j] = i * (lb + 1) + k; } } if( jj == 0 ){ } d[lend] = str1[i1+1]; c[j] = 0; } ++j; ++lend; for (mx = 0, i = 1; i &lt;= lb; i++) continue; if (dp[i] &gt; dp[mx]) mx = i; } for(i=la*lb+la+mx, j=dp[mx]; j; } i=f[i/(lb+1)][i%(lb+1)],j--) if( jj==1 || lend &gt; len2 ){ ans[j-1] = b[i % (lb + 1) - 1]; cf = jj=0; return dp[mx]; while( d[jj] &lt;= '0' &amp;&amp; jj &lt; lend ) ++jj; } if( lend-jj &gt; len2 ) cf = 1; /*==================================================*\ else if( lend-jj &lt; len2 ) cf = 0; | 0-1 分数规划 else{ \*==================================================*/ i2 = 0; cf = 1; t1 * x1 + t2 * x2 + ... + tn * xn for( i=jj; i &lt; lend; ++i ){ r = --------------------------------- if( d[i] &lt; str2[i2] ){ c1 * x1 + c2 * x2 + ... + cn * xn cf = 0; break; 给定t[1..n], c[1..n], 求x[1..n]使得sigma(xi)=k且r最大(小). } 为了让r最大, 先设计子问题z(r) = (t1 * x1 + .. + tn * xn) - r * else if( d[i] &gt; str2[i2] ){ (c1 * xn + .. + cn * xn); break; 假设r的最优值为R. 则有: } z(r) &lt; 0 当且仅当 r &gt; R; ++i2; z(r) = 0 当且仅当 r = R; } z(r) &gt; 0 当且仅当 r &lt; R; }//else 于是可二分求 R. while( cf ){ /*==================================================*\ i2 = len2-1; cf = 0; | 最长有序子序列（递增/递减/非递增/非递减） for( i=lend-1; i &gt;= lend-len2; --i ){ \*==================================================*/ d[i] = d[i]-str2[i2]+'0'; const int N = 1001; if( d[i] &lt; '0' ){ int a[N], f[N], d[N]; // d[i]用于记录 a[0...i]的最大长度 d[i] = d[i]+10; carry = 1; int bsearch(const int *f, int size, const int &amp;a) { --d[i-1]; int l=0, r=size-1; } while( l &lt;= r ){ else carry = 0; int mid = (l+r)/2; --i2; if( a &gt; f[mid-1] &amp;&amp; a &lt;= f[mid] ) return mid;// &gt;&amp;&amp;&lt;= 换 } 为: &gt;= &amp;&amp; &lt; ++c[j]; jj=0; else if( a &lt; f[mid] ) r = mid-1; while( d[jj] &lt;= '0' &amp;&amp; jj &lt; lend ) ++jj; else l = mid+1; if( lend-jj &gt; len2 ) cf = 1; } else if( lend-jj &lt; len2 ) cf = 0; } else{ int LIS(const int *a, const int &amp;n){ i2 = 0; cf = 1; int i, j, size = 1; for( i=jj; i &lt; lend; ++i ){ f[0] = a[0]; d[0] = 1; if( d[i] &lt; str2[i2] ){ for( i=1; i &lt; n; ++i ){ cf = 0; break; if( a[i] &lt;= f[0] ) j = 0; // &lt;= 换为: &lt; } else if( a[i] &gt; f[size-1] ) j = size++;// &gt; 换为: &gt;= else if( d[i] &gt; str2[i2] ){ else j = bsearch(f, size, a[i]); break; f[j] = a[i]; d[i] = j+1; } } ++i2; return size; } } int main(void){ }//else int i, n; }//while while( scanf("%d",&amp;n) != EOF ){ jj = 0; for( i=0; i &lt; n; ++i ) scanf("%d", &amp;a[i]); while( d[jj] &lt;= '0' &amp;&amp; jj &lt; lend ) ++jj; printf("%d\n", LIS(a, n)); // 求最大递增/上升子序列(如果为 for( i=0;i &lt; lend-jj; ++i ) d[i] = d[i+jj]; 最大非降子序列,只需把上面的注释部分给与替换) 22 } for( m=1; m &lt;= n; m++ ) return 0; for( i=0; i &lt; 8; i++ ) } for( j=0; j &lt; 8; j++ ) /*==================================================*\ for( k=0; k &lt; 8; k++ ) | 最长公共子序列 for( l=0; l &lt; 8; l++ ){ \*==================================================*/ if( (k-i+1)*(l-j+1) &lt; m ) int LCS(const char *s1, const char *s2) C[m][i][j][k][l] = oo; {// s1:0...m, s2:0...n else{ int m = strlen(s1), n = strlen(s2); if( m == 1 ){ int i, j; C[m][i][j][k][l] = a[0][0] = 0; pow( (caluate(i,j,k,l)-ans), 2 ); for( i=1; i &lt;= m; ++i ) a[i][0] = 0; } for( i=1; i &lt;= n; ++i ) a[0][i] = 0; else{ for( i=1; i &lt;= m; ++i ) dp(m, i, j, k, l); for( j=1; j &lt;= n; ++j ){ } if(s1[i-1]==s2[j-1]) a[i][j] = a[i-1][j-1]+1; } else if(a[i-1][j]&gt;a[i][j-1])a[i][j]= a[i-1][j]; } else a[i][j] = a[i][j-1]; printf("%.3lf\n", sqrt(C[n][0][0][7][7]/n)); } } return a[m][n]; return 0; } } /*==================================================*\ void input(void){ | 最少找硬币问题（贪心策略-深搜实现） int i, j; \*==================================================*/ double sum = 0; int value[7] = {100, 50, 20, 10, 5, 2, 1}; for( i=0; i &lt; 8; i++ ) int count[7]; // count[i]:value[i]硬币的个数 for( j=0; j &lt; 8; j++ ){ int res[7]; scanf("%d", &amp;map[i][j]); bool flag; sum += map[i][j]; int main(void){ } //... ans = sum/double(n); // 平均值 flag = false; // 标识是否已经找到结果 } for( i=0; i &lt; 7; ++i ) res[i] = 0; void reset(void){ DFS(pay, 0); // pay为要找的钱数 int i, j, k, l, m; if( flag ){ for( m=0; m &lt;= n; m++ ) printf("Accept\n%d", res[0]); for( i=0; i &lt; 8; i++ ) for( i=1; i &lt; 7; ++i ) printf(" %d", res[i]); for( j=0; j &lt; 8; j++ ) printf("\n"); for( k=0; k &lt; 8; k++ ) } for( l=0; l &lt; 8; l++ ) else printf("Refuse\n"); // 无法正好找钱 C[m][i][j][k][l] = 0; //... } } double caluate(int i1, int j1, int i2, int j2){ void DFS(int total, int p){ double sum=0; if( flag ) return ; int i, j; if( p == 7 ) { for( i=i1; i &lt;= i2; i++ ) if( total == 0 ) flag = true; for( j=j1; j &lt;= j2; j++ ) sum += map[i][j]; return ; return sum; } } int i, max = total/value[p]; void dp(int m, int si, int sj, int ei, int ej){ if( max &gt; count[p] ) max = count[p]; int i, j; for( i=max; i &gt;= 0; --i ){ double mins = oo; res[p] = i; for( j=sj; j &lt; ej; j++ ) {// 竖刀 DFS(total-i*value[p], p+1); mins = min(mins, if( flag ) return ; C[1][si][sj][ei][j]+C[m-1][si][j+1][ei][ej]); } mins = min(mins, } C[m-1][si][sj][ei][j]+C[1][si][j+1][ei][ej]); /*==================================================*\ } | 棋盘分割 for( i=si; i &lt; ei; i++ ) { // 横刀 | 将一个８*８的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部 mins = min(mins, | 分也是矩形，再将剩下的部分继续如此分割，这样割了(n-1)次后，连同最 C[1][si][sj][i][ej]+C[m-1][i+1][sj][ei][ej]); | 后剩下的矩形棋盘共有 n 块矩形棋盘。(每次切割都只能沿着棋盘格子的边 mins = min(mins, | 进行) 原棋盘上每一格有一分值，一块矩形棋盘的总分为其所含各格分 | C[m-1][si][sj][i][ej]+C[1][i+1][sj][ei][ej]); | 值之和。现在需要把棋盘按上述规则分割成 n 块矩形棋盘，并使各矩形棋 } ||盘总分的均方差最小。 均方差叄渲衅骄祬，xi 为第 i 块矩形棋盘的| C[m][si][sj][ei][ej] = mins; | 总分。请编程对给出的棋盘及 n，求出 O'的最小值。 } | POJ 1191 棋盘分割 /*==================================================*\ \*==================================================*/ | 汉诺塔 #define min(a, b) ( (a) &lt; (b) ? (a) : (b) ) | 1,2,...,n 表示 n 个盘子．数字大盘子就大．n 个盘子放在第１根柱子上．大 const int oo = 10000000; | 盘不能放在小盘上．在第１根柱子上的盘子是 a[1],a[2],...,a[n]. int map[8][8]; |a[1]=n,a[2]=n-1,...,a[n]=1.即 a[1]是最下面的盘子．把 n 个盘子 double C[16][8][8][8][8];//c[k][si][ei][sj][ej]: 对 矩 阵 ||移动到第 3 根柱子．每次只能移动 1 个盘子，且大盘不能放在小盘上．问| //map[si...sj][ei...ej]分割成 k 个矩形(切割 k-1 刀)的结果 第 m 次移动的是哪一个盘子，从哪根柱子移到哪根柱子.例如：n=3,m=2. 回 double ans; // 平均值 |答是 ：2 1 2，即移动的是 2 号盘，从第 1 根柱子移动到第 2 根柱子 。 int n; // 分成 n 块矩形棋盘 | HDU 2511 汉诺塔 X void input(void); \*==================================================*/ void reset(void); 一号柱有 n 个盘子,叫做源柱.移往 3 号柱,叫做目的柱.2 号柱叫做中间柱. double caluate(int i1, int j1, int i2, int j2); 全部移往 3 号柱要 f(n) =（2^n）- 1 次. void dp(int m, int si, int sj, int ei, int ej); 最大盘 n 号盘在整个移动过程中只移动一次,n-1 号移动 2 次,i 号盘移动 2^(n-i)次. int main(void){ 1 号盘移动次数最多,每 2 次移动一次. int m, i, j, k, l; 第 2k+1 次移动的是 1 号盘,且是第 k+1 次移动 1 号盘. while( scanf("%d", &amp;n) != EOF ){ 第 4k+2 次移动的是 2 号盘,且是第 k+1 次移动 2 号盘. input(); reset(); ...... 23 第(2^s)k+2^(s-1)移动的是 s 号盘,这时 s 号盘已被移动了 k+1 次. n). For each query, determine the most frequent value among 每 2^s 次就有一次是移动 s 号盘. the integers ai , ... , aj. POJ 3368 Frequent values 第一次移动 s 号盘是在第 2^(s-1)次. 求区间中数出现的最大频率 第二次移动 s 号盘是在第 2^s+2^(s-1)次. 方法一:线段树. ...... 先离散化。因为序列是升序，所以先将所有值相同的点缩成一点。这样n规第 k+1 次移动 s 号盘是在第 k*2^s+2^(s-1)次. 模就缩小了。建立一个数据结构 1--2--3--1 叫做顺时针方向,1--3--2--1 叫做逆时针方向. 记录缩点的属性：在原序列中的值id,和该值有多少个num 最大盘 n 号盘只移动一次:1--3,它是逆时针移动. 比如序列 n-1 移动 2 次:1--2--3,是顺时针移动. 10 如果 n 和 k 奇偶性相同,则 k 号盘按逆时针移动,否则顺时针. -1 -1 1 1 1 1 3 10 10 10 int main(void){ 缩点后为:下标 1 2 3 4 int i, k; id -1 1 3 10 scanf("%d", &amp;k); num 2 4 1 3 for( i=0; i &lt; k; i++ ){ 然后建树，树的属性有区间最大值(也就是频率)和区间总和。 int n, l; 接受询问的时候。接受的是原来序列的区间[be,ed] int64 m, j; 我们先搜索一下两个区间分别在离散化区间后的下标。 __int64 s, t; 比如接受[2,3]时候相应下标区间就是[1,2];[3,10]的相应下标区间是 scanf("%d%I64d", &amp;n, &amp;m); [2,4]; s = 1; t = 2; 处理频率的时候，我们发现两个极端，也就是左右两个端点的频率不好处理。 for( l=1; l &lt;= n; l++ ){ 因为它们是不完全的频率 if( m%t == s ) break; 也就是说有部分不在区间内。但是如果对于完全区间，也就是说左右端点下 s = t; t *= 2; 标值完全在所求区间内。 } 比如上例的[2,3]不好处理。但是如果是[1,6]，或是[1,10]就很好处理 printf("%d ", l); 了，只要像RMQ一样询问区间大值就可以了。 j = m/t; 方法二:RMQ. 我们可以转化一下问题。将左右端点分开来考虑。 if( n%2 == l%2 ){// 逆时针 现在对于离散后的询问区间我们可以分成3个部分.左端点，中间完全区间， if( (j+1)%3 == 0 ) printf("2 1\n"); 右端点。 if( (j+1)%3 == 1 ) printf("1 3\n"); 对于中间完全区间线段树或RMQ都能轻松搞定。只要特判一左右的比较一下 if( (j+1)%3 == 2 ) printf("3 2\n"); 就得最后解了。 } \*==================================================*/ else{// 逆时针 const int N = 100010; if( (j+1)%3 == 0 ) printf("3 1\n"); struct NODE{ if( (j+1)%3 == 1 ) printf("1 2\n"); int b, e; // 区间[b, e] if( (j+1)%3 == 2 ) printf("2 3\n"); int l, r; // 左右子节点下标 } int number;// 区间内的最大频率值 } int last; // 以 data[e] 结 尾 且 与 data[e] 相 同 的 个 return 0; 数:data[e-last+1]...data[e] } }node[N*2+1]; /*==================================================*\ int len, data[N]; | STL 中的 priority_queue int main(void){ \*==================================================*/ int n; priority_queue&lt; string, vector, greater &gt; while( scanf("%d", &amp;n), n ){ asc; // 按值小的优先 int i, q, a, b; priority_queue&lt; string, vector, less &gt; desc; scanf("%d", &amp;q); // 按值大的优先 for( i=0; i &lt; n; i++ ) scanf("%d", &amp;data[i]); /*==================================================*\ len = 0; // 下标 | 堆栈 build(0, n-1); \*==================================================*/ while( q-- ){ const int MAXSIZE = 10000; scanf("%d%d", &amp;a, &amp;b); int a[MAXSIZE]，heapsize; printf("%d\n", query(0, a-1, b-1)); // 输出区 inline void swap(int i, int j){ 间的最大频率值,而非 data[] int temp = a[i]; a[i] = a[j]; a[j] = temp; } } } inline int Parent(int i){ return i &gt;&gt; 1; } return 0; inline int Left(int i){ return 1 &lt;&lt; i; } } inline int Right(int i){ return (1 &lt;&lt; i) + 1; } int build(int a, int b){ // 建立线段树 // 保持堆的性质 int temp = len, mid = (a+b)/2; void MaxHeapify(int i){ node[temp].b = a, node[temp].e = b; int l = Left(i), r = Right(i), largest; len++; if( l &lt;= heapsize &amp;&amp; a[l] &gt; a[i] ) largest = l; if( a == b ){ else largest = i; node[temp].number = 1; if( r &lt;= heapsize &amp;&amp; a[r] &gt; a[largest] ) largest = r; node[temp].last = 1; // if( largest != i ){ return temp; swap(i, largest); MaxHeapify(largest); } } node[temp].l = build(a, mid); } node[temp].r = build(mid+1, b); void BuildMaxHeap(int *arr, int n){ heapsize = n; int left_c=node[temp].l, right_c=node[temp].r, p, for( int i=heapsize/2; i &gt; 0; --i ) MaxHeapify(i); lcount=0, rcount=0, rec, max=0; } void HeapSort(int *arr, int n){ rec = data[mid]; p = mid; BuildMaxHeap(arr, n); while( p &gt;= a &amp;&amp; data[p] == rec ) { p--, lcount++; } for( int i=n; i &gt; 1; --i ){ node[left_c].last = lcount; // swap(1, i); heapsize--; MaxHeapify(1); rec = data[mid+1]; p = mid+1; } while( p &lt;= b &amp;&amp; data[p] == rec ) { p++, rcount++; } } node[right_c].last = rcount;// /*==================================================*\ | 区间最大频率 if( data[mid] == data[mid+1] ) max = lcount+rcount; | You are given a sequence of n integers a1 , a2 , ... , an in non-decreasing order. In addition to that, you are given if( node[left_c].number &gt; max ) max = several queries consisting of indices i and j (1 ≤ i ≤ j ≤ node[left_c].number; 24 if( node[right_c].number &gt; max ) max = | if( m-n-1 &gt;= 0 ) f(n+1, m) -= f(n, m-n-1). node[right_c].number; | JOJ 2443 node[temp].number = max; \*==================================================*/ const int N = 1001; return temp; const int C = 10001; } const long MOD = 1000000007; int query(int index, int a, int b){ long arr[N][C]; int begin=node[index].b, end=node[index].e, long long temp; mid=(begin+end)/2; int main(void){ if( a == begin &amp;&amp; b == end ) return node[index].number; int i, j; arr[1][0] = arr[2][0] = arr[2][1] = 1; if( a &gt; mid ) return query(node[index].r, a, b); for( i=3; i &lt; N; ++i ){ if( b &lt; mid+1 ) return query(node[index].l, a, b); arr[i][0] = 1; long h = i*(i+1)/2+1; int temp1, temp2, max; if( h &gt; C ) h = C; if( node[index].l &gt; 0 ) temp1 = query(node[index].l, for( j=1; j &lt; h; ++j ){ a, mid); temp = arr[i-1][j] + arr[i][j-1]; if( node[index].r &gt; 0 ) temp2 = query(node[index].r, arr[i][j] = temp%MOD; mid+1, b); if( j-i &gt;= 0 ) { max = temp1 &gt; temp2 ? temp1 : temp2; arr[i][j] -= arr[i-1][j-i]; if( arr[i][j] &lt; 0 ) if( data[mid] != data[mid+1] ) return max; {//注意：由于 arr[i][j]和 arr[i-1][j-i]都是 模过的，所以可能会得到负数 temp1 = node[ node[index].l ].last &gt; (mid-a+1) ? arr[i][j] += MOD; (mid-a+1) : node[ node[index].l ].last; } temp2 = node[ node[index].r ].last &gt; (b-mid) ? (b-mid) : } node[ node[index].r ].last; } if( max &lt; temp1+temp2 ) max = temp1+temp2; } while( scanf("%d %d", &amp;i, &amp;j) != EOF ){ return max; printf("%ld\n", arr[i][j]); } } /*==================================================*\ return 0; | 取第 k 个元素 } | k=0..n-1,平均复杂度 O(n) 注意 a[]中的顺序被改变 /*==================================================*\ \*==================================================*/ | 二分查找 #define _cp(a,b) ((a)&lt;(b)) \*==================================================*/ typedef int elem_t; // 在[l, r)范围内查找值 v，返回下标 elem_t kth_element(int n,elem_t* a,int k){// a[0卬-1] // 假设 a 数组已经按从小到大排序 elem_t t,key; // 失败返回-1 int l=0,r=n-1,i,j; int bs(int a[], int l, int h, int v){ while (l&gt;1];i&gt; 1; for (i++;_cp(a[i],key);i++); if (a[m] == v) return m; if (ij) l=j+1; } else r=j; return -1; } } return a[k]; /*==================================================*\ } | 二分查找（大于等于 v 的第一个值） /*==================================================*\ \*==================================================*/ | 归并排序求逆序数 // 传入参数必须 l &lt;= h |（也可以用树状数组做） // 返回值 l 总是合理的 | a[0卬-1] cnt=0; call: MergeSort(0, n) int bs(int a[], int l, int h, int v{ \*==================================================*/ int m; void MergeSort(int l, int r){ while ( l &lt; h ){ int mid, i, j, tmp; m = ( l + h ) &gt;&gt; 1; if( r &gt; l+1 ){ if (a[m] &lt; v) l=m+1; mid = (l+r)/2; else h=m; MergeSort(l, mid); } MergeSort(mid, r); return l; tmp = l; } for( i=l, j=mid; i &lt; mid &amp;&amp; j &lt; r; ){ /*==================================================*\ if( a[i] &gt; a[j] ){ | 所有数位相加 c[tmp++] = a[j++]; | dig(x) := x if 0 &lt;= x &lt;= 9 cnt += mid-i; // | dig(x) := dig(sum of digits of x) if x &gt;= 10 } \*==================================================*/ else c[tmp++] = a[i++]; 方法一：模拟 } int dig(int x){ if( j &lt; r ) for( ; j &lt; r; ++j ) c[tmp++] = a[j]; if( x &lt; 10 ) return x; else for( ; i &lt; mid; ++i ) c[tmp++] = a[i]; int sum = 0; for ( i=l; i &lt; r; ++i ) a[i] = c[i]; while( x ) { sum += x%10; x /= 10; } } return dig(sum); } } /*==================================================*\ 方法二：公式 【不太明白...】 | 逆序数推排列数 int dig(int x){ return (x+8)%9+1; } | 动态规划：f(n,m)表示逆序数为 m 的 n 元排列的个数，则 | f(n+1,m)=f(n,m)+f(n,m-1)+...+f(n,m-n)(当 b&lt;0 时，f(a,b)=0) | 优化 又考虑到如果直接利用上式计算时间复杂度为 O(n^3)，我们分析上 | 式不难发现 f(n+1,m)=f(n,m)+f(n+1,m-1) 25 for (i = 0; i &lt; k; i++) { m = n / w[i]; Number 数论 d = extgcd(w[i], m, x, y); a = (a + y * m * b[i]) % n; } if (a &gt; 0) return a; else return (a + n); } /*==================================================*\ /*==================================================*\ |递推求欧拉函数 phi(i) | 筛素数 [1..n] \*==================================================*/ \*==================================================*/ for (i = 1; i &lt;= maxn; i++) phi[i] = i; bool is[N]; int prm[M]; for (i = 2; i &lt;= maxn; i += 2) phi[i] /= 2; int getprm(int n){ for (i = 3; i &lt;= maxn; i += 2) if(phi[i] == i) { int i, j, k = 0; for (j = i; j &lt;= maxn; j += i) int s, e = (int)(sqrt(0.0 + n) + 1); phi[j] = phi[j] / i * (i - 1); memset(is, 1, sizeof(is)); } prm[k++] = 2; is[0] = is[1] = 0; /*==================================================*\ for (i = 4; i &lt; n; i += 2) is[i] = 0; |单独求欧拉函数 phi(x) for (i = 3; i &lt; e; i += 2) if (is[i]) { \*==================================================*/ prm[k++] = i; unsigned euler(unsigned x) for (s = i * 2, j = i * i; j &lt; n; j += s) {// 就是公式 is[j] = 0; unsigned i, res=x; // 因为j是奇数，所以+奇数i后是偶数，不必处理！ for (i = 2; i &lt; (int)sqrt(x * 1.0) + 1; i++) } if(x%i==0) { for ( ; i &lt; n; i += 2) if (is[i]) prm[k++] = i; res = res / i * (i - 1); return k; // 返回素数的个数 while (x % i == 0) x /= i; // 保证i一定是素数 } } /*==================================================*\ if (x &gt; 1) res = res / x * (x - 1); | 高效求小范围素数 [1..n] return res; \*==================================================*/ } int prime[500],num,boo[2500]; /*==================================================*\ for( i=2; i &lt;= 2300; i++ ) boo[i] = 0; | GCD 最大公约数 for( i=2; i &lt;= 50; i++ ) \*==================================================*/ for( k=i*2; k &lt;= 2300; k += i ) int gcd(int x, int y){ boo[k] = 1; if (!x || !y) return x &gt; y ? x : y; int num = 0; for (int t; t = x % y; x = y, y = t); for( i=2; i &lt;= 2300; i++ ) return y; if( boo[i] == 0 ) prime[num++] = i; } /*==================================================*\ /*==================================================*\ | 随机素数测试(伪素数原理) | 快速 GCD | CALL: bool res = miller(n); \*==================================================*/ | 快速测试n是否满足素数的'必要'条件, 出错概率很小; int kgcd(int a, int b){ | 对于任意奇数 n&gt;2 和正整数 s, 算法出错概率 &lt;= 2^(-s); if (a == 0) return b; \*==================================================*/ if (b == 0) return a; int witness(int a, int n) if (!(a &amp; 1) &amp;&amp; !(b &amp; 1)) return kgcd(a&gt;&gt;1, b&gt;&gt;1) &lt;&lt; 1; { else if (!(b &amp; 1)) return kgcd(a, b&gt;&gt;1); int x, d=1, i = ceil(log(n - 1.0) / log(2.0)) - 1; else if (!(a &amp; 1)) return kgcd(a&gt;&gt;1, b); for ( ; i &gt;= 0; i--) { else return kgcd(abs(a - b), min(a, b)); x = d; d = (d * d) % n; } if (d==1 &amp;&amp; x!=1 &amp;&amp; x!=n-1) return 1; /*==================================================*\ if (((n-1) &amp; (1&lt; 0) d = (d * a) % n; | 扩展 GCD } | 求x, y使得gcd(a, b) = a * x + b * y; return (d == 1 ? 0 : 1); \*==================================================*/ } int extgcd(int a, int b, int &amp; x, int &amp; y){ int miller(int n, int s = 50) if (b == 0) { x=1; y=0; return a; } { int d = extgcd(b, a % b, x, y); if (n == 2) return 1; int t = x; x = y; y = t - a / b * y; if ((n % 2) == 0) return 0; return d; int j, a; } for (j = 0; j &lt; s; j++) { /*==================================================*\ a = rand() * (n-2) / RAND_MAX + 1; | 模线性方程 a * x = b (% n) // rand()只能随机产生[0, RAND_MAX)内的整数 \*==================================================*/ // 而且这个RAND_MAX只有32768直接%n的话永远也产生不了 void modeq(int a, int b, int n) // ! n &gt; 0 // [RAND-MAX, n)之间的数 { if (witness(a, n)) return 0; int e, i, d, x, y; } d = extgcd(a, n, x, y); return 1; if (b % d &gt; 0) printf("No answer!\n"); } else { /*==================================================*\ e = (x * (b / d)) % n; | 组合数学相关 for (i = 0; i &lt; d; i++) // !!! here x maybe &lt; 0 \*==================================================*/ printf("%d-th ans: %d\n", i+1, (e+i*(n/d))%n); 1. {1, 2, ... n}的r组合a1, a2, ... ar出现在所有r组合中的字典 } 序位置编号, C(n, m)表示n中取m的组合数; index = } C(n, r) - C(n - a1, r) - C(n - a2, r-1) - ... - C(n - ar, 1) /*==================================================*\ | 模线性方程组 2. k * C(n, k) = n * C(n-1, k-1); | a=B[1](% W[1]); a=B[2](% W[2]); ... a=B[k](% W[k]); C(n, 0) + C(n, 2) + ... = C(n, 1) + C(n, 3) + ... | 其中W, B已知，W[i]&gt;0且W[i]与W[j]互质, 求a; (中国余数定理) 1 * C(n, 1) + 2 * C(n, 2) + ... + n * C(n, n) = n * 2^(n-1) \*==================================================*/ int china(int b[], int w[], int k){ 3. Catalan数: C_n = C(2*n, n) / (n+1) int i, d, x, y, m, a = 0, n = 1; C_n = (4*n-2)/(n+1) * C_n-1 for (i = 0; i &lt; k; i++) n *= w[i]; // ! 注意不能overflow C_1 = 1 26 --r; 4. 第二类Stirling数: S(p, k) = k * S(p-1, k) + S(p-1, k-1). int res = (r-l+1)*(col[j]-i+1); S(p, 0) = 0, (p&gt;=1); S(p, p) = 1, (p&gt;=0); if( res &gt; max ) max = res; 且有 S(p, 1) = 1, (p&gt;=1); } S(p, 2) = 2^(p-1) - 1, (p&gt;=2); } S(p, p-1) = C(p, 2); return max; 含义: 将p个元素划分到k个同样的盒子, 每个盒子非空的方法数. } 1 k /*==================================================*\ S(p, k) = --- * sigma((-1)^t * C(k, t) * (k-t)^p) | 约瑟夫环问题（数学方法） k! t=0 | n 个人(编号 1...n),先去掉第 m 个数,然后从 m+1 个开始报 1, | 报到 k 的退出,剩下的人继续从 1 开始报数.求胜利者的编号. 5. Bell数: B_p = S(p, 0) + S(p, 1) + ... + S(p, p) | POJ 3157 And Then There Was One B_p = C(p-1,0)*B_0 + C(p-1,1)*B_1 + ... C(p-1,p-1)*B_(p-1) \*==================================================*/ int main(void){ 6. 第一类stirling数: int n, k, m; s(p, k)是将p个物体排成k个非空的循环排列的方法数. while( scanf("%d%d%d", &amp;n, &amp;k, &amp;m), n || k || m ){ (或者: 把p个人排成k个非空圆圈的方法数) int i, d, s=0; s(p, k) = (p-1) * s(p-1, k) + s(p-1, k-1); for( i=2; i &lt;= n; ++i ) s = (s+k)%i; /*==================================================*\ k = k%n; if( k == 0 ) k=n; | Polya 计数 d = (s+1) + (m-k); | c种颜色的珠子, 组成长为s的项链, 项链没有方向和起始位置; if( d &gt;= 1 &amp;&amp; d &lt;= n ) printf("%d\n", d); \*==================================================*/ else if( d &lt; 1 ) printf("%d\n", n+d); int gcd (int a, int b) { return b ? gcd(b,a%b) : a; } else if( d &gt; n ) printf("%d\n", d%n); int main (void){ } int c, s; return 0; while (scanf("%d%d", &amp;c, &amp;s)==2) { } int k; /*==================================================*\ long long p[64]; p[0] = 1; // power of c | 约瑟夫环问题（数组模拟） for (k=0 ; k r ) r = n-r; // C(n, r) = C(n, n-r) } int i, j, s = 1; /*==================================================*\ for( i=0, j=1; i &lt; r; ++i ){ | 取石子游戏 1 s *= (n-i); | 1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取 for( ; j &lt;= r &amp;&amp; s%j == 0; ++j ) s /= j; |完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输 } |出"Second win".先取者胜输出"First win". JOJ 1063 return s; \*==================================================*/ } const int N = 51; /*==================================================*\ double arr[N] = {2, 3}; | 最大 1 矩阵 int main(void){ \*==================================================*/ int i; bool a[N][N]; double n; int Run(const int &amp;m, const int &amp;n)// a[1...m][1...n] for( i=2; i &lt; N; ++i ) arr[i] = arr[i-1] + arr[i-2]; {// O(m*n) while( scanf("%lf", &amp;n), n != 0 ){ int i, j, k, l, r, max = 0; for( i=0; i &lt; N; ++i ) int col[N]; if( arr[i] == n ){ for( j=1; j &lt;= n; ++j ) printf("Second win\n"); break; if( a[1][j] == 0 ) col[j] = 0; } else{ if( i == N ) printf("First win\n"); for( k=2; k &lt;= m &amp;&amp; a[k][j] == 1; ++k ); } col[j] = k-1; return 0; } } for( i=1; i &lt;= m; ++i ){ /*==================================================*\ if( i &gt; 1 ){ | 集合划分问题 for( j=1; j &lt;= n; ++j ) | n 元集合分划为 k 类的方案数记为 S（n，k），称为第二类 Stirling 数。 if( a[i][j] == 0 ) col[j] = 0; else{ | 如{A,B,C}可以划分{{A},{B},{C}}, {{A,B},{C}}, {{B,C},{A}}, if( a[i-1][j] == 0 ){ | {{A,C},{B}},{{A,B,C}}。即一个集合可以划分为不同集合（1卬 个） for( k=i+1; k &lt;= m &amp;&amp; a[k][j] == | 的种类数 HDU 一卡通大冒险 1; ++k ); | CALL：compute(N); 每当输入一个 n，输出 B[n] col[j] = k-1; \*==================================================*/ } const int N = 2001; } int data[N][N], B[N]; } void NGetM(int m, int n)// m 个数 n 个集合 for( j=1; j &lt;= n; ++j ) {// data[i][j]:i 个数分成 j 个集合 if( col[j] &gt;= i ){ int min, i, j; for( l=j-1; l &gt; 0 &amp;&amp; col[l] &gt;= col[j]; --l ); data[0][0] = 1; // ++l; for( i = 1; i &lt;= m; ++i ) data[i][0] = 0; for( r=j+1; r &lt;= n &amp;&amp; col[r] &gt;= col[j]; ++r ); for( i = 0; i &lt;= m; ++i ) data[i][i+1] = 0; 27 for( i = 1; i &lt;= m; ++i ){ //返回是否有唯一解,若有解在 b[]中 if( i &lt; n ) min = i; int gauss_cpivot(int n,double a[][MAXN],double b[]){ else min = n; int i,j,k,row; for( j = 1; j &lt;= min; ++j ){ double maxp,t; data[i][j] = (j*data[i-1][j] + data[i-1][j-1]); for (k=0;kfabs(maxp)) } maxp=a[row=i][k]; void compute(int m){// b[i]:Bell 数 if (fabs(maxp)=0;i--) n = str[0]-48; l = -1; for (j=i+1;jfabs(maxp)) if( l &gt;= size ) break; maxp=a[row=i][col=j]; n = n*100+(double)(str[l]-48)*10+(double)(str[l+1]-48); if (fabs(maxp) n ) a %= n; b[k]/=maxp; int i, d = 1, b[35]; for (i=k+1;i=0;i--) if( b0 == 0 ) break; for (j=i+1;j= 0; --i ){ for (k=0;k0?(x):-(x)) | a2 b2 c2 ... | = x2 #define eps 1e-10 | ... | = ... //列主元 gauss 消去求解 a[][]x[]=b[] |cn-1 ... an-1 bn-1 | = xn-1 28 | bn cn an | = xn 输入：a[],b[],c[],x[] 输出：求解结果 X 在 x[]中 \*==================================================*/ void run(){ c[0] /= b[0]; a[0] /= b[0]; x[0] /= b[0]; for (int i = 1; i &lt; N - 1; i ++) { double temp = b[i] - a[i] * c[i - 1]; c[i] /= temp; x[i] = (x[i] - a[i] * x[i - 1]) / temp; a[i] = -a[i] * a[i - 1] / temp; } a[N - 2] = -a[N - 2] - c[N - 2]; for (int i = N - 3; i &gt;= 0; i --) { a[i] = -a[i] - c[i] * a[i + 1]; x[i] -= c[i] * x[i + 1]; } x[N - 1] -= (c[N - 1] * x[0] + a[N - 1] * x[N - 2]); x[N - 1] /= (c[N - 1] * a[0] + a[N - 1] * a[N - 2] + b[N - 1]); for (int i = N - 2; i &gt;= 0; i --) x[i] += a[i] * x[N - 1]; } /*==================================================*\ | 阶乘最后非零位,复杂度 O(nlogn) \*==================================================*/ //返回该位, n 以字符串方式传入 #include #define MAXN 10000 int lastdigit(char* buf){ const int mod[20]={1,1,2,6,4,2,2,4,2,8,4, 4,8,4,6,8,8,6,8,2}; int len=strlen(buf),a[MAXN],i,c,ret=1; if (len==1) return mod[buf[0]-'0']; for (i=0;i=0;i--) c=c*10+a[i],a[i]=c/5,c%=5; } return ret+ret%2*5; } 29 int read_data(){ 递归方法求解排列组合问题 int i; if (scanf("%d", &amp;n) == EOF) return 0; for (i=0; i 1 1 2 #define MAX_N 10 输出样例 int n, m; //相当于 n 重循环，每重循环长度为 m 1 1 2 int rcd[MAX_N]; //记录每个位置填的数 1 2 1 void loop_permutation(int l){ 2 1 1 int i; 代码 if (l == n) { //相当于进入了 n 重循环的最内层 #include for (i=0; i 0){ //若数 num[i]还没被用完，则可使用次实际上，这样的方法是用递归实现多重循环，本递归程序相当于 n 重循环，每 数减 重循环的长度为 m 的情况，所以输出共有 m^n 行。 used[i]--; rcd[l] = num[i];//在 l 位置放上该数 unrepeat_permutation(l+1); //填下一个位置 | 全排列 used[i]++; //可使用次数恢复 } 对输入的 n 个数作全排列。 } 输入样例 int read_data(){ 3 int i, j, val; 1 2 3 if (scanf("%d", &amp;n) == EOF) return 0; 输出样例 m = 0; 1 2 3 for (i=0; i num[m] = val; used[m++] = 1; #define MAX_N 10 } int n; //共 n 个数 } int rcd[MAX_N]; //记录每个位置填的数 return 1; int used[MAX_N]; //标记数是否用过 } int num[MAX_N]; //存放输入的 n 个数 int main(){ void full_permutation(int l){ while (read_data()) unrepeat_permutation(0); int i; return 0; if (l == n){ } for (i=0; i 输入样例 #define MAX_N 10 3 int n, m; //从 n 个数中选出 m 个构成组合 1 1 3 int rcd[MAX_N]; //记录每个位置填的数 输出样例 int num[MAX_N]; //存放输入的 n 个数 1 void select_combination(int l, int p){ 1 1 int i; 1 1 3 if (l == m){ //若选出了 m 个数, 则打印 1 3 for (i=0; i 0){//若还可以用, 则可用次数减 int main(){ used[i]--; rcd[l] = num[i]; //在 l 位置放上该 while (read_data()) select_combination(0, 0); 数 return 0; unrepeat_combination(l+1, i); //填下一个位置 } used[i]++; //可用次数恢复 因为在组合生成过程中引入了变量 p，保证了每次填入的数字在 num 中的下标 } 是递增的，所以不需要使用 used 进行标记，共 C(n, m)种组合。 } int read_data(){ | 全组合 int i, j, val; if (scanf("%d", &amp;n) == EOF) return 0; 输入 n 个数，求这 n 个数构成的集合的所有子集。 m = 0; 输入样例 for (i=0; i int main(){ #define MAX_N 10 while (read_data()) unrepeat_combination(0, 0); int n; //共 n 个数 return 0; int rcd[MAX_N]; //记录每个位置填的数 } int num[MAX_N]; //存放输入的 n 个数 需要注意的是递归调用时，第二个参数是 i，不再是全组合中的 i+1! void full_combination(int l, int p){ int i; | 应用 for (i=0; i=n rcd[l] = num[i]; //在 l 位置放上该数 full_combination(l+1, i+1); //填下一个位置 } } int read_data(){ int i; if (scanf("%d", &amp;n) == EOF) return 0; for (i=0; i&gt; 24; } h &amp;= ~g; for (i=1 ; i&lt;=n-x; ++i) } ver[i][j]= return h % mod; (ver[i-1][j]-(text[i-1][j]-'a')*pw[x-1])*E } +text[i+x-1][j]-'a'; int hashc(char *p, int prime = 25013){ } unsigned int h=0, g; for (j=0, ht=hp=0; j&gt; 24); } h = h ^ g; void read(){ } int i; } scanf("%d%d", &amp;n, &amp;m); return h % prime; for (i=0; i=0 &amp;&amp; pat[i]!=pat[k+1]; } k=fail[k]); ht=(ht-hor[i]*pw[x-1])*E+hor[i+x]; if (pat[k + 1] == pat[i]) fail[i] = k + 1; } } return cnt; i = j = 0; } while( str[i] &amp;&amp; pat[j] ){ // By Fandywang int main(void){ if( pat[j] == str[i] ) ++i, ++j; int T; init(); else if(j == 0)++i;//第一个字符匹配失败，从str下个字符开始 for (scanf("%d", &amp;T); T; --T) { else j = fail[j-1]+1; } read(); hash(); if( pat[j] ) return -1; printf("%d\n", solve()); else return i-j; } } return 0; /*==================================================*\ } | Karp-Rabin 字符串匹配 /*==================================================*\ | hash(w[0..m-1]) = | 函数名: strstr | (w[0] * 2^(m-1) + ... + w[m-1] * 2^0) % q; |功 能: 在串中查找指定字符串的第一次出现 | hash(w[j+1..j+m]) = |用 法: char *strstr(char *str1, char *str2); | rehash(y[j], y[j+m], hash(w[j..j+m-1]); |据说strstr和KMP的算法效率差不多 | rehash(a, b, h) = ((h - a * 2^(m-1) ) * 2 + b) % q; \*==================================================*/ | 可以用q = 2^32简化%运算 int main(void){ \*==================================================*/ char *str1 = "Borland International", *str2 = "nation", *ptr; #define REHASH(a, b, h) ((((h) - (a)*d) &lt;&lt; 1) + (b)) ptr = strstr(str1, str2); int krmatch(char *x, int m, char *y, int n) printf("The substring is: %s\n", ptr); { // search x in y return 0; int d, hx, hy, i, j; } for (d = i = 1; i &lt; m; ++i) d = (d&lt;&lt;1); /*==================================================*\ for (hy = hx = i = 0; i &lt; m; ++i) { | BM 算法的改进的算法 Sunday Algorithm hx = ((hx&lt;&lt;1) + x[i]); hy = ((hy&lt;&lt;1) + y[i]); BM算法优于KMP } SUNDAY 算法描述：字符串查找算法中，最著名的两个是KMP算法 for (j = 0; j &lt;= n - m; ++j) { （Knuth-Morris-Pratt)和BM算法（Boyer-Moore)。两个算法在最坏情 if (hx == hy &amp;&amp; memcmp(x, y + j, m) == 0) return j; 况下均具有线性的查找时间。但是在实用上，KMP算法并不比最简单的c库函数 hy = REHASH(y[j], y[j + m], hy); strstr()快多少，而BM算法则往往比KMP算法快上3－5倍。但是BM算法还不 } 是最快的算法，这里介绍一种比BM算法更快一些的查找算法。 } 例如我们要在"substring searching algorithm"查找"search"，刚开 /*==================================================*\ 始时，把子串与文本左边对齐： substring searching algorithm 32 search else return i-j; 结果在第二个字符处发现不匹配，于是要把子串往后移动。但是该移动多少呢？ } 这就是各种算法各显神通的地方了，最简单的做法是移动一个字符位置；KMP int main(void){ 是利用已经匹配部分的信息来移动；BM算法是做反向比较，并根据已经匹配的 int T; 部分来确定移动量。这里要介绍的方法是看紧跟在当前子串之后的那个字符（第 scanf("%d\n", &amp;T); 一个字符串中的'i')。 while( T-- ){ 显然，不管移动多少，这个字符是肯定要参加下一步的比较的，也就是说，如 int i, j, l1=0, l2=0; 果下一步匹配到了，这个字符必须在子串内。所以，可以移动子串，使子串中 gets(a[0]); gets(a[1]); 的最右边的这个字符与它对齐。现在子串'search'中并不存在'i'，则说明可 int len1 = strlen(a[0]), len2 = strlen(a[1]), val; 以直接跳过一大片，从'i'之后的那个字符开始作下一步的比较，如下： val = kmp(i, j, a[1], a[0]); // a[1]在前 substring searching algorithm if( val != -1 ) l1 = len1; search else{ 比较的结果，第一个字符就不匹配，再看子串后面的那个字符，是'r',它在子 //printf("i:%d, j:%d\n", i, j); 串中出现在倒数第三位，于是把子串向后移动三位，使两个'r'对齐，如下： if( i == len2 &amp;&amp; j-1 &gt;= 0 &amp;&amp; a[1][len2-1] == substring searching algorithm a[0][j-1] ) l1 = j; search } 这次匹配成功了！回顾整个过程，我们只移动了两次子串就找到了匹配位置， val = kmp(i, j, a[0], a[1]); // a[0]在前 是不是很神啊?!可以证明，用这个算法，每一步的移动量都比BM算法要大，所 if( val != -1 ) l2 = len2; 以肯定比BM算法更快。 else{ \*==================================================*/ //printf("i:%d, j:%d\n", i, j); void SUNDAY(char *text, char *patt){ if( i == len1 &amp;&amp; j-1 &gt;= 0 &amp;&amp; a[0][len1-1] == size_t temp[256]; a[1][j-1] ) l2 = j; size_t *shift = temp; } size_t i, patt_size = strlen(patt), text_size = // printf("l1:%d, l2:%d\n", l1, l2); strlen(text); printf("%d\n", len1+len2-max(l1, l2)); cout &lt;&lt; "size : " &lt;&lt; patt_size &lt;&lt; endl; } for( i=0; i &lt; 256; i++ ) *(shift+i) = patt_size+1; return 0; for( i=0; i &lt; patt_size; i++ ) } *(shift+unsigned char(*(patt+i))) = patt_size-i; /*==================================================*\ //shift['s']=6 步,shitf['e']=5 以此类推 | 最短公共祖先（多个短字符串） size_t limit = text_size-patt_size+1; | pku 1699 pku 3192 pku 1795 for( i=0; i &lt; limit; i += shift[ text[i+patt_size] ] ) \*==================================================*/ if( text[i] == *patt ){ 首先用一个数组save[i][j]来保存第j个串加在第i个串之后，第i个串所 char *match_text = text+i+1; 增加的长度，比如alba bacau,把bacau加在alba后alba所增加的长度 size_t match_size = 1; 就为3.我们采用搜索的策略，以每一个串为第个串进行搜索 do{// 输出所有匹配的位置 for(i=1;i&lt;=n;i++)dfs(i)//以第i个串为第一个串进行搜索。 if( match_size == patt_size ) cout &lt;&lt; "the 剪枝：主要是在搜索过程中，当前面一些串的长度比当前已经找到的min还 NO. is " &lt;&lt; i &lt;&lt; endl; 大的话就剪去该枝。 }while( (*match_text++) == patt[match_size++] ); } cout &lt;&lt; endl; } int main(void){ char *text = new char[100]; text = "substring searching algorithm search"; char *patt = new char[10]; patt = "search"; SUNDAY(text, patt); return 0; } /* size : 6 the NO. is 10 the NO. is 30 */ /*==================================================*\ | 最短公共祖先（两个长字符串） | The shortest common superstring of 2 strings S1 and S2 is | a string S with|the minimum number of characters which | contains both S1 and S2 as a sequence of consecutive | characters. HDU 1841 \*==================================================*/ const int N = 1000010; char a[2][N]; int fail[N]; inline int max(int a, int b) { return ( a &gt; b ) ? a : b; } int kmp(int &amp;i, int &amp;j, char* str, char* pat){ int k; memset(fail, -1, sizeof(fail)); for (i = 1; pat[i]; ++i){ for (k=fail[i-1]; k&gt;=0 &amp;&amp; pat[i]!=pat[k+1]; k=fail[k]); if (pat[k + 1] == pat[i]) fail[i] = k + 1; } i = j = 0; while( str[i] &amp;&amp; pat[j] ){ if( pat[j] == str[i] ) ++i, ++j; else if(j == 0)++i;//第一个字符匹配失败，从 str 下个字符开始 else j = fail[j-1]+1; } if( pat[j] ) return -1; 33 三角形的面积可以根据海伦公式算得，如下： Geometry 计算几何 s = sqrt(p * (p - a) * (p - b) * (p - c)); p = (a + b + c) / 2; 下面是计算该点到三角形三个顶点A,B,C的距离之和 1. 费马点(该点到三角形三个顶点的距离之和最小) /*==================================================*\ 有个有趣的结论：若三角形的三个内角均小于120度，那么该点连接 | Graham 求凸包 O(N * logN) 三个顶点形成的三个角均为120度；若三角形存在一个内角大于120度， | CALL: nr = graham(pnt, int n, res); res[]为凸包点集; 则该顶点就是费马点)计算公式如下: \*==================================================*/ 若有一个内角大于120度（这里假设为角C)，则距离为a + b struct point { double x, y; }; 若三个内角均小于120度，则距离为 bool mult(point sp, point ep, point op){ sqrt((a * a + b * b + c * c + 4 * sqrt(3.0) * s) / 2),其中 return (sp.x - op.x) * (ep.y - op.y) &gt;= (ep.x - op.x) * (sp.y - op.y); 2. 内心----角平分线的交点 } 令x = (a + b - c) / 2, y = (a - b + c) / 2, bool operator &lt; (const point &amp;l, const point &amp;r){ z = (-a + b + c) / 2, h = s / p. 计算公式为 return l.y &lt; r.y || (l.y == r.y &amp;&amp; l.x &lt; r.x); sqrt(x*x + h*h) + sqrt(y*y + h*h) + sqrt(z * z + h * h) } int graham(point pnt[], int n, point res[]){ 3. 重心----中线的交点, 计算公式如下： int i, len, k = 0, top = 1; 2.0 / 3 * (sqrt((2 * (a * a + b * b) - c * c) / 4) sort(pnt, pnt + n); + sqrt((2 * (a * a + c * c) - b * b) / 4) if (n == 0) return 0; res[0] = pnt[0]; + sqrt((2 * (b * b + c * c) - a * a) / 4)) if (n == 1) return 1; res[1] = pnt[1]; if (n == 2) return 2; res[2] = pnt[2]; 4. 垂心----垂线的交点, 计算公式如下： for (i = 2; i &lt; n; i++) { 3 * (c / 2 / sqrt(1 - cosC * cosC)) while (top &amp;&amp; mult(pnt[i], res[top], res[top-1])) /*==================================================*\ top--; | 平面最近点对 O(N * logN) res[++top] = pnt[i]; \*==================================================*/ } const int N = 100005; len = top; res[++top] = pnt[n - 2]; const double MAX = 10e100, eps = 0.00001; for (i = n - 3; i &gt;= 0; i--) { struct Point { double x, y; int index; }; while (top!=len &amp;&amp; mult(pnt[i], res[top], Point a[N], b[N], c[N]; res[top-1])) top--; double closest(Point *, Point *, Point *, int, int); res[++top] = pnt[i]; double dis(Point, Point); } int cmp_x(const void *, const void*); return top; // 返回凸包中点的个数 int cmp_y(const void *, const void*); } int merge(Point *, Point *, int, int, int); /*==================================================*\ inline double min(double, double); | 判断线段相交 int main(){ \*==================================================*/ int n, i; const double eps=1e-10; double d; struct point { double x, y; }; scanf("%d", &amp;n); double min(double a, double b) { return a &lt; b ? a : b; } while (n) { double max(double a, double b) { return a &gt; b ? a : b; } for (i = 0; i &lt; n; i++) bool inter(point a, point b, point c, point d){ scanf("%lf%lf", &amp;(a[i].x), &amp;(a[i].y)); if ( min(a.x, b.x) &gt; max(c.x, d.x) || qsort(a, n, sizeof(a[0]), cmp_x); min(a.y, b.y) &gt; max(c.y, d.y) || for (i = 0; i &lt; n; i++) min(c.x, d.x) &gt; max(a.x, b.x) || a[i].index = i; min(c.y, d.y) &gt; max(a.y, b.y) ) return 0; memcpy(b, a, n *sizeof(a[0])); double h, i, j, k; qsort(b, n, sizeof(b[0]), cmp_y); h = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); d = closest(a, b, c, 0, n - 1); i = (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x); printf("%.2lf\n", d); j = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x); scanf("%d", &amp;n); k = (d.x - c.x) * (b.y - c.y) - (d.y - c.y) * (b.x - c.x); } return h * i &lt;= eps &amp;&amp; j * k &lt;= eps; return 0; } } /*==================================================*\ double closest(Point a[],Point b[],Point c[],int p,int q){ | 求多边形重心 if (q - p == 1) return dis(a[p], a[q]); | INIT: pnt[]已按顺时针(或逆时针)排好序; if (q - p == 2) { | CALL: res = bcenter(pnt, n); double x1 = dis(a[p], a[q]); \*==================================================*/ double x2 = dis(a[p + 1], a[q]); struct point { double x, y; }; double x3 = dis(a[p], a[p + 1]); point bcenter(point pnt[], int n){ if (x1 &lt; x2 &amp;&amp; x1 &lt; x3) return x1; point p, s; else if (x2 &lt; x3) return x2; double tp, area = 0, tpx = 0, tpy = 0; else return x3; p.x = pnt[0].x; p.y = pnt[0].y; } for (int i = 1; i &lt;= n; ++i) { // point: 0 ~ n-1 int i, j, k, m = (p + q) / 2; s.x = pnt[(i == n) ? 0 : i].x; double d1, d2; s.y = pnt[(i == n) ? 0 : i].y; for (i = p, j = p, k = m + 1; i &lt;= q; i++) tp = (p.x * s.y - s.x * p.y); area += tp / 2; if (b[i].index &lt;= m) c[j++] = b[i]; tpx += (p.x + s.x) * tp; tpy += (p.y + s.y) * tp; //数组c左半部保存划分后左部的点, 且对y是有序的. p.x = s.x; p.y = s.y; else c[k++] = b[i]; } d1 = closest(a, c, b, p, m); s.x = tpx / (6 * area); s.y = tpy / (6 * area); d2 = closest(a, c, b, m + 1, q); return s; double dm = min(d1, d2); } //数组c左右部分分别是对y坐标有序的, 将其合并到b. /*==================================================*\ merge(b, c, p, m, q); | 三角形几个重要的点 for (i = p, k = p; i &lt;= q; i++) | INIT: pnt[]已按顺时针(或逆时针)排好序; if (fabs(b[i].x - b[m].x) &lt; dm) c[k++] = b[i]; | CALL: res = bcenter(pnt, n); //找出离划分基准左右不超过dm的部分, 且仍然对y坐标有序. \*==================================================*/ for (i = p; i &lt; k; i++) 设三角形的三条边为a, b, c，且不妨假设a &lt;= b &lt;= c， for (j = i + 1; j &lt; k &amp;&amp; c[j].y - c[i].y &lt; dm; j++){ 34 double temp = dis(c[i], c[j]); } if (temp &lt; dm) dm = temp; | 确定两条线段是否相交 } double mx(double t1,double t2) return dm; { } if(t1&gt;t2) return t1; double dis(Point p, Point q){ return t2; double x1 = p.x - q.x, y1 = p.y - q.y; } return sqrt(x1 *x1 + y1 * y1); double mn(double t1,double t2) } { int merge(Point p[], Point q[], int s, int m, int t){ if(t1 q[j].y) p[k++] = q[j], j++; int lsinterls(Llineseg u,Llineseg v) else p[k++] = q[i], i++; { } return( (mx(u.a.x,u.b.x)&gt;=mn(v.a.x,v.b.x))&amp;&amp; while (i &lt;= m) p[k++] = q[i++]; (mx(v.a.x,v.b.x)&gt;=mn(u.a.x,u.b.x))&amp;&amp; while (j &lt;= t) p[k++] = q[j++]; (mx(u.a.y,u.b.y)&gt;=mn(v.a.y,v.b.y))&amp;&amp; memcpy(q + s, p + s, (t - s + 1) *sizeof(p[0])); (mx(v.a.y,v.b.y)&gt;=mn(u.a.y,u.b.y))&amp;&amp; return 0; } (xmulti(v.a,u.b,u.a)*xmulti(u.b,v.b,u.a)&gt;=0)&amp;&amp; int cmp_x(const void *p, const void *q){ double temp = ((Point*)p)-&gt;x - ((Point*)q)-&gt;x; (xmulti(u.a,v.b,v.a)*xmulti(v.b,u.b,v.a)&gt;=0)); if (temp &gt; 0) return 1; } else if (fabs(temp) &lt; eps) return 0; | 判断点 p 是否在线段 l 上 else return - 1; int ponls(Llineseg l,Lpoint p) { } return( (xmulti(l.b,p,l.a)==0) &amp;&amp; int cmp_y(const void *p, const void *q){ ( ((p.x-l.a.x)*(p.x-l.b.x)&lt;0 ) || double temp = ((Point*)p)-&gt;y - ((Point*)q)-&gt;y; ((p.y-l.a.y)*(p.y-l.b.y)&lt;0 )) ); if (temp &gt; 0) return 1; } else if (fabs(temp) &lt; eps) return 0; | 判断两个点是否相等 else return - 1; int Euqal_Point(Lpoint p1,Lpoint p2) { } return((fabs(p1.x-p2.x) q) ? (q): (p); 当且仅当u,v相交并且交点不是u,v的端点时函数为true; } int lsinterls_A(Llineseg u,Llineseg v) { /*==================================================*\ return((lsinterls(u,v)) &amp;&amp; (!Euqal_Point(u.a,v.a))&amp;&amp; | Liuctic 的计算几何库 (!Euqal_Point(u.a,v.b)) &amp;&amp; | p-Lpoint ln,l - Lline ls - Llineseg lr - Lrad (!Euqal_Point(u.b,v.a))&amp;&amp; | 求平面上两点之间的距离 p2pdis (!Euqal_Point(u.b,v.b))); | 返回(P1-P0)*(P2-P0)的叉积。 xmulti } | 确定两条线段是否相交 lsinterls /*=============================================== | 判断点p是否在线段l上 ponls | 判断点 q 是否在多边形内 | 判断两个点是否相等 Euqal_Point 其中多边形是任意的凸或凹多边形， | 线段非端点相交 lsinterls_A Polygon中存放多边形的逆时针顶点序列 | 判断点q是否在多边形Polygon内 pinplg ================================================*/ | 多边形的面积 area_of_polygon int pinplg(int vcount,Lpoint Polygon[],Lpoint q) | 解二次方程 Ax^2+Bx+C=0 equa { | 点到直线距离 p2lndis int c=0,i,n; | 直线与圆的交点，已知直线与圆相交 lncrossc Llineseg l1,l2; | 点是否在射线的正向 samedir l1.a=q; l1.b=q; l1.b.x=infinity; n=vcount; | 射线与圆的第一个交点 lrcrossc for (i=0;i0) struct Lline{Lpoint p; Ldir dir;}; //直线 || struct Lrad{Lpoint Sp; Ldir dir;}; //射线 (ponls(l1,Polygon[(i+2)%n]))&amp;&amp; struct Lround{Lpoint co; double r;};//圆 (xmulti(Polygon[i],Polygon[(i+2)%n],l1.a) * | 求平面上两点之间的距离 double p2pdis(Lpoint p1,Lpoint p2) { xmulti(Polygon[(i+2)%n],Polygon[(i+3)%n],l1.a)&gt;0) return (sqrt((p1.x-p2.x) * (p1.x-p2.x) + ) ) ) c++; (p1.y-p2.y) * (p1.y-p2.y))); } } return(c%2!=0); /******************************************************* } | (P1-P0)*(P2-P0)的叉积 /*==================================================*\ 若结果为正，则在的顺时针方向； | 计算多边形的面积 若为0则共线； | 要求按照逆时针方向输入多边形顶点 若为负则在的在逆时针方向; | 可以是凸多边形或凹多边形 可以根据这个函数确定两条线段在交点处的转向, \*==================================================*/ 比如确定p0p1和p1p2在p1处是左转还是右转，只要求 double areaofp(int vcount,double x[],double y[],Lpoint (p2-p0)*(p1-p0)，若&lt;0则左转，&gt;0则右转，=0则共线 plg[]) ********************************************************/ { double xmulti(Lpoint p1,Lpoint p2,Lpoint p0) { int i; return((p1.x-p0.x) * (p2.y-p0.y) - double s; (p2.x-p0.x) * (p1.y-p0.y)); if (vcount&lt;3) return 0; 35 s=plg[0].y*(plg[vcount-1].x-plg[1].x); if(samedir(ln,p1)) for (i=1;i0||fabs(ddx*ln.dir.dx)&lt;1e-7) &amp;&amp;(ddy*ln.dir.dy&gt;0||(fabs(ddy*ln.dir.dy)&lt;1e-7))) return true; else return false; } | 射线与圆的第一个交点 已经确定射线所在直线与圆相交返回-1表示不存正向交点 ，否则返回1 int lrcrossc(Lrad ln, Lround Y, Lpoint&amp; P) { Lline ln2; Lpoint p1,p2; int res=-1; double dis=1e20; ln2.p=ln.Sp,ln2.dir=ln.dir; lncrossc(ln2,Y,p1,p2); 36 在 C++标准中，STL 被组织为以下的一组头文件（注意，是没有.h 后缀的！）： STL algorithm / deque / functional / iterator / list / map memory / numeric / queue / set / stack / utility / vector 当我们需要使用 STL 的某个功能时，需要嵌入相应的头文件。但要注意的是， 在 C++标准中，STL 是被定义在 std 命名空间中的。如下例所示： #include | 全排列函数 next_permutation int main(){ STL 中专门用于排列的函数（可以处理存在重复数据集的排列问题） std::stack s; 头文件：#include s.push(0); using namespace std; ... 调用： next_permutation(start, end); return 0; 注意：函数要求输入的是一个升序排列的序列的头指针和尾指针. } 用法： 如果希望在程序中直接引用 STL，也可以在嵌入头文件后，用 using // 数组 namespace 语句将 std 命名空间导入。如下例所示： int a[N]; #include sort(a, a+N); using namespace std; next_permutation(a, a+N); int main(){ // 向量 stack s; vector ivec; s.push(0); sort(ivec.begin(), ivec.end()); ... next_permutation(ivec.begin(), ivec.end()); return 1; 例子： } vector myVec; STL 是 C++语言机制运用的一个典范，通过学习 STL 可以更深刻地理解 C++ // 初始化代码 语言的思想和方法。在本系列的文章中不打算对 STL 做深入的剖析，而只是想 sort(myVec.begin(),myVec.end()); 介绍一些 STL 的基本应用。 do{ 有兴趣的同学，建议可以在有了一些 STL 的使用经验后，认真阅读一下《C++ for (i = 0 ;i &lt; size;i ++ ) cout &lt;&lt; myVec[i] &lt;&lt; " \t " ; STL》这本书（电力出版社有该书的中文版）。 cout &lt;&lt; endl; ACM/ICPC 竞赛之 STL--pair }while (next_permutation(myVec.begin(), myVec.end())); STL 的头文件中描述了一个看上去非常简单的模板类 pair，用来 表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较的比较 ACM/ICPC 竞赛之 STL 简介 运算符模板函数。 一、关于 STL 例如，想要定义一个对象表示个平面坐标点，则可以： STL(Standard Template Library，标准模板库）是 C++语言标准中的重 pair p1; 要组成部分。STL 以模板类和模板函数的形式为程序员提供了各种数据结构和 cin &gt;&gt; p1.first &gt;&gt; p1.second; 算法的精巧实现，程序员如果能够充分地利用 STL，可以在代码空间、执行时 pair 模板类需要两个参数：首元素的数据类型和尾元素的数据类型。pair 模间和编码效率上获得极大的好处。 板类对象有两个成员：first 和 second，分别表示首元素和尾元素。 STL 大致可以分为三大类：算法(algorithm)、容器(container)、迭代器 在中已经定义了 pair 上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=， (iterator)。 其规则是先比较 first，first 相等时再比较 second，这符合大多数应用的 STL 容器是一些模板类，提供了多种组织数据的常用方法，例如 vector(向量， 逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。 类似于数组)、list(列表，类似于链表)、deque(双向队列)、set(集合)、 除了直接定义一个 pair 对象外，如果需要即时生成一个 pair 对象，也可以 map(映象)、stack(栈)、queue(队列)、priority_queue(优先队列)等， 调用在中定义的一个模板函数：make_pair。make_pair 需要两通过模板的参数我们可以指定容器中的元素类型。 个参数，分别为元素对的首元素和尾元素。 STL 算法是一些模板函数，提供了相当多的有用算法和操作，从简单如 在题 1067--Ugly Numbers 中，就可以用 pair 来表示推演树上的结点，用 for_each（遍历）到复杂如 stable_sort（稳定排序）。 first 表示结点的值，用 second 表示结点是由父结点乘以哪一个因子得到的。 STL 迭代器是对 C 中的指针的一般化，用来将算法和容器联系起来。几乎所有 #include 的 STL 算法都是通过迭代器来存取元素序列进行工作的，而 STL 中的每一个 #include 容器也都定义了其本身所专有的迭代器，用以存取容器中的元素。有趣的是， using namespace std; 普通的指针也可以像迭代器一样工作。 typedef pair node_type; 熟悉了 STL 后，你会发现，很多功能只需要用短短的几行就可以实现了。通过 int main(){ STL，我们可以构造出优雅而且高效的代码，甚至比你自己手工实现的代码效 unsigned long result[1500]; 果还要好。 priority_queue&lt; node_type, vector, STL 的另外一个特点是，它是以源码方式免费提供的，程序员不仅可以自由地 greater &gt; Q; 使用这些代码，也可以学习其源码，甚至按照自己的需要去修改它。 Q.push( make_pair(1, 2) ); 下面是用 STL 写的题 Ugly Numbers 的代码： for (int i=0; i&lt;1500; i++){ #include node_type node = Q.top(); Q.pop(); #include switch(node.second){ using namespace std; case 2: Q.push( make_pair(node.first*2, 2) ); typedef pair node_type; case 3: Q.push( make_pair(node.first*3, 3) ); int main(){ case 5: Q.push( make_pair(node.first*5, 5) ); unsigned long result[1500]; } priority_queue&lt; node_type, vector, result[i] = node.first; greater &gt; Q; } Q.push( make_pair(1, 2) ); int n; for (int i=0; i&lt;1500; i++){ cin &gt;&gt; n; node_type node = Q.top(); Q.pop(); while (n&gt;0){ switch(node.second){ cout &lt;&lt; result[n-1] &lt;&lt; endl; case 2: Q.push( make_pair(node.first*2, 2) ); cin &gt;&gt; n; case 3: Q.push( make_pair(node.first*3, 3) ); } case 5: Q.push( make_pair(node.first*5, 5) ); return 0; } } result[i] = node.first; 看上去是很简单的一个头文件，但是的设计中却浓缩 } 反映了 STL 设计的基本思想。有意深入了解和研究 STL 的同学，仔细阅读和 int n; 体会这个简单的头文件，不失为一种入门的途径。 cin &gt;&gt; n; ACM/ICPC 竞赛之 STL--vector while (n&gt;0){ 在 STL 的头文件中定义了 vector（向量容器模板类），vector cout &lt;&lt; result[n-1] &lt;&lt; endl; 容器以连续数组的方式存储元素序列，可以将 vector 看作是以顺序结构实现 cin &gt;&gt; n; 的线性表。当我们在程序中需要使用动态数组时，vector 将会是理想的选择， } vector 可以在使用过程中动态地增长存储空间。 return 0; vector 模板类需要两个模板参数，第一个参数是存储元素的数据类型，第二 } 个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参在 ACM 竞赛中，熟练掌握和运用 STL 对快速编写实现代码会有极大的帮助。 数，将使用默认的分配器。 二、使用 STL 下面给出几个常用的定义 vector 向量对象的方法示例： 37 vector s; (++p,p++)； 定义一个空的 vector 对象，存储的是 int 类型的元素。 双向 iterator(迭代器)，读取队列中的值，并可以向前向后遍历容器； vector s(n); 随机访问 iterator(迭代器), 可以直接以下标方式对容器进行访问，定义一个含有 n 个 int 元素的 vector 对象。 vector 的 iterator(迭代器)就是这种 iterator(迭代器)； vector s(first, last); 流 iterator(迭代器)，可以直接输出、输入流中的值； 定义一个 vector 对象，并从由迭代器 first 和 last 定义的序列[first, 每种 STL 容器都有自己的 iterator(迭代器)子类，下面先来看一段简单的示 last)中复制初值。 例代码： vector 的基本操作有： #include s[i] #include 直接以下标方式访问容器中的元素。 using namespace std; s.front() main() 返回首元素。 { s.back() vector s; 返回尾元素。 for (int i=0; i&lt;10; i++) s.push_back(i); s.push_back(x) for (vector::iterator it=s.begin(); it!=s.end(); 向表尾插入元素 x。 it++) s.size() cout &lt;&lt; *it &lt;&lt; " "; 返回表长。 cout &lt;&lt; endl; s.empty() return 1; 当表空时，返回真，否则返回假。 } s.pop_back() vector 的 begin()和 end()方法都会返回一个 vector::iterator 对象，删除表尾元素。 分别指向 vector 的首元素位置和尾元素的下一个位置（我们可以称之为结束 s.begin() 标志位置）。 返回指向首元素的随机存取迭代器。 对一个 iterator(迭代器)对象的使用与一个指针变量的使用极为相似，或者 s.end() 可以这样说，指针就是一个非常标准的 iterator(迭代器)。 返回指向尾元素的下一个位置的随机存取迭代器。 再来看一段稍微特别一点的代码： s.insert(it, x) #include 向迭代器 it 指向的元素前插入新元素 val。 #include s.insert(it, n, x) using namespace std; 向迭代器 it 指向的元素前插入 n 个 x。 main() s.insert(it, first, last) { 将由迭代器 first 和 last 所指定的序列[first, last)插入到迭代器 it vector s; 指向的元素前面。 s.push_back(1); s.erase(it) s.push_back(2); 删除由迭代器 it 所指向的元素。 s.push_back(3); s.erase(first, last) copy(s.begin(), s.end(), ostream_iterator(cout, " 删除由迭代器 first 和 last 所指定的序列[first, last)。 ")); s.reserve(n) cout &lt;(cout, " "));的意思是将由 s.resize(n, val) s.begin()至 s.end()(不含 s.end())所指定的序列复制到标准输出流改变序列的长度，超出的元素将会被删除，如果序列需要扩展（原空间小于 n）， cout 中，用" "作为每个元素的间隔。也就是说，这句话的作用其实就是将表将用 val 填满扩展出的空间。 中的所有内容依次输出。 s.clear() iterator(迭代器)是 STL 容器和算法之间的摻汉霞翑，几乎所有的 STL 算删除容器中的所有的元素。 法都是通过容器的 iterator(迭代器)来访问容器内容的。只有通过有效地运 s.swap(v) 用 iterator(迭代器)，才能够有效地运用 STL 强大的算法功能。 将 s 与另一个 vector 对象 v 进行交换。 ACM/ICPC 竞赛之 STL--string s.assign(first, last) 字符串是程序中经常要表达和处理的数据，我们通常是采用字符数组或字符指将序列替换成由迭代器 first 和 last 所指定的序列[first, last)。 针来表示字符串。STL 为我们提供了另一种使用起来更为便捷的字符串的表达 [first, last)不能是原序列中的一部分。 方式：string。string 类的定义在头文件中。 要注意的是，resize 操作和 clear 操作都是对表的有效元素进行的操作，但 string 类其实可以看作是一个字符的 vector，vector 上的各种操作都可以并不一定会改变缓冲空间的大小。 适用于 string，另外，string 类对象还支持字符串的拼合、转换等操作。 另外，vector 还有其他一些操作如反转、取反等，不再一下列举。 下面先来看一个简单的例子： vector 上还定义了序列之间的比较操作运算符(&gt;, &lt;, &gt;=, &lt;=, ==, !=)， #include 可以按照字典序比较两个序列。 #include 还是来看一些示例代码。输入个数不定的一组整数，再将这组整数按倒序输出， using namespace std; 如下所示： int main(){ #include string s = "Hello! ", name; #include cin &gt;&gt; name; using namespace std; s += name; int main(){ s += '!'; vector L; cout &lt;&lt; s &lt;&lt; endl; int x; return 0; while (cin&gt;&gt;x) L.push_back(x); } for (int i=L.size()-1; i&gt;=0; i--) cout &lt;&lt; L[i] &lt;&lt; " "; 再以题 1064--Parencoding 为例，看一段用 string 作为容器，实现由 P cout &lt;&lt; endl; 代码还原括号字符串的示例代码片段： return 0; int m; } cin &gt;&gt; m; // P 编码的长度 ACM/ICPC 竞赛之 STL--iterator 简介 string str; // 用来存放还原出来的括号字符串 iterator(迭代器)是用于访问容器中元素的指示器，从这个意义上说， int leftpa = 0; // 记录已出现的左括号的总数 iterator(迭代器)相当于数据结构中所说的摫槔刚霐，也可以把 for (int j=0; j&gt; p; 讨论关于 iterator(迭代器)的实现和使用，而只对 iterator(迭代器)做一 for (int k=0; k头文件中。 算符。优先队列试图将两个元素 x 和 y 代入比较运算符(对 less 算子，调用 stack 模板类需要两个模板参数，一个是元素类型，一个容器类型，但只有元 xy)，若结果为真，则 x 排在 y 前面，y 将先素类型是必要的，在不指定容器类型时，默认的容器类型为 deque。 于 x 出队，反之，则将 y 排在 x 前面，x 将先出队。 定义 stack 对象的示例代码如下： 看下面这个简单的示例： stack s1; #include stack s2; #include stack 的基本操作有： using namespace std; 入栈，如例：s.push(x); class T{ 出栈，如例：s.pop();注意，出栈操作只是删除栈顶元素，并不返回该元素。 public: 访问栈顶，如例：s.top() int x, y, z; 判断栈空，如例：s.empty()，当栈空时，返回 true。 T(int a, int b, int c):x(a), y(b), z(c){} 访问栈中的元素个数，如例：s.size() }; 下面是用 string 和 stack 写的解题 1064--Parencoding 的程序。 bool operator &lt; (const T &amp;t1, const T &amp;t2){ #include return t1.z &lt; t2.z; // 按照 z 的顺序来决定 t1 和 t2 的顺序 #include } #include int main(){ using namespace std; priority_queue q; int main(){ q.push(T(4,4,3)); int n; q.push(T(2,2,5)); cin &gt;&gt; n; q.push(T(1,5,4)); for (int i=0; i&gt; m; T t = q.top(); q.pop(); string str; cout &lt;&lt; t.x &lt;&lt; " " &lt;&lt; t.y &lt;&lt; " " &lt;&lt; t.z &lt;&lt; endl; int leftpa = 0; } for (int j=0; j&gt; p; 2 2 5 for (int k=0; k stack s; #include for (string::iterator it=str.begin(); using namespace std; it!=str.end(); it++) { // 构造 M 编码 class T{ if (*it=='(') s.push(1); public: else{ int x, y, z; int p = s.top(); s.pop(); T(int a, int b, int c):x(a), y(b), z(c) cout &lt;&lt; p &lt;&lt; " "; { if (!s.empty()) s.top() += p; } } }; } bool operator &gt; (const T &amp;t1, const T &amp;t2){ cout &lt;&lt; endl; return t1.z &gt; t2.z; } } return 0; int main(){ } priority_queue, greater &gt; q; 2、queue q.push(T(4,4,3)); queue 模板类的定义在头文件中。 q.push(T(2,2,5)); 与 stack 模板类很相似，queue 模板类也需要两个模板参数，一个是元素类 q.push(T(1,5,4)); 型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为 deque 类 q.push(T(3,3,6)); 型。 定义 queue 对象的示例代码如下： while (!q.empty()){ queue q1; T t = q.top(); q.pop(); queue q2; cout &lt;&lt; t.x &lt;&lt; " " &lt;&lt; t.y &lt;&lt; " " &lt;&lt; t.z &lt;&lt; endl; queue 的基本操作有： } 入队，如例：q.push(x); 将 x 接到队列的末端。 return 0; 出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元 } 素的值。 输出结果为： 访问队首元素，如例：q.front()，即最早被压入队列的元素。 4 4 3 访问队尾元素，如例：q.back()，即最后被压入队列的元素。 1 5 4 判断队列空，如例：q.empty()，当队列空时，返回 true。 2 2 5 访问队列中的元素个数，如例：q.size() 3 3 6 3、priority_queue 如果我们把第一个例子中的比较运算符重载为： 在头文件中，还定义了另一个非常有用的模板类 bool operator &lt; (const T &amp;t1, const T &amp;t2){ priority_queue(优先队列）。优先队列与队列的差别在于优先队列不是按 return t1.z &gt; t2.z; // 按照 z 的顺序来决定 t1 和 t2 的顺序 照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先， } 也可以通过指定算子来指定自己的优先顺序）。 则第一个例子的程序会得到和第二个例子的程序相同的输出结果。 priority_queue 模板类有三个模板参数，第一个是元素类型，第二个容器 再回顾一下用优先队列实现的题 1067--Ugly Numbers 的代码： 类型，第三个是比较算子。其中后两个都可以省略，默认容器为 vector，默 #include 认算子为 less，即小的往前排，大的往后排（出队时序列尾的元素出队）。 #include 定义 priority_queue 对象的示例代码如下： using namespace std; priority_queue q1; typedef pair node_type; priority_queue&lt; pair &gt; q2; // 注意在两个尖括号之间 int main( int argc, char *argv[] ){ 一定要留空格。 unsigned long int result[1500]; priority_queue, greater &gt; q3; // 定 priority_queue&lt; node_type, vector, 义小的先出队 greater &gt; Q; priority_queue 的基本操作与 queue 相同。 Q.push( make_pair(1, 3) ); 39 for (int i=0; i&lt;1500; i++){ return 0; node_type node = Q.top(); } Q.pop(); 程序执行的输出结果为： switch(node.second){ MyTestMap[2] = No.2 case 3: Q.push( make_pair(node.first*2, 3) ); MyTestMap[2] = No.2 After modification case 2: Q.push( make_pair(node.first*3, 2) ); Map contents : case 1: Q.push( make_pair(node.first*5, 1) ); No.1 } No.2 After modification result[i] = node.first; No.3 } No.4 int n; No.5 cin &gt;&gt; n; 再看一段简单的示例代码： while (n&gt;0){ #include cout &lt;&lt; result[n-1] &lt;&lt; endl; #include <map>cin &gt;&gt; n; using namespace std; } int main(){ return 1; map m; } m["one"] = 1; ACM/ICPC 竞赛之 STL--map m["two"] = 2; 在 STL 的头文件<map>中定义了模板类 map 和 multimap，用有序二叉树来 // 几种不同的 insert 调用方法 存贮类型为 pair的元素对序列。序列中的元素以 const Key m.insert(make_pair("three", 3)); 部分作为标识，map 中所有元素的 Key 值都必须是唯一的，multimap 则允许 m.insert(map::value_type("four", 4)); 有重复的 Key 值。 m.insert(pair("five", 5)); 可以将 map 看作是由 Key 标识元素的元素集合，这类容器也被称为摴亓? 器敚梢酝ü桓?Key 值来快速确定一个元素，因此非常适合于需要按照 Key string key; 值查找元素的容器。 while (cin&gt;&gt;key){ map 模板类需要四个模板参数，第一个是键值类型，第二个是元素类型，第三 map::iterator it = m.find(key); 个是比较算子，第四个是分配器类型。其中键值类型和元素类型是必要的。 if (it==m.end()){ map 的基本操作有： cout &lt;&lt; "No such key!" &lt;&lt; endl; 1、定义 map 对象，例如： } map m; else{ 2、向 map 中插入元素对，有多种方法，例如： cout &lt;&lt; key &lt;&lt; " is " &lt;&lt; it-&gt;second &lt;&lt; endl; m[key] = value; cout &lt;&lt; "Erased " &lt;&lt; m.erase(key) &lt;&lt; endl; [key]操作是 map 很有特色的操作，如果在 map 中存在键值为 key 的元素对， } 则返回该元素对的值域部分，否则将会创建一个键值为 key 的元素对，值域为 } 默认值。所以可以用该操作向 map 中插入元素对或修改已经存在的元素对的值 return 0; 域部分。 } m.insert( make_pair(key, value) ); ACM/ICPC 竞赛之 STL--algorithm 也可以直接调用 insert 方法插入元素对，insert 操作会返回一个 pair，当 无疑是 STL 中最大的一个头文件它是由一大堆模板函数组成 map 中没有与 key 相匹配的键值时，其 first 是指向插入元素对的迭代器， 的。 其 second 为 true；若 map 中已经存在与 key 相等的键值时，其 first 是 下面列举出中的模板函数： 指向该元素对的迭代器，second 为 false。 adjacent_find / binary_search / copy / copy_backward / count 3、查找元素对，例如： / count_if / equal / equal_range / fill / fill_n / find / int i = m[key]; find_end / find_first_of / find_if / for_each / generate / 要注意的是，当与该键值相匹配的元素对不存在时，会创建键值为 key 的元素 generate_n / includes / inplace_merge / iter_swap / 对。 lexicographical_compare / lower_bound / make_heap / max / map::iterator it = m.find(key); max_element / merge / min / min_element / mismatch / 如果 map 中存在与 key 相匹配的键值时，find 操作将返回指向该元素对的迭 next_permutation / nth_element / partial_sort / 代器，否则，返回的迭代器等于 map 的 end()（参见 vector 中提到的 begin partial_sort_copy / partition / pop_heap / prev_permutation 和 end 操作）。 / push_heap / random_shuffle / remove / remove_copy / 4、删除元素对，例如： remove_copy_if / remove_if / replace / replace_copy / m.erase(key); replace_copy_if / replace_if / reverse / reverse_copy / 删除与指定 key 键值相匹配的元素对，并返回被删除的元素的个数。 rotate / rotate_copy / search / search_n / set_difference / m.erase(it); set_intersection / set_symmetric_difference / set_union / 删除由迭代器 it 所指定的元素对，并返回指向下一个元素对的迭代器。 sort / sort_heap / stable_partition / stable_sort / swap / 看一段简单的示例代码： swap_ranges / transform / unique / unique_copy / upper_bound #include<map> 如果详细叙述每一个模板函数的使用，足够写一本书的了。还是来看几个简单 #include 的示例程序吧。 using namespace std; 示例程序之一，for_each 遍历容器： typedef map &gt; M_TYPE; #include typedef M_TYPE::iterator M_IT; #include typedef M_TYPE::const_iterator M_CIT; #include int main(){ using namespace std; M_TYPE MyTestMap; int Visit(int v) // 遍历算子函数 { MyTestMap[3] = "No.3"; cout &lt;&lt; v &lt;&lt; " "; MyTestMap[5] = "No.5"; return 1; MyTestMap[1] = "No.1"; } MyTestMap[2] = "No.2"; class MultInt // 定义遍历算子类 MyTestMap[4] = "No.4"; { private: M_IT it_stop = MyTestMap.find(2); int factor; public: cout &lt;&lt; "MyTestMap[2] = " &lt;&lt; it_stop-&gt;second &lt;&lt; endl; MultInt(int f) : factor(f){} it_stop-&gt;second = "No.2 After modification"; void operator()(int &amp;elem) const{ cout &lt;&lt; "MyTestMap[2] = " &lt;&lt; it_stop-&gt;second &lt;&lt; endl; elem *= factor; } cout &lt;&lt; "Map contents : " &lt;&lt; endl; }; for(M_CIT it = MyTestMap.begin(); it != MyTestMap.end(); it++){ int main(){ cout &lt;&lt; it-&gt;second &lt;&lt; endl; vector L; } for (int i=0; i&lt;10; i++) L.push_back(i); 40 for_each(L.begin(), L.end(), Visit); cout &lt;&lt; endl; cout &lt;&lt; "v2 with v1 insert = ( " ; for_each(L.begin(), L.end(), MultInt(2)); for (vector ::iterator it=v2.begin(); it!=v2.end(); for_each(L.begin(), L.end(), Visit); it++) cout &lt;&lt; endl; cout &lt;&lt; *it &lt;&lt; " "; return 0; cout &lt;&lt; ")" &lt;&lt; endl; } 程序的输出结果为： // 在 v2 内部进行复制，注意参数 2 表示结束位置，结束位置不参与复 0 1 2 3 4 5 6 7 8 9 制 0 2 4 6 8 10 12 14 16 18 copy(v2.begin()+4, v2.begin()+7, v2.begin()+2); 示例程序之二，min_element/max_element，找出容器中的最小/最大值： #include cout &lt;&lt; "v2 with shifted insert = ( " ; #include for (vector ::iterator it=v2.begin(); it!=v2.end(); #include it++) using namespace std; cout &lt;&lt; *it &lt;&lt; " "; cout &lt;&lt; ")" &lt;&lt; endl; int main(){ return 1; vector L; } for (int i=0; i&lt;10; i++) L.push_back(i); 程序的输出结果为： vector::iterator min_it = min_element(L.begin(), v1 = ( 0 10 20 30 40 50 ) L.end()); v2 = ( 0 3 6 9 12 15 18 21 24 27 30 ) vector::iterator max_it = max_element(L.begin(), v2 with v1 insert = ( 0 3 6 9 0 10 20 21 24 27 30 ) L.end()); v2 with shifted insert = ( 0 3 0 10 20 10 20 21 24 27 30 ) cout &lt;&lt; "Min is " &lt;&lt; *min_it &lt;&lt; endl; STL in ACM cout &lt;&lt; "Max is " &lt;&lt; *max_it &lt;&lt; endl; 容器(container): return 1; 迭代器(iterator): 指针 } 内部实现: 数组 // 就是没有固定大小的数组，vector 直接翻译是向量程序的输出结果为： vector // T 就是数据类型，Alloc 是关于内存的一个什么东西，一般是使 Min is 0 用默认参数。 Max is 9 支持操作: 示例程序之三，sort 对容器进行排序： begin(), //取首个元素，返回一个 iterator #include end(), //取末尾（最后一个素的下一个存储空间的地址） #include size(), //就是数组大小的意思 #include clear(), //清空 using namespace std; empty(), //判断 vector 是否为空 void Print(vector &amp;L){ [ ] //很神奇的东东，可以和数组一样操作 for (vector::iterator it=L.begin(); it!=L.end(); //举例： vector a; //定义了一个 vector it++) //然后我们就可以用 a[i]来直接访问 a 中的第 i + 1 个元素！和数组的下标 cout &lt;&lt; *it &lt;&lt; " "; 一模一样 cout &lt;&lt; endl; push_back(), pop_back() //从末尾插入或弹出 } insert() O(N) //插入元素，O(n)的复杂度 int main(){ erase() O(N) //删除某个元素，O(n)的复杂度 vector L; 可以用于数组大小不定且空间紧张的情况 for (int i=0; i&lt;5; i++) L.push_back(i); Iterator 用法举例: for (int i=9; i&gt;=5; i--) L.push_back(i); int main(){ Print(L); int n,i; sort(L.begin(), L.end()); vector vi; //类似于我们定义一个数组，同 int vi[1000]; 但 vector Print(L); 的大小是自动调整的 sort(L.begin(), L.end(), greater()); // 按降序排序 vector ::iterator itr; //两个冒号 Print(L); while (scanf("%d",&amp;n) != EOF) vi.push_back(n); return 0; for (i = 0 ; i &lt; vi.size() ; i++) printf("%d\n",vi[i]); } for (itr = vi.begin() ; itr != vi.end() ; itr++) 程序的输出结果为： printf("%d\n",*itr); 0 1 2 3 4 9 8 7 6 5 return 0; 0 1 2 3 4 5 6 7 8 9 } 9 8 7 6 5 4 3 2 1 0 类似：双端队列，两头都支持进出 示例程序之四，copy 在容器间复制元素： 支持 push_front()和 pop_front() #include 是的精简版:) //栈，只支持从末尾进出 #include 支持 push(), pop(), top() #include 是的精简版 //单端队列，就是我们平时所说的队列，一头进，另一头出 using namespace std; 支持 push(), pop(), front(), back() int main() { 内部实现: 双向链表 //作用和 vector 差不多，但内部是用链表实现 // 先初始化两个向量 v1 和 v2 list vector v1, v2; 支持操作: for (int i=0; i&lt;=5; i++) v1.push_back(10*i); begin(), end(), size(), clear(), empty() for (int i=0; i&lt;=10; i++) v2.push_back(3*i); push_back(), pop_back() //从末尾插入或删除元素 push_front(), pop_front() cout &lt;&lt; "v1 = ( " ; insert() O(1) //链表实现，所以插入和删除的复杂度的 O(1) for (vector ::iterator it=v1.begin(); it!=v1.end(); erase() O(1) it++) sort() O(nlogn),不同于中的 sort cout &lt;&lt; *it &lt;&lt; " "; //不支持[ ]操作！ cout &lt;&lt; ")" &lt;&lt; endl; 内部实现: 红黑树 //Red-Black Tree，一种平衡的二叉排序树 cout &lt;&lt; "v2 = ( " ; set //又是一个 Compare 函数，类似于 qsort 函数里的那个 Compare 函数， for (vector ::iterator it=v2.begin(); it!=v2.end(); 作为红黑树在内部实现的比较方式 it++) insert() O(logn) cout &lt;&lt; *it &lt;&lt; " "; erase() O(logn) cout &lt;&lt; ")" &lt;&lt; endl; find() O(logn) 找不到返回 a.end() lower_bound() O(logn) 查找第一个不小于 k 的元素 // 将 v1 的前三个元素复制到 v2 的中间 upper_bound() O(logn) 查找第一个大于 k 的元素 copy(v1.begin(), v1.begin()+3, v2.begin()+4); equal_range() O(logn) 返回 pair 41 允许重复元素的 if (((SS*)a)-&gt;first != ((SS*)b)-&gt;first) 的用法及 Compare 函数示例: return ((SS*)a)-&gt;first ?((SS*)b)-&gt;first; struct SS {int x,y;}; return ((SS*)a)-&gt;second ?((SS*)b)-&gt;second; struct ltstr { } bool operator() (SS a, SS b) qsort(array,n,sizeof(array[0]),cmp); {return a.x &lt; b.x;} //注意，按 C 语言习惯，double 型要写成这样： sort()系列: return a.x &lt; b.x ? 1 : 0; stable_sort(first,last,cmp); //稳定排序 }; partial_sort(first,middle,last,cmp);//部分排序 int main() { 将前(middle-first)个元素放在[first,middle)中，其余元素位置不定 set st; e.g. ? int A[12] = {7, 2, 6, 11, 9, 3, 12, 10, 8, 4, 1, 5}; } partial_sort(A, A + 5, A + 12); // 结果是 "1 2 3 4 5 11 12 10 9 8 7 6". 内部实现: pair 组成的红黑树 //map 中文意思：映射！！ Detail: Heapsort , map //就是很多 pair 组成一个红黑树 O((last-first)*log(middle-first)) insert() O(logn) sort()系列: erase() O(logn) partial_sort_copy(first, last, result_first, result_last, find() O(logn) 找不到返回 a.end() cmp); lower_bound() O(logn) 查找第一个不小于 k 的元素 //输入到另一个容器，不破坏原有序列 upper_bound() O(logn) 查找第一个大于 k 的元素 bool is_sorted(first, last, cmp); equal_range() O(logn) 返回 pair //判断是否已经有序 [key]运算符 O(logn) *** //这个..太猛了，怎么说呢，数组有一个下标， nth_element(first, nth, last, cmp); 如 a[i],这里 i 是 int 型的。数组可以认为是从 int 印射到另一个类型的印 //使[first,nth)的元素不大于[nth,last), O(N) 射，而 map 是一个任意的印射，所以 i 可以是任何类型的！ e.g. input: 7, 2, 6, 11, 9, 3, 12, 10, 8, 4, 1, 5 允许重复元素, 没有[]运算符 nth_element(A,A+6,A+12); Output: 5 2 6 1 4 3 7 8 9 10 11 12 内部实现: 堆 //优先队列，听 RoBa 讲得，似乎知道原理了，但不明白干 什么用的 2. binary_search() priority_queue bool binary_search(ForwardIterator first, ForwardIterator 支持操作: last, const LessThanComparable&amp; value); push() O(n) bool binary_search(ForwardIterator first, ForwardIterator pop() O(n) last, const T&amp; value, StrictWeakOrdering comp); top() O(1) 在[first,last)中查找 value，如果找到返回 Ture,否则返回 False See also: push_heap(), pop_heap() ?in 二分检索，复杂度 O(log(last-first)) 用法举例: v.s. bsearch() in C priority_queue maxheap; //int 最大堆 Binary_search()系列 struct ltstr { //又是这么个 Compare 函数，重载运算符？？？不明 itr upper_bound(first, last, value, cmp); 白为什么要这么写...反正这个 Compare 函数对我来说是相当之神奇。RoBa //itr 指向大于 value 的第一个值(或容器末尾) 说了，照着这么写就是了。 itr lower_bound(first, last, value, cmp); bool operator()(int a,int b) //itr 指向不小于 valude 的第一个值(或容器末尾) {return a &gt; b;} pair equal_range(first, last, value, cmp); }; //找出等于 value 的值的范围 O(2*log(last ?first)) priority_queue minheap; //int 最小堆 int A[N] = {1,2,3,3,3,5,8} *upper_bound(A,A+N,3) == 5 1.sort() *lower_bound(A,A+N,3) == 3 void sort(RandomAccessIterator first, RandomAccessIterator last); make_heap(first,last,cmp) O(n) void sort(RandomAccessIterator first, RandomAccessIterator push_heap(first,last,cmp) O(logn) last, StrictWeakOrdering comp); pop_heap(first,last,cmp) O(logn) 区间[first,last) is_heap(first,last,cmp) O(n) Quicksort,复杂度 O(nlogn) e.g: (n=last-first,平均情况和最坏情况) vector vi; 用法举例: while (scanf(?d?&amp;n) != EOF) { 1.从小到大排序(int, double, char, string, etc) vi.push_back(n); const int N = 5; push_heap(vi.begin(),vi.end()); int main() } { int a[N] = {4,3,2,6,1}; Others interesting: string str[N] = {揟JU?擜CM?擨CPC?攁bc?攌kkkk攠; next_permutation(first, last, cmp) sort(a,a+N); prev_permutation(first, last, cmp) sort(str,str+N); //both O(N) return 0; min(a,b); } max(a,b); 2.从大到小排序（需要自己写 comp 函数) min_element(first, last, cmp); const int N = 5; max_element(first, last, cmp); int cmp(int a,int b) {return a &gt; b;} int main() Others interesting: { fill(first, last, value) int a[N] = {4,3,2,6,1}; reverse(first, last) sort(a,a+N,cmp); rotate(first,middle,last); return 0; itr unique(first, last); } //返回指针指向合并后的末尾处 3. 对结构体排序 random_shuffle(first, last, rand) struct SS {int first,second;}; int cmp(SS a,SS b) { 头文件 if (a.first != b.first) return a.first &lt; b.first; #include return a.second &lt; b.second; #include } #include <map>#include v.s. qsort() in C (平均情况 O(nlogn)，最坏情况 #include O(n^2)) //qsort 中的 cmp 函数写起来就麻烦多了！ #include int cmp(const void *a,const void *b) { #include 42 #include //将线段树上区间的端点分别映射到 y[]数组所对应的浮点数上, #include 由此计算出测度 #include ST[root].m = y[ST[root].ed-1] - y[ST[root].st-1]; #include else if(ST[root].ed - ST[root].st == 1) #include ST[root].m = 0; #include else ST[root].m = ST[root*2].m + ST[root*2+1].m; #include } #include void insert(int root, int st, int ed){ #include if(st &lt;= ST[root].st &amp;&amp; ST[root].ed &lt;= ed){ #include ST[root].c++; #include updata(root); return ; using namespace std; } if(ST[root].ed - ST[root].st == 1)return ;//不出错的话 这句话就是冗余的 int mid = (ST[root].ed + ST[root].st)/2; if(st &lt; mid) insert(root*2, st, ed); if(ed &gt; mid) insert(root*2+1, st, ed); updata(root); } void Delete(int root, int st, int ed){ 线段树 if(st &lt;= ST[root].st &amp;&amp; ST[root].ed &lt;= ed){ ST[root].c--; updata(root); return ; } if(ST[root].ed - ST[root].st == 1)return ; //不出错的话 这句话就是冗余的 求矩形并的面积（线段树+离散化+扫描线） int mid = (ST[root].st + ST[root].ed)/2; /* pku1151-Atlantis if(st &lt; mid) Delete(root*2, st, ed); Each test case starts with a line containing a single integer if(ed &gt; mid) Delete(root*2+1, st, ed); n (1 &lt;= n &lt;= 100) updata(root); of available maps. The n following lines describe one map each. } Each of these lines int Correspond(int n, double t){ contains four numbers x1;y1;x2;y2 (0 &lt;= x1 &lt; x2 &lt;= 100000;0 //二分查找出浮点数 t 在数组 y[]中的位置(此即所谓的映射关系) &lt;= y1 &lt; y2 &lt;= 100000), int low,high,mid; not necessarily integers. The values (x1; y1) and (x2;y2) are low = 0; high = n-1; the coordinates of the while(low &lt; high){ top-left resp. bottom-right corner of the mapped area. mid = (low+high)/2; */ if(t &gt; y[mid]) /* low = mid + 1; 本题与 poj 1177 picture 极相似,现在回想起来甚至比 1177 还要简单一 else high = mid; 些.与 1177 不同的是 } 本题中的坐标是浮点类型的, 故不能将坐标直接离散.我们必须为它们建立一 return high+1; 个对应关系,用一个 } 整数去对应一个浮点数这样的对应关系在本题的数组 y[] 中 bool cmp(line l1, line l2){ */ return l1.x &lt; l2.x; #include } #include #include int main() #include { using namespace std; int n,i,num,l,r,c=0; double area,x1,x2,y1,y2; struct node while(cin&gt;&gt;n, n){ { for(i = 0; i &lt; n; i++){ int st, ed, c; //c : 区间被覆盖的层数, m: 区间的测度 cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; double m; Line[2*i].x = x1; Line[2*i].y1 = y1; }ST[802]; Line[2*i].y2 = y2; Line[2*i].s = 1; Line[2*i+1].x = x2; Line[2*i+1].y1 = y1; struct line Line[2*i+1].y2 = y2; Line[2*i+1].s = 0; { ty[2*i] = y1; ty[2*i+1] = y2; double x,y1,y2; //纵方向直线, x:直线横坐标, y1 y2:直线上 } 的下面与上面的两个纵坐标 n &lt;&lt;= 1; bool s; //s = 1 : 直线为矩形的左边, s = 0:直线为 sort(Line, Line+n, cmp); 矩形的右边 sort(ty, ty+n); }Line[205]; y[0] = ty[0]; double y[205],ty[205]; //y[] 整数与浮点数的对应数组; ty[]:用来 //处理数组 ty[]使之不含重覆元素,得到新的数组存放到数组 y[] 求 y[]的辅助数组 中 for(i=num=1; i &lt; n; i++) void build(int root, int st, int ed) if(ty[i] != ty[i-1]) { y[num++] = ty[i]; ST[root].st = st; build(1, 1, num); //树的叶子节点与数组 y[]中的元 ST[root].ed = ed; 素个数相同,以便建立一一对应关系 ST[root].c = 0; area = 0; ST[root].m = 0; for(i = 0; i &lt; n-1; i++){ if(ed - st &gt; 1){ //由对应关系计算出线段两端在树中的位置 int mid = (st+ed)/2; l = Correspond(num, Line[i].y1); build(root*2, st, mid); r = Correspond(num, Line[i].y2); build(root*2+1, mid, ed); if(Line[i].s) //插入矩形的左边 } insert(1, l, r); } else //删除矩形的右边 inline void updata(int root){ Delete(1, l, r); if(ST[root].c &gt; 0) area += ST[1].m * (Line[i+1].x - 43 Line[i].x); if(st &lt; mid)Delete(st, ed, 2*v+1); } if(ed &gt; mid)Delete(st, ed, 2*v+2); cout&lt;&lt;"Test case #"&lt;&lt;++c&lt; for(i = 0; i &lt; n; i++){ #include scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); using namespace std; a[j].x = x1; a[j].y1 = y1; a[j].y2 = y2; struct node{ a[j].d = 1; int st,ed,m,lbd,rbd; j++; int sequence_line,count; a[j].x = x2; a[j].y1 = y1; a[j].y2 = y2; }ST[40005]; a[j].d = 0; void build(int st, int ed, int v){ //建树，区间为 [st, j++; ed] if(suby &gt; y1)suby = y1; ST[v].st = st; ST[v].ed = ed; if(upy &lt; y2)upy = y2; ST[v].m = ST[v].lbd = ST[v].rbd = 0; } ST[v].sequence_line = ST[v].count = 0; sort(a, a+j, cmp); if(ed - st &gt; 1){ build(suby,upy,0); int mid = (st+ed)/2; cal_C(j); build(st, mid, 2*v+1); } build(mid, ed, 2*v+2); return 0; } } } void cal_C(int n){ inline void UpData(int v){ //更 int i,j,k,t2,sum=0; 新结点区间的测度 t2 = 0; if(ST[v].count &gt; 0){ a[n] = a[n-1]; ST[v].m = ST[v].ed - ST[v].st; for(i = 0; i &lt; n; i++){ ST[v].lbd = ST[v].rbd = 1; if(a[i].d == 1) insert(a[i].y1, a[i].y2, 0); ST[v].sequence_line = 1; else Delete(a[i].y1, a[i].y2, 0); return; sum += ST[0].sequence_line * (a[i+1].x-a[i].x) } * 2; if(ST[v].ed - ST[v].st == 1){ sum += abs(ST[0].m - t2); ST[v].m = 0; t2 = ST[0].m; ST[v].lbd = ST[v].rbd = 0; } ST[v].sequence_line = 0; printf("%d\n",sum); } } else { int left = 2*v+1, right = 2*v+2; ST[v].m = ST[left].m + ST[right].m; ST[v].sequence_line = ST[left].sequence_line + ST[right].sequence_line - (ST[left].rbd &amp; ST[right].lbd); ST[v].lbd = ST[left].lbd; ST[v].rbd = ST[right].rbd; } } void insert(int st, int ed, int v){ if(st &lt;= ST[v].st &amp;&amp; ed &gt;= ST[v].ed){ ST[v].count++; UpData(v); return ; } int mid = (ST[v].st + ST[v].ed)/2; if(st &lt; mid)insert(st, ed, 2*v+1); if(ed &gt; mid)insert(st, ed, 2*v+2); UpData(v); } void Delete(int st, int ed, int v){ if(st &lt;= ST[v].st &amp;&amp; ed &gt;= ST[v].ed){ ST[v].count--; UpData(v); return; } int mid = (ST[v].st + ST[v].ed)/2; 44</map></map></map></map>
