<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[shengsheng的博客]]></title>
  <link href="http://www.shengsheng.net/atom.xml" rel="self"/>
  <link href="http://www.shengsheng.net/"/>
  <updated>2020-12-07T09:31:25+08:00</updated>
  <id>http://www.shengsheng.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[node.js web框架]]></title>
    <link href="http://www.shengsheng.net/16081725657882.html"/>
    <updated>2020-12-17T10:36:05+08:00</updated>
    <id>http://www.shengsheng.net/16081725657882.html</id>
    <content type="html"><![CDATA[
<p>有个小服务，需要使用node.js运行，需要提供一个后台给运营人员使用，故使用node web框架来搭建。Egg.js是不错的选择，不过服务不需要那么大型，所以采用koa快速开发</p>

<h1 id="toc_0">使用到的node.js扩展</h1>

<pre><code class="language-text">// web框架
const Koa = require(&#39;koa&#39;);
// 路由
const router = require(&#39;koa-router&#39;)();
// 运行系统shell脚本
const shelljs = require(&#39;shelljs&#39;);
// http请求
const koaBody = require(&#39;koa-body&#39;);
// 文件操作
const fs = require(&#39;fs&#39;);
// 路径相关
const path = require(&quot;path&quot;);
// 静态资源服务器
const static = require(&#39;koa-static&#39;);
// zip压缩与解压
// const AdmZip = require(&#39;adm-zip&#39;);
// 支付中文版的adm-zip
const AdmZip = require(&#39;adm-zip-iconv&#39;);
</code></pre>

<h1 id="toc_1">router路由</h1>

<pre><code class="language-text">router.get(&#39;/test&#39;, async (ctx, next) =&gt; {
    console.log(ctx.response);
    ctx.response.body = &#39;&lt;h1&gt;test&lt;/h1&gt;&#39;;
});

// 导航
router.post(&#39;/nav&#39;, async (ctx, next) =&gt; {
    ctx.response.body = Nav;
});
</code></pre>

<h1 id="toc_2">核心功能</h1>

<pre><code class="language-text">function extractfile(filePath,filename)
{
    console.log(&#39;开始解压:&#39;+filePath);
    // 停两秒才继续上传
    sleep(2000);
    // 要上传完才能进行处理
    const filetmp = new AdmZip(filePath,&#39;GBK&#39;);
    filetmp.extractAllTo(&#39;./js3/&#39;+filename,true);  // output | js3
}

router.post(&#39;/upload&#39;, async (ctx, next) =&gt; {
    const file = ctx.request.files.gamezip; // 获取上传文件
    console.log(file.name);
    let filePath = path.join(__dirname, &#39;/zipupload/&#39;) + `${file.name}`;
    // 这里设置了异步
    console.log(&#39;开始上传&#39;);
    const reader = fs.createReadStream(file.path);
    const writer = fs.createWriteStream(filePath);
    reader.pipe(writer);
    reader.on(&#39;end&#39;, () =&gt; {
        console.log(&#39;上传成功&#39;);
        extractfile(filePath,file.name);
        var p1 = new Promise((resolve, reject) =&gt; {
            resolve(&#39;成功&#39;);
        });
        p1.then(function(){
            console.log(&quot; 【执行】：zsh obf_terser_dir.sh &quot; + &quot; auto&quot;+ctx.request.body.mixtype + &quot; &quot;+ctx.request.body.gameid);
            shelljs.exec( &quot; zsh obf_terser_dir.sh &quot; + &quot; auto&quot;+ctx.request.body.mixtype + &quot; &quot;+ctx.request.body.gameid, { async : true } ) ;
        })
        .then(
            console.log(&quot;end!&quot;)
        );
    });
    return ctx.body = Nav+&quot;&lt;p&gt;正在执行任务!&lt;/p&gt;&quot;;
});
</code></pre>

<h1 id="toc_3">运行程序</h1>

<pre><code class="language-text">const staticPath = &#39;/zip&#39;
const main2 = static(path.join(__dirname,staticPath));

// 查看静态文件
app.use(main2);
// 验证登录
app.use(authlogin);
// 操作相关
app.use(router.routes());

// app.use(main);
// 监听3000端口
app.listen(3000);
console.log(&#39;app started at port 3000...&#39;);
</code></pre>

<h1 id="toc_4">总结</h1>

<p>总的来说入门理解比较容易，能快速开发，基本完成这个项目只花了两天时间。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[华为hcip证书]]></title>
    <link href="http://www.shengsheng.net/16073046089051.html"/>
    <updated>2020-12-07T09:30:08+08:00</updated>
    <id>http://www.shengsheng.net/16073046089051.html</id>
    <content type="html"><![CDATA[
<p>h12-221,h12-222,h12-223,共三科。<br/>
<img src="media/16073046089051/16073046741619.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELK数据分析]]></title>
    <link href="http://www.shengsheng.net/16045584516905.html"/>
    <updated>2020-11-05T14:40:51+08:00</updated>
    <id>http://www.shengsheng.net/16045584516905.html</id>
    <content type="html"><![CDATA[
<p>ELK（elasticsearch、logstash、kibana）,使用这个套件分析数据<br/>
logstash占用比较大，实际只用了filebeat作为分析使用。</p>

<h1 id="toc_0">搭建</h1>

<p>自己可以根据docker来搭建，当然也可以直接使用腾讯云的elasticsearch service服务。</p>

<h1 id="toc_1">客户端</h1>

<p>在客户端装上filebeat</p>

<pre><code class="language-text">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.5.1-x86_64.rpm
sudo rpm -vi filebeat-7.5.1-x86_64.rpm
</code></pre>

<p>编辑/etc/filebeat/filebeat.yml内容</p>

<pre><code class="language-text">filebeat.config.modules:
  path: ${path.config}/modules.d/*.yml
  reload.enabled: true
  reload.period: 10s
setup.kibana:
  host: &quot;xxxx.kibana.tencentelasticsearch.com:5601&quot;

output.elasticsearch:
      hosts: [&quot;172.16.16.8:9200&quot;]
      protocol: &quot;http&quot;
      username: &quot;elastic&quot;
      password: &quot;xxx&quot;
      
</code></pre>

<p>这里使用nginx module，上报一下nginx</p>

<pre><code class="language-text">filebeat modules enable nginx
filebeat modules list  # 查看启动之后的模块
# /etc/filebeat/modules.d/nginx.yml 填写相关nginx日志文件
filebeat setup
systemctl start filebeat
# 可使用filebeat -e 测试并打印一下
</code></pre>

<p>回到kibana查看dashboard与日志</p>

<h3 id="toc_2">nginx数据</h3>

<p><img src="media/16045584516905/16045588949397.jpg" alt=""/></p>

<h3 id="toc_3">系统cpu</h3>

<p><img src="media/16045584516905/16045589182355.jpg" alt=""/></p>

<h1 id="toc_4">总结</h1>

<p>使用云服务不用懂配置，直接就能使用了,相对监控来说，elk这块使用上更方便。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php微服务的分享]]></title>
    <link href="http://www.shengsheng.net/16002662215905.html"/>
    <updated>2020-09-16T22:23:41+08:00</updated>
    <id>http://www.shengsheng.net/16002662215905.html</id>
    <content type="html"><![CDATA[
<p>几分钟写的ppt，讲了一小时。<br/>
<img src="media/16002662215905/16002662808301.jpg" alt=""/></p>

<p><img src="media/16002662215905/16002663188569.jpg" alt=""/></p>

<p>多交流交流！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运营后台相关参数]]></title>
    <link href="http://www.shengsheng.net/15983439644690.html"/>
    <updated>2020-08-25T16:26:04+08:00</updated>
    <id>http://www.shengsheng.net/15983439644690.html</id>
    <content type="html"><![CDATA[
<p>整理一下通用后台用到的统计标准，一文说清所有的指标。</p>

<h2 id="toc_0">实用指标</h2>

<p>日期<br/>
区服<br/>
新增注册数：规定区服条件下的新增注册玩家数<br/>
老用户：规定区服条件下的非当日新增注册的登陆玩家数<br/>
DAU：新增注册数+老用户 （日活跃用户）<br/>
新用户付费金额：新增注册玩家的总付费金额 （新总）<br/>
总付费金额：新增注册玩家+老用户产生的总充值金额 （新+老）<br/>
新用户付费人数：新增注册玩家中充值玩家总数 （新付人数）<br/>
新增付费率：新用户付费数/新增注册数 （新付数/新)<br/>
总付费人数：新增注册玩家+老用户产生的总充值人数 (新付+老付)<br/>
注册ARPPU：新用户付费金额/新用户付费人数 （新付/新付数）<br/>
活跃ARPPU：总付费金额/总付费人数  （总付/总付人）<br/>
活跃付费率：总付费人数/DAU  (总付数/活跃人数)<br/>
活跃ARPU：活跃ARPPU<em>活跃付费率 (arppu</em>付费率，也可以= 总付金额/dau)<br/>
至今（LTV和充值类型数据 可加入）<br/>
活跃ARPU：活跃ARPPU*活跃付费率 （同上，很好理解，反过来的逻辑）<br/>
新增付费率 = （新增付费人数 / 新增注册数) <br/>
活跃付费率 = 付费用户数 / 总用户数<br/>
注册ARPU = 新增人数付费金额 / 新增注册数<br/>
注册ARPPU = 新增人数付费金额 / 新增付费人数<br/>
活跃ARPU = 付费金额 / 总用户数<br/>
活跃ARPPU = 付费金额 / 付费人数<br/>
活跃付费率 = 付费用户 / 总用户数<br/>
注册成本 = 成本 / 新增注册数 <br/>
激活注册率 = 注册 / 激活数  （这个要创角上传的情况下）<br/>
激活成本 = 成本 / 激活数     （激活看是否注册还是创角）<br/>
创角率 = 创角数 / 新增注册数<br/><br/>
DNU（Daily New Users）： 每日游戏中的新登入用户数量<br/>
AU（Active Users）：活跃用户，统计周期内，登录过游戏的用户数<br/>
相应的，根据统计周期，有DAU(日活跃用户)，WAU(周活跃用户),MAU(月活跃用户)等。<br/>
PU ( Paying User）：付费用户<br/>
APA（Active Payment Account）：活跃付费用户数<br/>
这里我们要注意“用户”和“付费用户”的区分，这也将影响收入的计算。<br/>
ARPU(Average Revenue Per User) ：平均每用户收入，即可通过 总收入/AU 计算得出。(平均收入每个用户)<br/>
ARPPU (Average Revenue Per Paying User)： 平均每付费用户收入，可通过 总收入/APA 计算得出。（平均收入每个付费用户)<br/>
PUR(Pay User Rate)：付费比率，可通过 APA/AU 计算得出。<br/>
LTV(Lift Time Value)：生命周期价值，即平均一个用户在首次登录游戏到最后一次登录游戏内，为该游戏创造的收入总计<br/>
投资回报率（ROI）=产出（销售收入）/ 投入（成本<br/>
至今LTV = 累积金额 / 总人数<br/>
苹果至今=苹果内购累积金额/注册数<br/>
苹果付费金额</p>

<h2 id="toc_1">其它</h2>

<p>CPA：<br/>
Cost Per Action 每效果成本——即按照效果付费。</p>

<p>CPC：<br/>
Cost Per Click;Cost Per Thousand Click-Through 每点击成本。</p>

<p>CPT：<br/>
Cost Per Time，CPT 是一种以时间来计费的广告。</p>

<p>CPS：<br/>
英文全称 Cost Per Sales。CPS 是一种以实际销售产品数量来计算广告费用的广告。</p>

<p>CPPA：<br/>
按照到达用户付费。既不是按照浏览量（PV）付费，也不是按照实际效果付费，而是按照到达的用户那个付费，在网站上等同于 UV，在手机端是新增用户上游数据（例如用户已下载安装还未打开激活 APP 的数量即为到达用户）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[safari阻止cookie写入]]></title>
    <link href="http://www.shengsheng.net/15951652105930.html"/>
    <updated>2020-07-19T21:26:50+08:00</updated>
    <id>http://www.shengsheng.net/15951652105930.html</id>
    <content type="html"><![CDATA[
<p>今天在某个网站里iframe另一个网站的地址<br/>
发现手机safari不同域的情况下，另一个网站老是写不下cookie。<br/>
只有关闭safari里的阻止跨网站跟踪才行。<br/>
so,尽量不要使用cookie通讯了，如果想运行得更好，那使用localstorage吧</p>

<p><img src="media/15951652105930/15951655340274.jpg" alt=""/></p>

<p><img src="media/15951652105930/15951653541414.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[k8s使用笔记]]></title>
    <link href="http://www.shengsheng.net/15951637392913.html"/>
    <updated>2020-07-19T21:02:19+08:00</updated>
    <id>http://www.shengsheng.net/15951637392913.html</id>
    <content type="html"><![CDATA[
<p>k8s全称kerbernets，docker集群的工具</p>

<h2 id="toc_0">安装k8s</h2>

<p>首先得有docker环境，安装完之后继续下一步</p>

<pre><code class="language-text">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
</code></pre>

<p>设置好数据源之后<br/>
安装指定的</p>

<pre><code class="language-text"> yum -y install kubelet-1.17.0 kubeadm-1.17.0
</code></pre>

<p>以上操作，从机也要进行下载</p>

<pre><code class="language-text">systemctl enable docker &amp;&amp; systemctl start docker
systemctl enable kubelet &amp;&amp; systemctl start kubelet
</code></pre>

<p>启动docker与kubelet服务</p>

<h3 id="toc_1">每个机器设置一下hostname</h3>

<p>hostnamectl set-hostname k8s-master<br/>
hostnamectl set-hostname k8s-slave01<br/>
hostnamectl set-hostname k8s-slave02<br/>
有便于后面的区分</p>

<h2 id="toc_2">k8s的核心思想</h2>

<p>node pods deployment service</p>

<h3 id="toc_3">新建命令空间</h3>

<p>新建namespce.yaml文件</p>

<pre><code class="language-text">apiVersion: v1
kind: Namespace
metadata:
  name: work

</code></pre>

<h2 id="toc_4">deployment</h2>

<p>搭建swagger-ui作演示<br/>
swagger-ui-deployment</p>

<pre><code class="language-text">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: swagger-ui
  name: swagger-ui
  namespace: work
spec:
  selector:
    matchLabels:
      app: swagger-ui
  replicas: 1
  template:
    metadata:
      labels:
        app: swagger-ui
    spec:
      containers:
      - env:
        image: swaggerapi/swagger-ui
        name: swagger-ui
        volumeMounts:
          - mountPath: /usr/share/nginx/html/config
            name: doc-volume
        ports:
        - containerPort: 8080
      volumes:
        - name: doc-volume
          hostPath:
            # directory location on host
            path: /webwww/swagger
            # this field is optional
            type: Directory

</code></pre>

<h2 id="toc_5">service</h2>

<p>以swagger作演示<br/>
swagger-ui-service.yaml</p>

<pre><code class="language-text">apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: swagger-ui
  name: swagger-ui
  namespace: work
spec:
  selector:
    matchLabels:
      app: swagger-ui
  replicas: 1
  template:
    metadata:
      labels:
        app: swagger-ui
    spec:
      containers:
      - env:
        image: swaggerapi/swagger-ui
        name: swagger-ui
        volumeMounts:
          - mountPath: /usr/share/nginx/html/config
            name: doc-volume
        ports:
        - containerPort: 8080
      volumes:
        - name: doc-volume
          hostPath:
            # directory location on host
            path: /webwww/swagger
            # this field is optional
            type: Directory
</code></pre>

<h2 id="toc_6">相关命令</h2>

<p>查看work命令空间所有的pods<br/>
kubectl get pods -n work</p>

<p>查看相关节点<br/>
kubectl get nodes</p>

<p>制作pods集<br/>
kubectl create -f swagger-ui-deployment.yaml</p>

<p>查看指定pod相关信息<br/>
kubectl describe pods swagger-ui-c69f9f4cf-kbft9 -n work<br/>
查看指定pod详细信息<br/>
kubectl describe pods swagger-ui-c69f9f4cf-kbft9 -n work</p>

<p>制作service暴露外部<br/>
kubectl apply -f swagger-ui-service.yaml</p>

<p>删除指定的service<br/>
kubectl delete -f swagger-ui-service.yaml</p>

<p>查看有哪些service<br/>
kubectl get svc -n work</p>

<p>更新相关配置<br/>
kubectl replace -f nginx.yaml</p>

<p>进入指定pods<br/>
kubectl -n work exec -it gitlab-67f74459f4-qdqtf /bin/bash</p>

<h2 id="toc_7">注意点</h2>

<p>Pod并非一个持久化的东西，很有可能突然挂了，并且没有能力自我修复，这就是为啥我们把它们和controller一起用，这样可以来控制pod的replica，容错，自我修复等等。比较有名的例子比如Deployments，ReplicaSets等。我们通过把Pod的定义（specification，也就是spec）附加到别的对象（也就是之前用的template.spec）来完成。</p>

<p>k8s会有两个默认Namespace：kube-system和default。kube-system一般会用来放一些Kubernetes系统的组件，default会用来放一些属于其它Namespace的对象。我们默认情况下是会连接到default命名空间。kube-public是一个特殊的namespace，可以被所有的用户读，一般用于特殊情况比如初始化一个集群。</p>

<p>Docker 启动时可以用 --publish/-p 参数配置端口映射规则，Pod 的定义设置容器的映射规则如：</p>

<p>apiVersion: v1<br/>
kind: Pod<br/>
metadata:<br/>
  name: nginx<br/>
spec:<br/>
  containers:<br/>
  - name: nginx<br/>
    image: &quot;nginx:1.11&quot;<br/>
    ports:<br/>
    - name: web<br/>
      containerPort: 80<br/>
      protocol: TCP<br/>
      hostIP: 0.0.0.0<br/>
      hostPort: 80<br/>
name：设置端口名称，必须 Pod 内唯一，当只配置一个端口的时候，这是一个可选项，当配置多个端口的时候，这是一个必须项。<br/>
containerPort：必须项，设置在容器内的端口，有效范围 1 ~ 65535。<br/>
protocol：可选项，设置端口的协议，TCP 或者 UDP，默认是 TCP。<br/>
hostIP：可选项，是指在宿主机上的IP，默认绑定到所有可用的 IP 上，即 0.0.0.0 。<br/>
hostPort：可选项，设置在宿主机上的端口，如果设置则进行端口映射，有效范围 1 ~ 65535。</p>

<h2 id="toc_8">总结</h2>

<p>总的来说相对复制，生产上使用必须要把核心理解清楚。</p>

<h2 id="toc_9">相关阅读</h2>

<p><a href="https://zhuanlan.zhihu.com/p/94628967">安装k8s</a><br/>
<a href="https://blog.csdn.net/fanren224/article/details/86610799%0Ahttps://zdyxry.github.io/2019/08/01/Kubernetes-%E5%AE%9E%E6%88%98-%E5%B9%B3%E6%BB%91%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9/">k8s增减node</a></p>

<p><a href="https://www.jianshu.com/p/70e9c0b5fd25">kubectl delete pod 后又创建了一个新的pod</a></p>

<p>1 node(s) had taints that the pod didn&#39;t tolerate.<br/>
有时候一个pod创建之后一直是pending，没有日志，也没有pull镜像，describe的时候发现里面有一句话： 1 node(s) had taints that the pod didn&#39;t tolerate.</p>

<p>直译意思是节点有了污点无法容忍，执行 kubectl get no -o yaml | grep taint -A 5 之后发现该节点是不可调度的。这是因为kubernetes出于安全考虑默认情况下无法在master节点上部署pod，于是用下面方法解决：</p>

<p>kubectl taint nodes --all node-role.kubernetes.io/master-<br/>
<a href="https://my.oschina.net/eima/blog/1860598">https://my.oschina.net/eima/blog/1860598</a><br/>
<a href="https://kubernetes.io/zh/docs/concepts/services-networking/connect-applications-service/">https://kubernetes.io/zh/docs/concepts/services-networking/connect-applications-service/<br/>
</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php composer应该注意的点]]></title>
    <link href="http://www.shengsheng.net/15950818535796.html"/>
    <updated>2020-07-18T22:17:33+08:00</updated>
    <id>http://www.shengsheng.net/15950818535796.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">phpcomposer的安装方式</h2>

<pre><code class="language-text">php -r &quot;copy(&#39;https://install.phpcomposer.com/installer&#39;, &#39;composer-setup.php&#39;);&quot;
php composer-setup.php
mv composer.phar /usr/local/bin/composer
</code></pre>

<h2 id="toc_1">查看镜像源等配置</h2>

<p>composer config -l -g<br/>
<img src="media/15950818535796/15950818960608.jpg" alt=""/></p>

<p>设定阿里源站</p>

<pre><code class="language-text">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
</code></pre>

<h2 id="toc_2">要安装的php扩展</h2>

<p>一定要安装php的zip扩展，不然走github下载就更慢了<br/>
<img src="media/15950818535796/15950819597920.jpg" alt=""/></p>

<p>走国内源也就几秒的事情<br/>
<img src="media/15950818535796/15950820367441.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JetBrains免费获取]]></title>
    <link href="http://www.shengsheng.net/15946911363103.html"/>
    <updated>2020-07-14T09:45:36+08:00</updated>
    <id>http://www.shengsheng.net/15946911363103.html</id>
    <content type="html"><![CDATA[
<p>使用开源项目，免费撸了一个一年的序列号,想要的朋友自己去撸一下<a href="https://www.jetbrains.com/shop/eform/opensource">https://www.jetbrains.com/shop/eform/opensource</a></p>

<p><img src="media/15946911363103/15946911383285.jpg" alt=""/></p>

<p><img src="media/15946911363103/15946930504171.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php之redis队列]]></title>
    <link href="http://www.shengsheng.net/15936998383453.html"/>
    <updated>2020-07-02T22:23:58+08:00</updated>
    <id>http://www.shengsheng.net/15936998383453.html</id>
    <content type="html"><![CDATA[
<p>php redis队列的使用,记录一下常用代码。</p>

<h1 id="toc_0">redis常用方法</h1>

<p>通常使用redis作为缓存使用<br/>
例如：</p>

<h2 id="toc_1">字符串缓存</h2>

<pre><code class="language-text">// 设置缓存数据
redis::set(Report::$cache_key.&quot;init_&quot;.$initkey,$dataJson);
// 设置过期时间 
redis::expire(Report::$cache_key.&quot;init_&quot;.$initkey,3600);
// 获取缓存数据
redis::get(Report::$cache_key.&quot;init_&quot;.$initkey);

</code></pre>

<h2 id="toc_2">hash字典缓存</h2>

<pre><code class="language-text">$setArr = [
    &#39;putType&#39; =&gt; $result[&#39;putType&#39;],
    &#39;timestamp&#39; =&gt; $time,
    &#39;date&#39; =&gt; date(&#39;Ymd&#39;,$time),
    &#39;clickid&#39; =&gt; $result[&#39;click_id&#39;],
    &#39;putType&#39; =&gt; $result[&#39;putType&#39;],
    &#39;reg&#39; =&gt; 1
];
// 设置字典
redis::hmset($userkey,$setArr);
// 设置字典指定字段
redis::hset($userkey,&#39;pay&#39;,1);
// 获取字典所有字段
$put = redis::hgetall($userkey);
</code></pre>

<h1 id="toc_3">列表队列</h1>

<p>简单的队列操作，先进先出，出可以先进后出</p>

<pre><code class="language-text">// 放入列表
$status = redis::lpush(&quot;webSend&quot;,$dataJson);
// 获取队列列表
while($result = redis::rpop(&quot;webSend&quot;))
{
    // 获取数据之后的处理
}
</code></pre>

<h1 id="toc_4">延迟队列</h1>

<p>使用集合来作为延迟队列</p>

<pre><code class="language-text">// 添加数据
$second = 15; //延迟15秒之后执行
redis::zadd(&#39;test&#39;,time()+$second,json_encode([&#39;1&#39;,&#39;3&#39;,&#39;2&#39;]));
// 获取1个数据 limit即限制的条数
$tmp = redis::zRangeByScore(&#39;test&#39;, 0, time(), [&#39;limit&#39; =&gt; [0, 1]]);
var_dump($tmp);
// 删除指定数据
$tm = redis::zRem(&#39;test&#39;,$tmp[0]);
var_dump($tm);  //1成功 2失败
</code></pre>

<h1 id="toc_5">其它</h1>

<p>自从redis火起之后，memcache越来越少人用啦。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sql语句笔记]]></title>
    <link href="http://www.shengsheng.net/15917864708307.html"/>
    <updated>2020-06-10T18:54:30+08:00</updated>
    <id>http://www.shengsheng.net/15917864708307.html</id>
    <content type="html"><![CDATA[
<p>SELECT * FROM A WHERE cc IN (SELECT cc FROM B)</p>

<p>SELECT * FROM A WHERE EXIST (SELECT cc FROM B WHERE B.cc=A.cc)</p>

<p>SQL: SELECT player_id, player_name, height FROM player WHERE height &gt; ANY (SELECT height FROM player WHERE team_id = 1002)</p>

<p>笛卡尔面积：<br/>
SQL: SELECT * FROM player, team</p>

<p>等值相连：<br/>
SQL: SELECT player_id, player.team_id, player_name, height, team_name FROM player, team WHERE player.team_id = team.team_id</p>

<p>SELECT player_id, a.team_id, player_name, height, team_name FROM player AS a, team AS b WHERE a.team_id = b.team_id</p>

<p>非等值相连：<br/>
SQL：SELECT p.player_name, p.height, h.height_level<br/>
FROM player AS p, height_grades AS h<br/>
WHERE p.height BETWEEN h.height_lowest AND h.height_highest</p>

<p>外连接：<br/>
左链接：(sql92(+)代表从表)<br/>
SQL：SELECT * FROM player, team where player.team_id = team.team_id(+)<br/>
SQL：SELECT * FROM player LEFT JOIN team on player.team_id = team.team_id</p>

<p>SQL：SELECT * FROM player RIGHT JOIN team on player.team_id = team.team_id</p>

<p>自连接：<br/>
SQL：SELECT b.player_name, b.height FROM player as a , player as b WHERE a.player_name = &#39;布雷克 - 格里芬&#39; and a.height &lt; b.height</p>

<p>交叉连接：<br/>
实际就是笛卡尔面积：<br/>
SQL: SELECT * FROM player CROSS JOIN team</p>

<p>SQL: SELECT * FROM t1 CROSS JOIN t2 CROSS JOIN t3</p>

<p>SELECT player_id, a.team_id, player_name, height, team_name FROM player as a, team as b WHERE a.team_id = b.team_id<br/>
SELECT player_id, team_id, player_name, height, team_name FROM player NATURAL JOIN team </p>

<p>ON:<br/>
SQL99：SELECT p.player_name, p.height, h.height_level<br/>
FROM player as p JOIN height_grades as h<br/>
ON height BETWEEN h.height_lowest AND h.height_highest</p>

<p>using:<br/>
等名等值连接:<br/>
SELECT player_id, team_id, player_name, height, team_name FROM player JOIN team USING(team_id)</p>

<p>left join = left outer join<br/>
right join = right outer join<br/>
full join = full outer join</p>

<p>全外连接：<br/>
实际就是左右连接的结合：<br/>
full join <br/>
SELECT * FROM player FULL JOIN team ON player.team_id = team.team_id</p>

<p>SELECT b.player_name, b.height FROM player as a , player as b WHERE a.player_name = &#39;布雷克 - 格里芬&#39; and a.height &lt; b.height</p>

<p>SELECT b.player_name, b.height FROM player as a JOIN player as b ON a.player_name = &#39;布雷克 - 格里芬&#39; and a.height &lt; b.height</p>

<p>交叉连接：也称为笛卡尔积，返回左表中每一行与右表中每一行的组合。在 SQL99 中使用的 CROSS JOIN。</p>

<p>视图：<br/>
简化复杂的sql<br/>
CREATE VIEW view_name AS<br/>
SELECT column1, column2<br/>
FROM table<br/>
WHERE condition</p>

<p>修改视图：<br/>
ALTER VIEW view_name AS<br/>
SELECT column1, column2<br/>
FROM table<br/>
WHERE condition</p>

<p>删除视图：<br/>
DROP VIEW view_name</p>

<p>存储过程：</p>

<pre><code class="language-text">CREATE PROCEDURE `add_num`(IN n INT)
BEGIN
       DECLARE i INT;
       DECLARE sum INT;
       
       SET i = 1;
       SET sum = 0;
       WHILE i &lt;= n DO
              SET sum = sum + i;
              SET i = i +1;
       END WHILE;
       SELECT sum;
END



DELIMITER //
CREATE PROCEDURE `add_num`(IN n INT)
BEGIN
       DECLARE i INT;
       DECLARE sum INT;
       
       SET i = 1;
       SET sum = 0;
       WHILE i &lt;= n DO
              SET sum = sum + i;
              SET i = i +1;
       END WHILE;
       SELECT sum;
END //
DELIMITER ;

CREATE PROCEDURE `get_hero_scores`(
       OUT max_max_hp FLOAT,
       OUT min_max_mp FLOAT,
       OUT avg_max_attack FLOAT,  
       s VARCHAR(255)
       )
BEGIN
       SELECT MAX(hp_max), MIN(mp_max), AVG(attack_max) FROM heros WHERE role_main = s INTO max_max_hp, min_max_mp, avg_max_attack;
END

</code></pre>

<p>out 返回的值<br/>
in 传入参数<br/>
inout 即可传入参数，又可返回的值</p>

<p>事务：<br/>
acid:<br/>
a 原子性<br/>
c 一致性<br/>
i 隔离性<br/>
d 持久性</p>

<p>mysql&gt; set autocommit =0;  // 关闭自动提交<br/>
mysql&gt; set autocommit =1;  // 开启自动提交</p>

<p>你有没有发现什么异常？这个时候小张还没有提交事务，但是小李却读到了小张还没有提交的数据，这种现象我们称之为“脏读”。</p>

<p>这个时候你会发现，两次查询的结果并不一样。小张会想这是怎么回事呢？他明明刚执行了一次查询，马上又进行了一次查询，结果两次的查询结果不同。实际上小张遇到的情况我们称之为“不可重复读”，也就是同一条记录，两次读取的结果不同。</p>

<p>他发现这一次查询多了一个英雄，原来只有 3 个，现在变成了 4 个。这种异常情况我们称之为“幻读”。</p>

<p>脏读：读到了其他事务还没有提交的数据。</p>

<p>不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。</p>

<p>幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。</p>

<p>读未提交，也就是允许读到未提交的数据，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。</p>

<p>读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于 RDBMS 中常见的默认隔离级别（比如说 Oracle 和 SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在 SQL 查询的时候编写带加锁的 SQL 语句（我会在进阶篇里讲加锁）。</p>

<p>可重复读，保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL 默认的隔离级别就是可重复读。</p>

<p>可串行化，将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。</p>

<p>mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</p>

<p>游标：</p>

<pre><code class="language-text">DECLARE cur_hero CURSOR FOR 
    SELECT hp_max FROM heros;

FETCH cursor_name INTO var_name ...

CLOSE cursor_name
</code></pre>

<p>释放游标：</p>

<pre><code class="language-text">DEALLOCATE PREPARE


CREATE PROCEDURE `alter_attack_growth`()
BEGIN
       -- 创建接收游标的变量
       DECLARE temp_id INT;  
       DECLARE temp_growth, temp_max, temp_start, temp_diff FLOAT;  

       -- 创建结束标志变量  
       DECLARE done INT DEFAULT false;
       -- 定义游标     
       DECLARE cur_hero CURSOR FOR SELECT id, attack_growth, attack_max, attack_start FROM heros;
       -- 指定游标循环结束时的返回值  
       DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;  
       
       OPEN cur_hero;  
       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;
       REPEAT
                     IF NOT done THEN
                            SET temp_diff = temp_max - temp_start;
                            IF temp_growth &lt; 5 THEN
                                   IF temp_diff &gt; 200 THEN
                                          SET temp_growth = temp_growth * 1.1;
                                   ELSEIF temp_diff &gt;= 150 AND temp_diff &lt;=200 THEN
                                          SET temp_growth = temp_growth * 1.08;
                                   ELSEIF temp_diff &lt; 150 THEN
                                          SET temp_growth = temp_growth * 1.07;
                                   END IF;                       
                            ELSEIF temp_growth &gt;=5 AND temp_growth &lt;=10 THEN
                                   SET temp_growth = temp_growth * 1.05;
                            END IF;
                            UPDATE heros SET attack_growth = ROUND(temp_growth,3) WHERE id = temp_id;
                     END IF;
       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;
       UNTIL done = true END REPEAT;
       
       CLOSE cur_hero;
       DEALLOCATE PREPARE cur_hero;
END

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php爬虫]]></title>
    <link href="http://www.shengsheng.net/15910095044784.html"/>
    <updated>2020-06-01T19:05:04+08:00</updated>
    <id>http://www.shengsheng.net/15910095044784.html</id>
    <content type="html"><![CDATA[
<p>基于swoole多进程与协程，撸了一下网络爬虫库。</p>

<h1 id="toc_0">demo</h1>

<p>快手后台</p>

<pre><code class="language-text">&lt;?php
/**
 * 跑取快手数据示例
 * https://k.kuaishou.com/#/index
 */
namespace demo;
// 引入composer加载
require_once dirname(__FILE__).&quot;/../vendor/autoload.php&quot;;
use \phpspiderman\phpspiderman;
$config = require_once &quot;config.php&quot;;
$mysqldb = $config[&#39;db&#39;];

$spider = new phpspiderman([
    &quot;type&quot; =&gt; 2,
    //数据库配置
    &quot;mysqlconfig&quot; =&gt; $mysqldb,
    &quot;worker_num&quot; =&gt; 4,
    &quot;totalSumField&quot; =&gt; &quot;total&quot;,
    &quot;totalPageField&quot; =&gt; &#39;&#39;,
    &quot;PageField&quot; =&gt; &#39;currentPage&#39;,
    &quot;table&quot; =&gt; &quot;spider_kuaishou&quot;,
    &quot;PageSize&quot; =&gt; 20,
    &quot;ProxyUrl&quot; =&gt; &#39;&#39;,
    &quot;url&quot; =&gt; &#39;k.kuaishou.com&#39;,
    &quot;urlport&quot; =&gt; 443,
    &quot;list&quot; =&gt; &quot;/rest/web/star/list&quot;,
    &quot;cookie&quot; =&gt; &quot;&quot;,
    &quot;body&quot; =&gt; [
        &#39;liveAvgPeopleMinNum&#39; =&gt; &#39;0&#39;,
        &#39;currentPage&#39; =&gt; 1,
        &#39;starOrderTag&#39; =&gt; 3,
        &#39;liveAvgPeopleMaxNum&#39; =&gt; null,
        &#39;starMaxPrice&#39; =&gt; null,
        &#39;ugcTag&#39; =&gt; &#39;&#39;,
        &#39;mmuStarTagIds&#39; =&gt; [
            12,3  //搞笑和游戏
        ],
        &#39;fansMinNum&#39; =&gt; 0,  //最低粉丝数
        &#39;taskType&#39; =&gt; 1,  //1 4 1视频 4直播
        &#39;cityCode&#39; =&gt; 0,
        &#39;fansMaxNum&#39; =&gt; null,
        &#39;userName&#39; =&gt; &#39;&#39;,
        &#39;provinceCode&#39; =&gt; 0,
        &#39;starOrderType&#39; =&gt; 0,
        &#39;isAppWithLink&#39; =&gt; null,
        &#39;starMinPrice&#39; =&gt; 0,
        &#39;gender&#39; =&gt; &#39;&#39;
        ],
]);

$spider-&gt;handleList = function($spider,$header,$json_array)
{
    $list = $spider-&gt;Http-&gt;getContent2($spider-&gt;urlconfig[&#39;list&#39;],$header,$json_array);
    $list = \phpspiderman\content\json::decode($list);
    return $list[&#39;starList&#39;];
};

//获取到内容的处理
$spider-&gt;handleContent = function($val = null)
{
    $data[&#39;userId&#39;] = $val[&#39;userId&#39;];
    $data[&#39;starId&#39;] = $val[&#39;starId&#39;];
    $data[&#39;name&#39;] = $val[&#39;name&#39;];
    $data[&#39;kwaiId&#39;] = $val[&#39;kwaiId&#39;];
    $data[&#39;gender&#39;] = $val[&#39;gender&#39;]==&#39;男&#39;?&#39;0&#39;:&#39;1&#39;;
    $data[&#39;fansNumber&#39;] = $val[&#39;fansNumber&#39;];
    $data[&#39;areaTag&#39;] = $val[&#39;areaTag&#39;];
    $data[&#39;headUrl&#39;] = $val[&#39;headUrl&#39;];

    $data[&#39;liveQuotedPrice&#39;] = $val[&#39;liveQuotedPrice&#39;];
    $data[&#39;oneDaysOrderBid&#39;] = $val[&#39;oneDaysOrderBid&#39;];
    $data[&#39;threeDaysOrderBid&#39;] = $val[&#39;threeDaysOrderBid&#39;];
    $data[&#39;sevenDaysOrderBid&#39;] = $val[&#39;sevenDaysOrderBid&#39;];
    return $data;

};
$spider-&gt;crawl();
</code></pre>

<h1 id="toc_1">安装</h1>

<p>composer install showx/phpspiderman</p>

<h1 id="toc_2">文档说明</h1>

<p>后续再更新！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[while(true)的思考]]></title>
    <link href="http://www.shengsheng.net/15910082719284.html"/>
    <updated>2020-06-01T18:44:31+08:00</updated>
    <id>http://www.shengsheng.net/15910082719284.html</id>
    <content type="html"><![CDATA[
<p>其实我们更多时候使用while(1)作为守护进程，帮我们处理更多的事情</p>

<h1 id="toc_0">测试while(1)</h1>

<p>使用php为例</p>

<pre><code class="language-text">$i = 1;
$time = time();
while(1)
{
    if($time != time())
    {
        echo &#39;ok|&#39;.$i.&quot;|&quot;.time().&quot;\n&quot;;
        $time = time();
        echo &quot;end\n&quot;;
        $i = 0;
    // break;
    }
    $i++;
}
</code></pre>

<p><img src="media/15910082719284/15910083567909.jpg" alt=""/><br/>
简单的操作的函数，每秒其实可以运算千万次的。<br/>
这时候我们查看一下top命令<br/>
<img src="media/15910082719284/15910084114815.jpg" alt=""/></p>

<p>实际cpu一直维持在98%左右。<br/>
我们去掉相关代码</p>

<pre><code class="language-text">while(1)
{
}
</code></pre>

<p>只保留while(true)，查看结果得知，cpu还是很高的状态。这是因为while(1)一直在进行着运算。<br/>
接着我们在while(1)里面增加sleep(1)函数,让他休息一下再执行下面的逻辑<br/>
<img src="media/15910082719284/15910085839165.jpg" alt=""/></p>

<p>可以看到cpu已经降下来了，因为有sleep停顿的操作，使代码不用一直不停地执行，所以cpu降了下来。</p>

<h1 id="toc_1">总结</h1>

<p>我们自己写守护进程的时候，要考虑一下放在进程里，程序里消耗有多少，甚至new一个mysql对象一直保持的状态下有没问题，都是要考虑的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql联合索引]]></title>
    <link href="http://www.shengsheng.net/15906766604133.html"/>
    <updated>2020-05-28T22:37:40+08:00</updated>
    <id>http://www.shengsheng.net/15906766604133.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">查询一张表的索引</h1>

<p><code><br/>
SHOW INDEX FROM T <br/>
</code><br/>
查询表 T 所有索引。</p>

<p>MySQL 中最多可以创建 16 个索引列。</p>

<h1 id="toc_1">联合索引</h1>

<p>联合索引又叫复合索引，MySQL 中的联合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。</p>

<pre><code class="language-text">where a=1 只使用了索引 a；
where a=1 and b=2 只使用了索引 a,b；
where a=1 and b=2 and c=3 使用a,b,c；
where b=1 or where c=1 不使用索引；
where a=1 and c=3 只使用了索引 a；
where a=3 and b like &#39;xx%&#39; and c=3 只使用了索引 a,b。

</code></pre>

<p><code><br/>
select * from t where year(date)&gt;2018;<br/>
</code><br/>
不会，因为在索引列上涉及到了运算。</p>

<h1 id="toc_2">InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h1>

<p>因为 B 树、Hash、红黑树或二叉树存在以下问题：</p>

<p>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；<br/>
Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高；<br/>
二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；<br/>
红黑树：树的高度随着数据量增加而增加，IO 代价高。</p>

<p>为什么 InnoDB 要使用 B+ 树来存储索引？<br/>
B+Tree 中的 B 是 Balance，是平衡的意思，它在经典 B Tree 的基础上进行了优化，增加了顺序访问指针，在B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree，这样就提高了区间访问性能：如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率（无需返回上层父节点重复遍历查找减少 IO 操作）。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[workerman ip的获取]]></title>
    <link href="http://www.shengsheng.net/15904033106403.html"/>
    <updated>2020-05-25T18:41:50+08:00</updated>
    <id>http://www.shengsheng.net/15904033106403.html</id>
    <content type="html"><![CDATA[
<p>记录一下workerman的ip处理,由于常驻内存的原因，workerman并不能直接获取ip和使用header等php函数。本文主要记录一下获取ip的方式。</p>

<h2 id="toc_0">官方示例代码：</h2>

<p>$_SERVER[&#39;HTTP_X_REAL_IP&#39;]方式</p>

<pre><code class="language-text">server {
  listen 443;

  ssl on;
  ssl_certificate /etc/ssl/server.pem;
  ssl_certificate_key /etc/ssl/server.key;
  ssl_session_timeout 5m;
  ssl_session_cache shared:SSL:50m;
  ssl_protocols SSLv3 SSLv2 TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;

  location /wss
  {
    proxy_pass http://127.0.0.1:8282;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;Upgrade&quot;;
    # 这部分是利用http头透传真实客户端ip
    proxy_set_header X-Real-IP $remote_addr;
  }

  # location / {} 站点的其它配置...
}


&lt;?php
require_once __DIR__ . &#39;/../Workerman/Autoloader.php&#39;;
use Workerman\Worker;
$worker = new Worker(&#39;websocket://0.0.0.0:7272&#39;);

// 客户端练上来时，即完成TCP三次握手后的回调
$worker-&gt;onConnect = function($connection) {
   /**
    * 客户端websocket握手时的回调onWebSocketConnect
    * 在onWebSocketConnect回调中获得nginx通过http头中的X_REAL_IP值
    */
   $connection-&gt;onWebSocketConnect = function($connection){
       /**
        * connection对象本没有realIP属性，这里给connection对象动态添加个realIP属性
        * 记住php对象是可以动态添加属性的，你也可以用自己喜欢的属性名
        */
       $connection-&gt;realIP = $_SERVER[&#39;HTTP_X_REAL_IP&#39;];
   };
};
$worker-&gt;onMessage = function($connection, $data)
{
    // 当使用客户端真实ip时，直接使用$connection-&gt;realIP即可
    $connection-&gt;send($connection-&gt;realIP);
};
Worker::runAll();
</code></pre>

<h2 id="toc_1">nginx配置</h2>

<pre><code class="language-text">server {
    listen 80;
    server_name example.com;
    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_read_timeout 365d;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
    }
}

</code></pre>

<p>或简单点</p>

<pre><code class="language-text">server {
        server_name test.cn;
        location / {
            proxy_pass http://127.0.0.1:8080;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &quot;upgrade&quot;;
            proxy_set_header X-Real-IP $remote_addr;
        }
}
</code></pre>

<h2 id="toc_2">header获取</h2>

<pre><code class="language-text">进入的$connection
$connection-&gt;header()-&gt;[&#39;x-real-ip&#39;];
</code></pre>

<h2 id="toc_3">getRemoteIP</h2>

<pre><code class="language-text">$worker-&gt;onConnect = function($connection)
{
    echo &quot;new connection from ip &quot; . $connection-&gt;getRemoteIp() . &quot;\n&quot;;
};
</code></pre>

<h1 id="toc_4">总结</h1>

<p>测试过\(_SERVER和getRemoteIP拿到的ip并不正常，使用\)connection-&gt;header()的方式能顺利拿到x-real-ip。查看资料后是workerman4.1和3.x的区别，4.1加强了http方面。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh公钥与私钥注意事项]]></title>
    <link href="http://www.shengsheng.net/15903327039833.html"/>
    <updated>2020-05-24T23:05:03+08:00</updated>
    <id>http://www.shengsheng.net/15903327039833.html</id>
    <content type="html"><![CDATA[
<p>公钥与私钥都是为了保障我们信息安全</p>

<h2 id="toc_0">linux下生成rsa匙</h2>

<pre><code class="language-text">ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;
</code></pre>

<p>-t  表示私钥类型<br/>
-C 表示注释，一般为自己的邮箱地址<br/>
记住生成的私钥一定要644权限，不然连接的时候会提示</p>

<pre><code class="language-text">Permissions 0644 for &#39;/Users/pengyongsheng/.ssh/yongsheng_qcloud_rsa&#39; are too open.
It is required that your private key files are NOT accessible by others.
</code></pre>

<h2 id="toc_1">目标服务器添加公钥登录</h2>

<p>将生成的公钥添加到目标服务器的~/.ssh/authorized_keys上即可使用相应的用户登录<br/>
例如~指/home/ubuntu,即可获得ubuntu权限</p>

<h2 id="toc_2">使用命令登录</h2>

<p>默认本地会读取id_rsa.pem作为私钥<br/>
sftp -oIdentityFile=私钥地址 -oPort=端口 用户名@ip<br/>
ssh <a href="mailto:root@xx.xx.xx.xx">root@xx.xx.xx.xx</a> -p 22 -i 本地私钥地址</p>

<h2 id="toc_3">软件类使用ssh</h2>

<p>软件类默认也是读取本地的id_rsa.pem,如有不同也要指定相应的即s<br/>
<img src="media/15903327039833/15903331776616.jpg" alt="" style="width:563px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php或php-fpm命令行相关参数]]></title>
    <link href="http://www.shengsheng.net/15902458128298.html"/>
    <updated>2020-05-23T22:56:52+08:00</updated>
    <id>http://www.shengsheng.net/15902458128298.html</id>
    <content type="html"><![CDATA[
<p>平时使用php多，这里记录一下php命令行下的方法说明 </p>

<pre><code class="language-text">#测试php-fpm配置
/usr/local/php/sbin/php-fpm -t
/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf -t
 
#启动php-fpm
/usr/local/php/sbin/php-fpm
/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf
 
</code></pre>

<h2 id="toc_0">官方命令解释</h2>

<pre><code class="language-text">  -a               Run as interactive shell
  -c &lt;path&gt;|&lt;file&gt; Look for php.ini file in this directory
  -n               No configuration (ini) files will be used
  -d foo[=bar]     Define INI entry foo with value &#39;bar&#39;
  -e               Generate extended information for debugger/profiler
  -f &lt;file&gt;        Parse and execute &lt;file&gt;.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r &lt;code&gt;        Run PHP &lt;code&gt; without using script tags &lt;?..?&gt;
  -B &lt;begin_code&gt;  Run PHP &lt;begin_code&gt; before processing input lines
  -R &lt;code&gt;        Run PHP &lt;code&gt; for every input line
  -F &lt;file&gt;        Parse and execute &lt;file&gt; for every input line
  -E &lt;end_code&gt;    Run PHP &lt;end_code&gt; after processing all input lines
  -H               Hide any passed arguments from external tools.
  -S &lt;addr&gt;:&lt;port&gt; Run with built-in web server.
  -t &lt;docroot&gt;     Specify document root &lt;docroot&gt; for built-in web server.
  -s               Output HTML syntax highlighted source.
  -v               Version number
  -w               Output source with stripped comments and whitespace.
  -z &lt;file&gt;        Load Zend extension &lt;file&gt;.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf &lt;name&gt;      Show information about function &lt;name&gt;.
  --rc &lt;name&gt;      Show information about class &lt;name&gt;.
  --re &lt;name&gt;      Show information about extension &lt;name&gt;.
  --rz &lt;name&gt;      Show information about Zend extension &lt;name&gt;.
  --ri &lt;name&gt;      Show configuration for extension &lt;name&gt;.
</code></pre>

<h2 id="toc_1">结语</h2>

<p>虽然比较基础，但工作了几年的phper也未必都知道！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[web常用测试]]></title>
    <link href="http://www.shengsheng.net/15901579634275.html"/>
    <updated>2020-05-22T22:32:43+08:00</updated>
    <id>http://www.shengsheng.net/15901579634275.html</id>
    <content type="html"><![CDATA[
<p>整理一下常用测试，有助于分析问题。</p>

<h1 id="toc_0">ab工具</h1>

<h2 id="toc_1">参数说明</h2>

<pre><code class="language-text">-n  //在测试会话中所执行的请求个数。默认时，仅执行一个请求
-c  //一次产生的请求个数。默认是一次一个。(如果请求的总数是1000,请求的总用户是10,那么平均每个用户执行100次请求)
-t  //测试所进行的最大秒数。其内部隐含值是-n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。
-p  //包含了需要POST的数据的文件.
-T  //POST数据所使用的Content-type头信息
-v  //设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 
-V  //显示版本号并退出。
-w  //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。
-i    //执行HEAD请求，而不是GET。
-x attributes String to insert as table attributes//
-y attributes String to insert as tr attributes//
-z attributes String to insert as td or th attributes//
-C attribute Add cookie, eg. ‘Apache=1234. (repeatable)//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复。
-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’Inserted after all normal header lines. (repeatable)
-A attribute Add Basic WWW Authentication, the attributesare a colon separated username and password.
-P attribute Add Basic Proxy Authentication, the attributesare a colon separated username and password.//-P proxy-auth-username:password 对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。
-X proxy:port Proxyserver and port number to use-V Print version number and exit-k Use HTTP KeepAlive feature
-d Do not show percentiles served table.
-S Do not show confidence estimators and warnings.
-g filename Output collected data to gnuplot format file.
-e filename Output CSV file with percentages served
-h Display usage information (this message)//-attributes 设置 属性的字符串. 缺陷程序中有各种静态声明的固定长度的缓冲区。另外，对命令行参数、服务器的响应头和其他外部输入的解析也很简单，这可能会有不良后果。它没有完整地实现 HTTP/1.x; 仅接受某些’预想’的响应格式。 strstr(3)的频繁使用可能会带来性能问题，即, 你可能是在测试ab而不是服务器的性能。
</code></pre>

<h2 id="toc_2">常用方法</h2>

<pre><code class="language-text">ab -c 100 -n 100  http://wxpush.xx.com
</code></pre>

<h2 id="toc_3">结果说明</h2>

<pre><code class="language-text">Server Software: 测试服务器的Web服务器软件名字
Server Hostname: 请求的域名
Server Port: 测试的访问端口
Document Path: 请求URL的绝问文件路径
Document Length: 表示HTTP相应的正文的长度
Concurrency Level: 标识并发的用户数(-c属性来设置)
Time taken for tests: 执行完所有的请求所花费的时间Complete requests: 表示测试的总请求数
Failed requests: 失败的请求
Total transferred: 表示所有请求的响应数据的总和,包含头信息和正文长度.
HTML transferred: 表示所有请求中响应数据的正文长度 (不包含头信息的长度)
Requests per second: 这个就是我们要的吞吐率,表示每秒处理的请求数
Time per request: 表示每个用户平均等待的时间. 等于 Time taken for tests / (Complete requests / Concurrency Level)
Time per request:(mean, across all concurrent requests) 服务器平均请求处理的时间. 正是吞详细地址的倒数，为：Time per request / Concurrency Level 每个请求花费了多少秒.
Transfer rate: 这些请求在单位内,从服务器获取的数据长度. 等于: Total transferred / Time taken for tests
Percentage of the requests served within a certain time (ms): 这部分数据用于描述每个请求处理时间的分页情况,百分之五十不超过183毫秒,. 百分之九十不超过249毫秒,百分百不超过374毫秒
</code></pre>

<h1 id="toc_4">siege工具</h1>

<h2 id="toc_5">使用方法</h2>

<pre><code class="language-text">siege -c 并发数 -t 运行测试时间 URL

如：
siege -c 1000 -t 5s URL
这里要注意的是-t后面的时间要带单位，s表示秒，如果不带，就是分钟，分钟的单位，还是挺长的，所以要注意一下。
</code></pre>

<h2 id="toc_6">结果说明</h2>

<pre><code class="language-text">
Transactions: 30000 hits //完成30000次处理

Availability: 100.00 % //100.00 % 成功率

Elapsed time: 68.59 secs //总共使用时间

Data transferred: 817.76 MB //共数据传输 817.76 MB

Response time: 0.04 secs //响应时间，显示网络连接的速度

Transaction rate: 437.38 trans/sec //平均每秒完成 437.38 次处理

Throughput: 11.92 MB/sec //平均每秒传送数据

Concurrency: 17.53 //实际最高并发连接数

Successful transactions: 30000 //成功处理次数

Failed transactions: 0 //失败处理次数

Longest transaction: 3.12 //每次传输所花最长时间

Shortest transaction: 0.00 //每次传输所花最短时间
</code></pre>

<h1 id="toc_7">webbench工具</h1>

<h2 id="toc_8">使用方法</h2>

<pre><code class="language-text">webbench -c 1000 -t 60 url
</code></pre>

<h2 id="toc_9">相关参数</h2>

<pre><code class="language-text">每秒钟响应请求数：24525 pages/min，每秒钟传输数据量20794612 bytes/sec.
并发1000运行60秒后产生的TCP连接数12000多个,已经显示有87个连接failed了，说明超负荷了。
-n总请求 -c总次数
</code></pre>

<h1 id="toc_10">jmeter</h1>

<p>相对专业的工具，有一定学习成本<br/>
需要java jdk环境。<br/>
下载之后，进入bin文件夹<br/>
<code><br/>
sh jmeter<br/>
</code><br/>
即打开工具</p>

<h1 id="toc_11">使用chome开发者工具</h1>

<p>使用开发者工具<br/>
<img src="media/15901579634275/15901588688692.jpg" alt="" style="width:1383px;"/></p>

<p>查看网络timing的waiting等参数，即可判断网络顺畅度。</p>

<h1 id="toc_12">使用第三方监测工具</h1>

<p>例如监控宝等，查看全国各地的联通情况。</p>

<h1 id="toc_13">常见问题</h1>

<p><code><br/>
ab socket: Too many open files (24)<br/>
[error] Host not found: xx.cn<br/>
[error] descriptor table full sock.c:133: Too many open files<br/>
</code><br/>
使用测试工具的机器或远程服务器，都需要加大进程使用数<br/>
即mac本地也要ulimit -n 一下，不然是并发测试不了的</p>

<h3 id="toc_14">可查看当前限制数</h3>

<p><code><br/>
ulimit -a <br/>
ulimit -n<br/>
</code><br/>
设置数<br/>
<code><br/>
ulimit -n 65535 <br/>
</code></p>

<h3 id="toc_15">个性/etc/sysctl.conf</h3>

<pre><code class="language-text">#该参数设置系统的TIME_WAIT的数量，如果超过默认值则会被立即清除
net.ipv4.tcp_max_tw_buckets = 20000
#定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数
net.core.somaxconn = 65535
#对于还未获得对方确认的连接请求，可保存在队列中的最大数目
net.ipv4.tcp_max_syn_backlog = 262144
#在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目
net.core.netdev_max_backlog = 30000
#能够更快地回收TIME-WAIT套接字。此选项会导致处于NAT网络的客户端超时，建议为0
net.ipv4.tcp_tw_recycle = 0
#系统所有进程一共可以打开的文件数量
fs.file-max = 6815744
#防火墙跟踪表的大小。注意：如果防火墙没开则会提示error: &quot;net.netfilter.nf_conntrack_max&quot; is an unknown key，忽略即可
net.netfilter.nf_conntrack_max = 2621440
</code></pre>

<p>sysctl -p即可生效。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CI/CD构建利器 Jenkins]]></title>
    <link href="http://www.shengsheng.net/15899883082622.html"/>
    <updated>2020-05-20T23:25:08+08:00</updated>
    <id>http://www.shengsheng.net/15899883082622.html</id>
    <content type="html"><![CDATA[
<p>传统的ftp上传，或通过svn hook提交，显得效率太慢，而且不太靠谱。<br/>
之前写了个gitlab 发布脚本。</p>

<pre><code class="language-text">echo &#39;pull project:&#39;$1
gitBasePath=&#39;/show/gitBase/&#39;
cd $gitBasePath$1
git pull

message=$(git log --pretty=format:&quot;%s&quot; -1)
isRedeploy=false
#检测到RELEASE，即发布项目
[[ $message =~ &quot;[RELEASE]&quot; ]] &amp;&amp; isRedeploy=true
echo &quot;是否可发布版本：&quot;$isRedeploy;

#一定要传git项目名
if [[ $isRedeploy = true &amp;&amp; $1 ]]
then
    #判断$2, 有可能$1 与实际环境名不一样
    if [[ -n $2 ]];then
        webAppPath=$2
    else
        webAppPath=&#39;/webwww/www/&#39;$1&#39;/&#39;
    fi
    #git 基础路径保持不变
    gitBasePath=&#39;/show/gitBase/&#39;$1&#39;/&#39;
    echo &quot;git:&quot;.$gitBasePath;
    echo &quot;web:&quot;.$webAppPath;
    cp -r -f -v $gitBasePath* $webAppPath
    echo &quot;success&quot;;
else
    echo &quot;fail&quot;;
fi;
</code></pre>

<p>通过提交检测到[RELEASE]关键词即提交。</p>

<p>但未免还是会发生构建没记录，没权限的事情。故研究玩一下jenkins</p>

<h1 id="toc_0">安装</h1>

<p>使用docker顺带搭建出来<br/>
<code><br/>
docker run -it -d -u root -p 8090:8080 -v jenkins-data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v &quot;$HOME&quot;:/home --name jenkins -v /webwww:/webwww jenkinsci/blueocean<br/>
</code><br/>
<img src="media/15899883082622/15899886195287.jpg" alt=""/></p>

<p>需安装以下扩展<br/>
Gitlab Hook、Build Authorization Token Root、Publish Over SSH、Gitlab Authentication、Gitlab、Git Parameter</p>

<p><img src="media/15899883082622/15899887426504.jpg" alt=""/></p>

<p>通过Publicsh over SSH我们创建与系统相关的通讯key</p>

<h1 id="toc_1">构建项目</h1>

<p><img src="media/15899883082622/15899887889342.jpg" alt=""/></p>

<p><img src="media/15899883082622/15899888131244.jpg" alt=""/></p>

<p><img src="media/15899883082622/15899888451155.jpg" alt=""/></p>

<p>输入需要获取的gitlab地址，需先配置通讯key</p>

<p><img src="media/15899883082622/15899888947470.jpg" alt=""/></p>

<p>构建选择send files去指定服务器<br/>
<img src="media/15899883082622/15899890185872.jpg" alt=""/></p>

<p><img src="media/15899883082622/15899890745327.jpg" alt=""/></p>

<p>每次更新好项目，按一下构建即马上发布代码到线上。当然也可以同步到测试机。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php之JsonSerializable]]></title>
    <link href="http://www.shengsheng.net/15887625331484.html"/>
    <updated>2020-05-06T18:55:33+08:00</updated>
    <id>http://www.shengsheng.net/15887625331484.html</id>
    <content type="html"><![CDATA[
<p>有时候我们的类是一个Model,但为了快速输出序列化格式，例如json,我们可以使用jsonSerialize</p>

<p><img src="media/15887625331484/15887626368131.jpg" alt=""/></p>

<p>class implements 一下JsonSerializable接口，每次json_encode就会把类内的jsonSerialize函数里返回的数据进行json格式化。</p>

<h1 id="toc_0">类似的接口</h1>

<p>其它更有趣的处理接口如下<br/>
<a href="https://www.php.net/manual/en/reserved.interfaces.php">https://www.php.net/manual/en/reserved.interfaces.php</a></p>

<ol>
<li>Traversable</li>
<li>Iterator</li>
<li>IteratorAggregate</li>
<li>Throwable</li>
<li>ArrayAccess</li>
<li>Serializable</li>
<li>Closure</li>
<li>Generator</li>
<li>WeakReference</li>
</ol>

]]></content>
  </entry>
  
</feed>
