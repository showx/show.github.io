<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[shengsheng的博客]]></title>
  <link href="http://www.shengsheng.net/atom.xml" rel="self"/>
  <link href="http://www.shengsheng.net/"/>
  <updated>2020-05-22T22:50:38+08:00</updated>
  <id>http://www.shengsheng.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[php或php-fpm命令行相关参数]]></title>
    <link href="http://www.shengsheng.net/15902458128298.html"/>
    <updated>2020-05-23T22:56:52+08:00</updated>
    <id>http://www.shengsheng.net/15902458128298.html</id>
    <content type="html"><![CDATA[
<p>平时使用php多，这里记录一下php命令行下的方法说明 </p>

<pre><code class="language-text">#测试php-fpm配置
/usr/local/php/sbin/php-fpm -t
/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf -t
 
#启动php-fpm
/usr/local/php/sbin/php-fpm
/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf
 
</code></pre>

<h2 id="toc_0">官方命令解释</h2>

<pre><code class="language-text">  -a               Run as interactive shell
  -c &lt;path&gt;|&lt;file&gt; Look for php.ini file in this directory
  -n               No configuration (ini) files will be used
  -d foo[=bar]     Define INI entry foo with value &#39;bar&#39;
  -e               Generate extended information for debugger/profiler
  -f &lt;file&gt;        Parse and execute &lt;file&gt;.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r &lt;code&gt;        Run PHP &lt;code&gt; without using script tags &lt;?..?&gt;
  -B &lt;begin_code&gt;  Run PHP &lt;begin_code&gt; before processing input lines
  -R &lt;code&gt;        Run PHP &lt;code&gt; for every input line
  -F &lt;file&gt;        Parse and execute &lt;file&gt; for every input line
  -E &lt;end_code&gt;    Run PHP &lt;end_code&gt; after processing all input lines
  -H               Hide any passed arguments from external tools.
  -S &lt;addr&gt;:&lt;port&gt; Run with built-in web server.
  -t &lt;docroot&gt;     Specify document root &lt;docroot&gt; for built-in web server.
  -s               Output HTML syntax highlighted source.
  -v               Version number
  -w               Output source with stripped comments and whitespace.
  -z &lt;file&gt;        Load Zend extension &lt;file&gt;.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf &lt;name&gt;      Show information about function &lt;name&gt;.
  --rc &lt;name&gt;      Show information about class &lt;name&gt;.
  --re &lt;name&gt;      Show information about extension &lt;name&gt;.
  --rz &lt;name&gt;      Show information about Zend extension &lt;name&gt;.
  --ri &lt;name&gt;      Show configuration for extension &lt;name&gt;.
</code></pre>

<h2 id="toc_1">结语</h2>

<p>虽然比较基础，但工作了几年的phper也未必都知道！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[web常用测试]]></title>
    <link href="http://www.shengsheng.net/15901579634275.html"/>
    <updated>2020-05-22T22:32:43+08:00</updated>
    <id>http://www.shengsheng.net/15901579634275.html</id>
    <content type="html"><![CDATA[
<p>整理一下常用测试，有助于分析问题。</p>

<h1 id="toc_0">ab工具</h1>

<h2 id="toc_1">参数说明</h2>

<pre><code class="language-text">-n  //在测试会话中所执行的请求个数。默认时，仅执行一个请求
-c  //一次产生的请求个数。默认是一次一个。(如果请求的总数是1000,请求的总用户是10,那么平均每个用户执行100次请求)
-t  //测试所进行的最大秒数。其内部隐含值是-n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。
-p  //包含了需要POST的数据的文件.
-T  //POST数据所使用的Content-type头信息
-v  //设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 
-V  //显示版本号并退出。
-w  //以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。
-i    //执行HEAD请求，而不是GET。
-x attributes String to insert as table attributes//
-y attributes String to insert as tr attributes//
-z attributes String to insert as td or th attributes//
-C attribute Add cookie, eg. ‘Apache=1234. (repeatable)//-C cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复。
-H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’Inserted after all normal header lines. (repeatable)
-A attribute Add Basic WWW Authentication, the attributesare a colon separated username and password.
-P attribute Add Basic Proxy Authentication, the attributesare a colon separated username and password.//-P proxy-auth-username:password 对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。
-X proxy:port Proxyserver and port number to use-V Print version number and exit-k Use HTTP KeepAlive feature
-d Do not show percentiles served table.
-S Do not show confidence estimators and warnings.
-g filename Output collected data to gnuplot format file.
-e filename Output CSV file with percentages served
-h Display usage information (this message)//-attributes 设置 属性的字符串. 缺陷程序中有各种静态声明的固定长度的缓冲区。另外，对命令行参数、服务器的响应头和其他外部输入的解析也很简单，这可能会有不良后果。它没有完整地实现 HTTP/1.x; 仅接受某些’预想’的响应格式。 strstr(3)的频繁使用可能会带来性能问题，即, 你可能是在测试ab而不是服务器的性能。
</code></pre>

<h2 id="toc_2">常用方法</h2>

<pre><code class="language-text">ab -c 100 -n 100  http://wxpush.xx.com
</code></pre>

<h2 id="toc_3">结果说明</h2>

<pre><code class="language-text">Server Software: 测试服务器的Web服务器软件名字
Server Hostname: 请求的域名
Server Port: 测试的访问端口
Document Path: 请求URL的绝问文件路径
Document Length: 表示HTTP相应的正文的长度
Concurrency Level: 标识并发的用户数(-c属性来设置)
Time taken for tests: 执行完所有的请求所花费的时间Complete requests: 表示测试的总请求数
Failed requests: 失败的请求
Total transferred: 表示所有请求的响应数据的总和,包含头信息和正文长度.
HTML transferred: 表示所有请求中响应数据的正文长度 (不包含头信息的长度)
Requests per second: 这个就是我们要的吞吐率,表示每秒处理的请求数
Time per request: 表示每个用户平均等待的时间. 等于 Time taken for tests / (Complete requests / Concurrency Level)
Time per request:(mean, across all concurrent requests) 服务器平均请求处理的时间. 正是吞详细地址的倒数，为：Time per request / Concurrency Level 每个请求花费了多少秒.
Transfer rate: 这些请求在单位内,从服务器获取的数据长度. 等于: Total transferred / Time taken for tests
Percentage of the requests served within a certain time (ms): 这部分数据用于描述每个请求处理时间的分页情况,百分之五十不超过183毫秒,. 百分之九十不超过249毫秒,百分百不超过374毫秒
</code></pre>

<h1 id="toc_4">siege工具</h1>

<h2 id="toc_5">使用方法</h2>

<pre><code class="language-text">siege -c 并发数 -t 运行测试时间 URL

如：
siege -c 1000 -t 5s URL
这里要注意的是-t后面的时间要带单位，s表示秒，如果不带，就是分钟，分钟的单位，还是挺长的，所以要注意一下。
</code></pre>

<h2 id="toc_6">结果说明</h2>

<pre><code class="language-text">
Transactions: 30000 hits //完成30000次处理

Availability: 100.00 % //100.00 % 成功率

Elapsed time: 68.59 secs //总共使用时间

Data transferred: 817.76 MB //共数据传输 817.76 MB

Response time: 0.04 secs //响应时间，显示网络连接的速度

Transaction rate: 437.38 trans/sec //平均每秒完成 437.38 次处理

Throughput: 11.92 MB/sec //平均每秒传送数据

Concurrency: 17.53 //实际最高并发连接数

Successful transactions: 30000 //成功处理次数

Failed transactions: 0 //失败处理次数

Longest transaction: 3.12 //每次传输所花最长时间

Shortest transaction: 0.00 //每次传输所花最短时间
</code></pre>

<h1 id="toc_7">webbench工具</h1>

<h2 id="toc_8">使用方法</h2>

<pre><code class="language-text">webbench -c 1000 -t 60 url
</code></pre>

<h2 id="toc_9">相关参数</h2>

<pre><code class="language-text">每秒钟响应请求数：24525 pages/min，每秒钟传输数据量20794612 bytes/sec.
并发1000运行60秒后产生的TCP连接数12000多个,已经显示有87个连接failed了，说明超负荷了。
-n总请求 -c总次数
</code></pre>

<h1 id="toc_10">jmeter</h1>

<p>相对专业的工具，有一定学习成本<br/>
需要java jdk环境。<br/>
下载之后，进入bin文件夹<br/>
<code><br/>
sh jmeter<br/>
</code><br/>
即打开工具</p>

<h1 id="toc_11">使用chome开发者工具</h1>

<p>使用开发者工具<br/>
<img src="media/15901579634275/15901588688692.jpg" alt="" style="width:1383px;"/></p>

<p>查看网络timing的waiting等参数，即可判断网络顺畅度。</p>

<h1 id="toc_12">使用第三方监测工具</h1>

<p>例如监控宝等，查看全国各地的联通情况。</p>

<h1 id="toc_13">常见问题</h1>

<p><code><br/>
ab socket: Too many open files (24)<br/>
[error] Host not found: xx.cn<br/>
[error] descriptor table full sock.c:133: Too many open files<br/>
</code><br/>
使用测试工具的机器或远程服务器，都需要加大进程使用数<br/>
即mac本地也要ulimit -n 一下，不然是并发测试不了的</p>

<h3 id="toc_14">可查看当前限制数</h3>

<p><code><br/>
ulimit -a <br/>
ulimit -n<br/>
</code><br/>
设置数<br/>
<code><br/>
ulimit -n 65535 <br/>
</code></p>

<h3 id="toc_15">个性/etc/sysctl.conf</h3>

<pre><code class="language-text">#该参数设置系统的TIME_WAIT的数量，如果超过默认值则会被立即清除
net.ipv4.tcp_max_tw_buckets = 20000
#定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数
net.core.somaxconn = 65535
#对于还未获得对方确认的连接请求，可保存在队列中的最大数目
net.ipv4.tcp_max_syn_backlog = 262144
#在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目
net.core.netdev_max_backlog = 30000
#能够更快地回收TIME-WAIT套接字。此选项会导致处于NAT网络的客户端超时，建议为0
net.ipv4.tcp_tw_recycle = 0
#系统所有进程一共可以打开的文件数量
fs.file-max = 6815744
#防火墙跟踪表的大小。注意：如果防火墙没开则会提示error: &quot;net.netfilter.nf_conntrack_max&quot; is an unknown key，忽略即可
net.netfilter.nf_conntrack_max = 2621440
</code></pre>

<p>sysctl -p即可生效。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CI/CD构建利器 Jenkins]]></title>
    <link href="http://www.shengsheng.net/15899883082622.html"/>
    <updated>2020-05-20T23:25:08+08:00</updated>
    <id>http://www.shengsheng.net/15899883082622.html</id>
    <content type="html"><![CDATA[
<p>传统的ftp上传，或通过svn hook提交，显得效率太慢，而且不太靠谱。<br/>
之前写了个gitlab 发布脚本。</p>

<pre><code class="language-text">echo &#39;pull project:&#39;$1
gitBasePath=&#39;/show/gitBase/&#39;
cd $gitBasePath$1
git pull

message=$(git log --pretty=format:&quot;%s&quot; -1)
isRedeploy=false
#检测到RELEASE，即发布项目
[[ $message =~ &quot;[RELEASE]&quot; ]] &amp;&amp; isRedeploy=true
echo &quot;是否可发布版本：&quot;$isRedeploy;

#一定要传git项目名
if [[ $isRedeploy = true &amp;&amp; $1 ]]
then
    #判断$2, 有可能$1 与实际环境名不一样
    if [[ -n $2 ]];then
        webAppPath=$2
    else
        webAppPath=&#39;/webwww/www/&#39;$1&#39;/&#39;
    fi
    #git 基础路径保持不变
    gitBasePath=&#39;/show/gitBase/&#39;$1&#39;/&#39;
    echo &quot;git:&quot;.$gitBasePath;
    echo &quot;web:&quot;.$webAppPath;
    cp -r -f -v $gitBasePath* $webAppPath
    echo &quot;success&quot;;
else
    echo &quot;fail&quot;;
fi;
</code></pre>

<p>通过提交检测到[RELEASE]关键词即提交。</p>

<p>但未免还是会发生构建没记录，没权限的事情。故研究玩一下jenkins</p>

<h1 id="toc_0">安装</h1>

<p>使用docker顺带搭建出来<br/>
<code><br/>
docker run -it -d -u root -p 8090:8080 -v jenkins-data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v &quot;$HOME&quot;:/home --name jenkins -v /webwww:/webwww jenkinsci/blueocean<br/>
</code><br/>
<img src="media/15899883082622/15899886195287.jpg" alt=""/></p>

<p>需安装以下扩展<br/>
Gitlab Hook、Build Authorization Token Root、Publish Over SSH、Gitlab Authentication、Gitlab、Git Parameter</p>

<p><img src="media/15899883082622/15899887426504.jpg" alt=""/></p>

<p>通过Publicsh over SSH我们创建与系统相关的通讯key</p>

<h1 id="toc_1">构建项目</h1>

<p><img src="media/15899883082622/15899887889342.jpg" alt=""/></p>

<p><img src="media/15899883082622/15899888131244.jpg" alt=""/></p>

<p><img src="media/15899883082622/15899888451155.jpg" alt=""/></p>

<p>输入需要获取的gitlab地址，需先配置通讯key</p>

<p><img src="media/15899883082622/15899888947470.jpg" alt=""/></p>

<p>构建选择send files去指定服务器<br/>
<img src="media/15899883082622/15899890185872.jpg" alt=""/></p>

<p><img src="media/15899883082622/15899890745327.jpg" alt=""/></p>

<p>每次更新好项目，按一下构建即马上发布代码到线上。当然也可以同步到测试机。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php之JsonSerializable]]></title>
    <link href="http://www.shengsheng.net/15887625331484.html"/>
    <updated>2020-05-06T18:55:33+08:00</updated>
    <id>http://www.shengsheng.net/15887625331484.html</id>
    <content type="html"><![CDATA[
<p>有时候我们的类是一个Model,但为了快速输出序列化格式，例如json,我们可以使用jsonSerialize</p>

<p><img src="media/15887625331484/15887626368131.jpg" alt=""/></p>

<p>class implements 一下JsonSerializable接口，每次json_encode就会把类内的jsonSerialize函数里返回的数据进行json格式化。</p>

<h1 id="toc_0">类似的接口</h1>

<p>其它更有趣的处理接口如下<br/>
<a href="https://www.php.net/manual/en/reserved.interfaces.php">https://www.php.net/manual/en/reserved.interfaces.php</a></p>

<ol>
<li>Traversable</li>
<li>Iterator</li>
<li>IteratorAggregate</li>
<li>Throwable</li>
<li>ArrayAccess</li>
<li>Serializable</li>
<li>Closure</li>
<li>Generator</li>
<li>WeakReference</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux权限和组]]></title>
    <link href="http://www.shengsheng.net/15887614689176.html"/>
    <updated>2020-05-06T18:37:48+08:00</updated>
    <id>http://www.shengsheng.net/15887614689176.html</id>
    <content type="html"><![CDATA[
<p>最近都是想写写linux基础为主</p>

<h1 id="toc_0">group</h1>

<p>/etc/group<br/>
我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。</p>

<h1 id="toc_1">用户</h1>

<p>/etc/passwd<br/>
用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</p>

<h1 id="toc_2">权限命令</h1>

<p>chown 修改文件或文件夹的归属用户和归属组 <br/>
chmod 修改权限属性</p>

<h1 id="toc_3">权限组成</h1>

<p><img src="media/15887614689176/15887617349056.jpg" alt=""/></p>

<p>前在的d代表文件夹的意思<br/>
r 代表读取 read<br/>
w 写  write<br/>
x 执行 execute</p>

<p>一共有三段 <br/>
即<br/>
用户|组|其它</p>

<p>这里可以看出jar文件夹的用户是pengyongsheng,组是staff<br/>
pengyongsheng对应的权限是读写执行<br/>
staff对应的权限只有读和执行<br/>
其它的用户只有执行的权限</p>

<p>r=4，w=2，x=1<br/>
想修改jar的组权限为可写，即该组下的用户都有写的功能<br/>
4+2+1=7<br/>
所以我们修改成<br/>
<code><br/>
chmod jar 771<br/>
</code></p>

<h1 id="toc_4">其它</h1>

<p>root是终极用户，可以理解为super用户</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux 3.根据指标找工具]]></title>
    <link href="http://www.shengsheng.net/15886892533426.html"/>
    <updated>2020-05-05T22:34:13+08:00</updated>
    <id>http://www.shengsheng.net/15886892533426.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">根据指标找工具（cpu性能）</h1>

<table>
<thead>
<tr>
<th>性能指标</th>
<th>性能工具</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>平均负载</td>
<td>Uptime top</td>
<td>uptime最简单；top提供了更全的指标</td>
</tr>
<tr>
<td>系统整体CPU使用率</td>
<td>vmstat mpstat top sar /proc/stat</td>
<td>top vmstat mpstat只可以动态查看，而sar还可以记录历史数据 /proc/stat是其它性能工具的数据来源</td>
</tr>
<tr>
<td>进程CPU使用率</td>
<td>top pidstat ps htop atop</td>
<td>top和ps可以按CPU使用给进程排序，而pidstat只显示实际用了CPU的进程，htop和atop以不同颜色显示更直观</td>
</tr>
<tr>
<td>系统上下文切换</td>
<td>vmstat</td>
<td>除了上下文切换次数，还提供运行状态和不可中断状态进程的数量</td>
</tr>
<tr>
<td>进程上下文切换</td>
<td>pidstat</td>
<td>注意加上-w选项</td>
</tr>
<tr>
<td>软中断</td>
<td>top /proc/softrqs mpstat</td>
<td>top提供软中断CPU使用率，而/proc/softirqs和mpstat提供各种中断在每个CPU上运行的累积次数</td>
</tr>
<tr>
<td>硬中断</td>
<td>vmstat /proc/interrupts</td>
<td>vmstat提供总的中断次数，而/proc/interrupts提供各种中断在每个CPU上运行的累积次数</td>
</tr>
<tr>
<td>网络</td>
<td>Dstat sar tcpdump</td>
<td>dstat和sar提供总的网络接收和发送情况，而tcpdump则是动态抓取正在进行的网络通讯</td>
</tr>
<tr>
<td>I/O</td>
<td>Dstat sar</td>
<td>dstat和sar都提供了I/O的整体情况</td>
</tr>
<tr>
<td>CPU个数</td>
<td>/proc/cpuinfo lscpu</td>
<td>lscpu更直观</td>
</tr>
<tr>
<td>事件剖析</td>
<td>Perf execsnoop</td>
<td>perf可以用来分析CPU的缓存以及内核调用链，execsnoop用来监控短时进程</td>
</tr>
</tbody>
</table>

<h1 id="toc_1">根据指标找工具（文件系统和磁盘I/O）</h1>

<table>
<thead>
<tr>
<th>性能指标</th>
<th>性能工具</th>
<th>说明</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>文件系统空间容量、使用量以及剩余空间</td>
<td>df</td>
<td>Info coreutils’df invocation&#39;</td>
<td></td>
</tr>
<tr>
<td>索引节点容量、使用量以及剩余量</td>
<td>df</td>
<td>使用-i选项</td>
<td></td>
</tr>
<tr>
<td>页缓存和可回收Slab缓存</td>
<td>/proc/meminfo sar vmstat</td>
<td>使用sar -r选项</td>
<td></td>
</tr>
<tr>
<td>缓冲区</td>
<td>/proc/meminfo sar vmstat</td>
<td>Sar -r</td>
<td></td>
</tr>
<tr>
<td>目录项、索引节点以及文件系统的缓存</td>
<td>/proc/slabinfo slabtop</td>
<td>slabtop</td>
<td></td>
</tr>
<tr>
<td>磁盘I/O使用率，IOPS，吞吐量，响应时间，I/O平均大小以及等待队列长度</td>
<td>iostat sar dstat</td>
<td>使用iostat -d -x 或 sar -d</td>
<td></td>
</tr>
<tr>
<td>进程I/O大小以及I/O延迟</td>
<td>pidstat iotop</td>
<td>使用pidstat -d</td>
<td></td>
</tr>
<tr>
<td>块设备I/O事件跟踪</td>
<td>blktrace</td>
<td>blktrace -d /dev/ sda -o       blkparse -i</td>
<td></td>
</tr>
<tr>
<td>进程I/O系统调用跟踪</td>
<td>strace</td>
<td>strace</td>
<td></td>
</tr>
<tr>
<td>进程块设备I/O大小跟踪</td>
<td>biosnoop biotop</td>
<td>需要安装bcc软件包</td>
<td></td>
</tr>
</tbody>
</table>

<h1 id="toc_2">根据指标找工具（内存性能）</h1>

<table>
<thead>
<tr>
<th>性能指标</th>
<th>性能工具</th>
</tr>
</thead>

<tbody>
<tr>
<td>系统已用、可用、剩余内存</td>
<td>free vmstat sar /proc/meminfo</td>
</tr>
<tr>
<td>进程虚拟内存、常驻内存、共享内存</td>
<td>ps top</td>
</tr>
<tr>
<td>进程内存分布</td>
<td>pmap</td>
</tr>
<tr>
<td>进程swap换出内存</td>
<td>top /roc/pid/status</td>
</tr>
<tr>
<td>进程缺页异常</td>
<td>ps top</td>
</tr>
<tr>
<td>系统换页情况</td>
<td>sar</td>
</tr>
<tr>
<td>缓存 / 缓冲区用量</td>
<td>free vmstat sar cachestat</td>
</tr>
<tr>
<td>缓存 / 缓冲区命中率</td>
<td>cachetop</td>
</tr>
<tr>
<td>SWAP已用空间和剩余空间</td>
<td>free sar</td>
</tr>
<tr>
<td>swap换入换出</td>
<td>vmstat</td>
</tr>
<tr>
<td>内存泄漏检测</td>
<td>memleak valgrind</td>
</tr>
<tr>
<td>指定文件的缓存大小</td>
<td>pcstat</td>
</tr>
</tbody>
</table>

<h1 id="toc_3">根据指标找工具（网络性能）</h1>

<table>
<thead>
<tr>
<th>性能指标</th>
<th>性能工具</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>吞吐量（BPS）</td>
<td>sar nethogs iftop</td>
<td>分别可以查看网络接口 进程以及IP地址的网络吴吐量</td>
</tr>
<tr>
<td>PPS</td>
<td>sar /proc/net/dev</td>
<td>查看网络接口的PPS</td>
</tr>
<tr>
<td>连接数</td>
<td>netstat ss</td>
<td>查看网络连接数</td>
</tr>
<tr>
<td>延迟</td>
<td>ping hping3</td>
<td>通过ICMP TCP等测试网络延迟</td>
</tr>
<tr>
<td>连接跟踪数</td>
<td>conntrack</td>
<td>查看和管理连接跟踪状况</td>
</tr>
<tr>
<td>路由</td>
<td>mtr route traceroute</td>
<td>查看路由并测试链路信息</td>
</tr>
<tr>
<td>DNS</td>
<td>dig nslookup</td>
<td>查看路由并测试链路信息</td>
</tr>
<tr>
<td>防火墙和NAT</td>
<td>iptables</td>
<td>配置和管理防火墙及NAT规则</td>
</tr>
<tr>
<td>网卡功能</td>
<td>ethtool</td>
<td>查看和配置网络接口的功能</td>
</tr>
<tr>
<td>抓包</td>
<td>tcpdump wireshark</td>
<td>分析</td>
</tr>
<tr>
<td>内核协议栈跟踪</td>
<td>bcc systemtap</td>
<td>动态跟踪内核协议栈的行为</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[加大效率的快捷键]]></title>
    <link href="http://www.shengsheng.net/15886055945928.html"/>
    <updated>2020-05-04T23:19:54+08:00</updated>
    <id>http://www.shengsheng.net/15886055945928.html</id>
    <content type="html"><![CDATA[
<p>偶尔用到某些功能的时候，忘记快捷键是多少了，故本篇主要记录一下常用快捷键</p>

<h2 id="toc_0">iterm2</h2>

<pre><code class="language-text">command + t：新建窗口

command + d：垂直分屏，

command + shift + d：水平分屏。

command + ] 和command + [ 在最近使用的分屏直接切换.

command + alt + 方向键：切换到指定位置的分屏。

command + 数字：切换标签页。

command + 方向键：按方向切换标签页。

shift + command + s：保存当前窗口快照。

command + alt + b：快照回放。很有意思的功能，你可以对你的操作根据时间轴进行回放。可以拖动下方的时间轴，也可以按左右方向s
</code></pre>

<h2 id="toc_1">visual studio code</h2>

<pre><code class="language-text">单行注释：[ctrl+k,ctrl+c] 或 ctrl+/

移动行：alt+up/down

显示/隐藏左侧目录栏 ctrl + b

复制当前行：shift + alt +up/down

删除当前行：shift + ctrl + k

控制台终端显示与隐藏：ctrl + ~

查找文件/安装vs code 插件地址：ctrl + p

代码格式化：shift + alt +f

新建一个窗口 : ctrl + shift + n

行增加缩进: ctrl + [

行减少缩进: ctrl + ]

裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x

字体放大/缩小: ctrl + ( + 或 - )

拆分编辑器 : ctrl + 1/2/3

切换窗口 : ctrl + shift + left/right

关闭编辑器窗口 : ctrl + w

关闭所有窗口 : ctrl + k + w

切换全屏 : F11

自动换行 : alt + z

显示git : ctrl + shift + g

全局查找文件：ctrl + shift + f

显示相关插件的命令(如：git log)：ctrl + shift + p

选中文字：shift + left / right / up / down

折叠代码： ctrl + k + 0-9 (0是完全折叠)

展开代码： ctrl + k + j (完全展开代码)

删除行 ： ctrl + shift + k

快速切换主题：ctrl + k / ctrl + t

快速回到顶部 ： ctrl + home

快速回到底部 : ctrl + end

格式化选定代码 ：ctrl + k / ctrl +f

选中代码 ： shift + 鼠标左键

多行同时添加内容（光标） ：ctrl + alt + up/down

全局替换：ctrl + shift + h

当前文件替换：ctrl + h

打开最近打开的文件：ctrl + r

打开新的命令窗：ctrl + shift + c
</code></pre>

<h1 id="toc_2">后记</h1>

<p>陆续会更新常用工具的快捷键</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php自定义异常类]]></title>
    <link href="http://www.shengsheng.net/15882435726461.html"/>
    <updated>2020-04-30T18:46:12+08:00</updated>
    <id>http://www.shengsheng.net/15882435726461.html</id>
    <content type="html"><![CDATA[
<p>工作中会经常用到异常的调试<br/>
所以会用到异常类</p>

<pre><code class="language-text">&lt;?php
Exception implements Throwable {
/* Properties */
protected string $message ;
protected int $code ;
protected string $file ;
protected int $line ;
/* Methods */
public __construct ([ string $message = &quot;&quot; [, int $code = 0 [, Throwable $previous = NULL ]]] )
final public getMessage ( void ) : string
final public getPrevious ( void ) : Throwable
final public getCode ( void ) : mixed
final public getFile ( void ) : string
final public getLine ( void ) : int
final public getTrace ( void ) : array
final public getTraceAsString ( void ) : string
public __toString ( void ) : string
final private __clone ( void ) : void
}
</code></pre>

<p>结合实际我们会自定义一些异常类来处理特定的事情</p>

<h1 id="toc_0">自定义异常类的编写</h1>

<pre><code class="language-text">Class dbException extends \Exception
{
    private $errorCode;
    private $sql;

    /**
     * 初始化异常
     */
    public function __construct($code = &quot;&quot;, $message = &quot;&quot;,  $sql = &quot;&quot;)
    {
        parent::__construct($message, 0);
        $this-&gt;errorCode = $code;
        $this-&gt;sql = $sql;
    }

    /**
     *  获取错误码
     */
    public function getErrorCode()
    {
        return $this-&gt;errorCode;
    }

    /**
     * 获取错误的sql语句
     */
    public function getSql():string
    {
        return $this-&gt;sql;
    }
    
    /**
     * 格式化输出异常码，异常信息，请求id
     * @return string
     */
    public function __toString()
    {
        return &quot;[&quot;.__CLASS__.&quot;]&quot;.&quot; code:&quot;.$this-&gt;errorCode.
            &quot; message:&quot;.$this-&gt;getMessage().
            &quot; sql:&quot;.$this-&gt;sql;
    }

}
</code></pre>

<p><img src="media/15882435726461/15882443213130.jpg" alt=""/></p>

<p>我们简单测试一下自定义的异常类</p>

<p><img src="media/15882435726461/15882441893437.jpg" alt=""/></p>

<p><img src="media/15882435726461/15882442464889.jpg" alt=""/></p>

<p>运行一下我们只走到了Exception,但我们不是没结果的时候拋出dbException么？<br/>
其实是没走到throw new dbException，语句已经有错，直接底层拋出Exception</p>

<p>改写一下函数<br/>
<img src="media/15882435726461/15882443985466.jpg" alt=""/></p>

<p>这样就捕获到异常了<br/>
<img src="media/15882435726461/15882444468903.jpg" alt=""/></p>

<h1 id="toc_1">结论</h1>

<p>提高效率，写好异常类是很有必要的！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android常用工具]]></title>
    <link href="http://www.shengsheng.net/15881725421998.html"/>
    <updated>2020-04-29T23:02:22+08:00</updated>
    <id>http://www.shengsheng.net/15881725421998.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">反编译与打包</h2>

<h3 id="toc_1">打包</h3>

<pre><code class="language-text">apktool b /Users/pengyongsheng/Downloads/UF -o /Users/pengyongsheng/Downloads/UF.apk
apktool b {$dapk_path} -o {$apk}.apk
</code></pre>

<p>没-o参数输出在dist文件夹</p>

<h3 id="toc_2">反编译</h3>

<pre><code class="language-text">apktool d /Users/pengyongsheng/Downloads/hjjd.apk -o /Users/pengyongsheng/Downloads/hjjd/hjjd
</code></pre>

<h2 id="toc_3">签名</h2>

<h3 id="toc_4">方式1</h3>

<p>使用pem,pk8文件进行签名</p>

<pre><code class="language-text">java -jar signapk.jar test.pem test.pk8 a.apk a_sign.apk
</code></pre>

<h3 id="toc_5">方式2</h3>

<p>使用keystore</p>

<pre><code class="language-text">jarsigner -verbose -keystore /code/android/package/test.keystore -signedjar /code/android/package/500_sign.apk /code/android/package/500.apk  test.keystore
</code></pre>

<h2 id="toc_6">查看包名</h2>

<ol>
<li><p>adb shell am monitor -&gt; 打开应用</p></li>
<li><p>安装了的包名<br/>
adb shell pm list packages -3</p></li>
<li><p>将apk包反编译后，打开AndroidManifest.xml，搜索package获取包名</p></li>
<li><p>安卓系统中：设置——应用——正在运行 查看</p></li>
</ol>

<h2 id="toc_7">查看签名</h2>

<pre><code class="language-text">keytool -printcert -jarfile xxx.apk
jarsigner -verify /code/android/package/5yyb/dist/5yyb.apk
</code></pre>

<h2 id="toc_8">adb logcat</h2>

<p>通过过滤包名+过滤进程ID</p>

<pre><code class="language-text">Linux or Mac:
adb logcat | grep -F &quot;`adb shell ps | grep com.abc.package | cut -c10-15`&quot;
windows:
adb logcat | findstr com.abc.package
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[超高性能的php框架之phpshow]]></title>
    <link href="http://www.shengsheng.net/15880420318169.html"/>
    <updated>2020-04-28T10:47:11+08:00</updated>
    <id>http://www.shengsheng.net/15880420318169.html</id>
    <content type="html"><![CDATA[
<p>基于workerman撸了个比较好性能的轻量级php框架。已得到官方收录，经实际项目实践。</p>

<p><img src="media/15880420318169/15880421689585.jpg" alt=""/></p>

<p>搭建比较简单，代码里都有示例app</p>

<p><img src="media/15880420318169/15880421212309.jpg" alt=""/></p>

<p>后续更新相关教程。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[绕过微信小程序机审]]></title>
    <link href="http://www.shengsheng.net/15879530916080.html"/>
    <updated>2020-04-27T10:04:51+08:00</updated>
    <id>http://www.shengsheng.net/15879530916080.html</id>
    <content type="html"><![CDATA[
<p>其实小程序都是ecmascript写的，了解一下运行机制，改写一下ast即可。<br/>
例如：静态扫描，静态分析，都是大概分析出结果。</p>

<h1 id="toc_0">何为ast</h1>

<p>示例代码：<br/>
<code><br/>
var a = 1;<br/>
</code><br/>
ast分析网站：<br/>
<a href="https://astexplorer.net/">https://astexplorer.net/</a></p>

<pre><code class="language-text">{
  &quot;type&quot;: &quot;File&quot;,
  &quot;start&quot;: 0,
  &quot;end&quot;: 10,
  &quot;loc&quot;: {
    &quot;start&quot;: {
      &quot;line&quot;: 1,
      &quot;column&quot;: 0
    },
    &quot;end&quot;: {
      &quot;line&quot;: 1,
      &quot;column&quot;: 10
    }
  },
  &quot;errors&quot;: [],
  &quot;program&quot;: {
    &quot;type&quot;: &quot;Program&quot;,
    &quot;start&quot;: 0,
    &quot;end&quot;: 10,
    &quot;loc&quot;: {
      &quot;start&quot;: {
        &quot;line&quot;: 1,
        &quot;column&quot;: 0
      },
      &quot;end&quot;: {
        &quot;line&quot;: 1,
        &quot;column&quot;: 10
      }
    },
    &quot;sourceType&quot;: &quot;module&quot;,
    &quot;interpreter&quot;: null,
    &quot;body&quot;: [
      {
        &quot;type&quot;: &quot;VariableDeclaration&quot;,
        &quot;start&quot;: 0,
        &quot;end&quot;: 10,
        &quot;loc&quot;: {
          &quot;start&quot;: {
            &quot;line&quot;: 1,
            &quot;column&quot;: 0
          },
          &quot;end&quot;: {
            &quot;line&quot;: 1,
            &quot;column&quot;: 10
          }
        },
        &quot;declarations&quot;: [
          {
            &quot;type&quot;: &quot;VariableDeclarator&quot;,
            &quot;start&quot;: 4,
            &quot;end&quot;: 9,
            &quot;loc&quot;: {
              &quot;start&quot;: {
                &quot;line&quot;: 1,
                &quot;column&quot;: 4
              },
              &quot;end&quot;: {
                &quot;line&quot;: 1,
                &quot;column&quot;: 9
              }
            },
            &quot;id&quot;: {
              &quot;type&quot;: &quot;Identifier&quot;,
              &quot;start&quot;: 4,
              &quot;end&quot;: 5,
              &quot;loc&quot;: {
                &quot;start&quot;: {
                  &quot;line&quot;: 1,
                  &quot;column&quot;: 4
                },
                &quot;end&quot;: {
                  &quot;line&quot;: 1,
                  &quot;column&quot;: 5
                },
                &quot;identifierName&quot;: &quot;a&quot;
              },
              &quot;name&quot;: &quot;a&quot;
            },
            &quot;init&quot;: {
              &quot;type&quot;: &quot;NumericLiteral&quot;,
              &quot;start&quot;: 8,
              &quot;end&quot;: 9,
              &quot;loc&quot;: {
                &quot;start&quot;: {
                  &quot;line&quot;: 1,
                  &quot;column&quot;: 8
                },
                &quot;end&quot;: {
                  &quot;line&quot;: 1,
                  &quot;column&quot;: 9
                }
              },
              &quot;extra&quot;: {
                &quot;rawValue&quot;: 1,
                &quot;raw&quot;: &quot;1&quot;
              },
              &quot;value&quot;: 1
            }
          }
        ],
        &quot;kind&quot;: &quot;var&quot;
      }
    ],
    &quot;directives&quot;: []
  },
  &quot;comments&quot;: []
}
</code></pre>

<p>即可分析出相关运行结构</p>

<h1 id="toc_1">改写ast工具</h1>

<ol>
<li><p>est家族<br/>
const esprima = require(&quot;esprima&quot;);<br/>
const estraverse = require(&quot;estraverse&quot;);<br/>
const escodegen = require(&quot;escodegen&quot;);<br/>
const escope = require(&#39;escope&#39;);</p></li>
<li><p>acorn<br/>
const acorn = require(&quot;acorn&quot;);</p></li>
<li><p>recast解析器，可另选择ast<br/>
const recast = require(&quot;recast&quot;);</p></li>
<li><p>babel-parser babel家族<br/>
const babel = require(&#39;@babel/parser&#39;);<br/>
const babeltraverse = require(&#39;@babel/traverse&#39;).default;<br/>
const t = require(&#39;@babel/types&#39;);<br/>
const generate = require(&#39;@babel/generator&#39;).default;<br/>
const template = require(&#39;@babel/template&#39;).default;</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php读写大的json文件]]></title>
    <link href="http://www.shengsheng.net/15877987592934.html"/>
    <updated>2020-04-25T15:12:39+08:00</updated>
    <id>http://www.shengsheng.net/15877987592934.html</id>
    <content type="html"><![CDATA[
<p>用js生成了个大的ast文件，内容为json格式，打算输出给php处理<br/>
由于内存用得很满，所以一直解析不了大json,大概大概150MB。</p>

<h1 id="toc_0">使用php读取文件的方式</h1>

<ol>
<li>file_get_contents(); <br/>
直接读取文件到内存，大文件使不得</li>
<li>file<br/>
读取文件内容，并将内容按行成数组。</li>
<li>fopen<br/>
按流的方式读取</li>
</ol>

<h1 id="toc_1">使用php开源组件</h1>

<p><img src="media/15877987592934/15877989637144.jpg" alt=""/><br/>
最后还是崩在内存上了。</p>

<h1 id="toc_2">寻找大神的帮助</h1>

<p>最后网友说你不用输出json格式啊，输出xml或二进制，再反解释不就行了。<br/>
前提是只能输出json格式呢？嘿嘿<br/>
最后还得使用node.js来解析，不过node.js解析大json还是快，而且内存占用也不晓得太多。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cors跨域失败的问题]]></title>
    <link href="http://www.shengsheng.net/15877943484342.html"/>
    <updated>2020-04-25T13:59:08+08:00</updated>
    <id>http://www.shengsheng.net/15877943484342.html</id>
    <content type="html"><![CDATA[
<p>通常前后端分离或某些跨域请求，我们会用到cors来控制<br/>
以下是php代码示例，nginx、java等其它都可以实现</p>

<pre><code class="language-text">header(&#39;Access-Control-Allow-Origin: *&#39;);  
header(&#39;Access-Control-Allow-Credentials: true&#39;); //是否允许后续请求携带认证信息（cookies）,该值只能是true,否则不返回
header(&#39;Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS&#39;); //允许的请求类型
header(&quot;Access-Control-Allow-Headers: Accept,AUTHORIZATION,DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&quot;); 
header(&quot;Access-Control-Allow-Headers: *&quot;);
</code></pre>

<h1 id="toc_0">问题</h1>

<p>在搭建的过程中，会遇到失效的问题。<br/>
查看了一下<br/>
<code><br/>
Access-Control-Allow-Origin: *<br/>
</code><br/>
设置为*即允许所有，但登录成功之后获取信息有错。<br/>
<img src="media/15877943484342/15877944590386.jpg" alt=""/></p>

<p>改变一下Access-Control-Allow-Origin测试<br/>
<code><br/>
Access-Control-Allow-Origin: http://test<br/>
</code><br/>
<img src="media/15877943484342/15877945540038.jpg" alt=""/><br/>
发现不是Access-Control-Allow-Origin的问题。</p>

<p>使用Charles抓包查看一下<br/>
<img src="media/15877943484342/15877974328399.jpg" alt=""/></p>

<p>每次请求cors前都有个OPTIONS方法，里面没有任何的参数内容<br/>
<img src="media/15877943484342/15877975157214.jpg" alt=""/><br/>
由于框架每次都会验证一下jwt权限，遇到没内容直接返回401状态码。</p>

<p><img src="media/15877943484342/15877977625055.jpg" alt=""/></p>

<p>改写一下代码即可。</p>

<h1 id="toc_1">结论</h1>

<p>查阅相关资料，得出如下提醒：<br/>
跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）</p>

<h1 id="toc_2">其它</h1>

<h3 id="toc_3">怎样避免CORS跨域发出OPTIONS请求？</h3>

<p>// 后端设置，2592000，单位秒，也就是30天，如果是一天，就是86400<br/>
response.addHeader( &quot;Access-Control-Max-Age&quot;, &quot;2592000&quot; )<br/>
注意，后端只需要处理OPTIONS请求，不要改正常的GET、POST请求。</p>

<h3 id="toc_4">cors漏洞</h3>

<p><a href="https://www.freebuf.com/column/194652.html">https://www.freebuf.com/column/194652.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docker发布hub过程]]></title>
    <link href="http://www.shengsheng.net/15877286658619.html"/>
    <updated>2020-04-24T19:44:25+08:00</updated>
    <id>http://www.shengsheng.net/15877286658619.html</id>
    <content type="html"><![CDATA[
<p>其实不少人会制作docker镜像，但重新pull的时候，在本地没镜像，环境搭起来就浪费不少时间了，所以把自己常用的镜像推送到云端是比较有必要的。</p>

<h1 id="toc_0">推送hub</h1>

<p>docker官方提供的hub地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a><br/>
没账号的先在上面申请好账号哈。hub.docker的账号注册就略过啦。<sup>_^</sup></p>

<p><img src="media/15877286658619/15877288006092.jpg" alt=""/></p>

<p>注册好之后，有个创建仓库的按钮。<br/>
进入容器，修改好容之后<br/>
把容器提交到镜像<br/>
<code><br/>
docker commit container [repository:tag]<br/>
</code><br/>
<img src="media/15877286658619/15877290189087.jpg" alt=""/><br/>
这时候内容已经更新到本地的镜像指定的tag中了</p>

<p><code><br/>
docker push show/php:7.2.6<br/>
</code><br/>
输入相关账号密码，即可提交到云端</p>

<p>去另外一台电脑上愉快的docker pull 自己的镜像吧。</p>

<h1 id="toc_1">后记</h1>

<p>理解好微服务，就知道使用docker是如何的方便的啦。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打印nginx变量来调试相关信息]]></title>
    <link href="http://www.shengsheng.net/15877280381303.html"/>
    <updated>2020-04-24T19:33:58+08:00</updated>
    <id>http://www.shengsheng.net/15877280381303.html</id>
    <content type="html"><![CDATA[
<p>实际有时候nginx服务器有很多变量我们都不清楚conf的时候配置得怎么样，实际可以安装nginx的module：echo模块来打印一下</p>

<p>通常我们的配置，登录fastcgi</p>

<pre><code class="language-text">
fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;

fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;
fastcgi_param  REQUEST_URI        $request_uri;
fastcgi_param  DOCUMENT_URI       $document_uri;
fastcgi_param  DOCUMENT_ROOT      $document_root;
fastcgi_param  SERVER_PROTOCOL    $server_protocol;
fastcgi_param  REQUEST_SCHEME     $scheme;
fastcgi_param  HTTPS              $https if_not_empty;

fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;

fastcgi_param  REMOTE_ADDR        $remote_addr;
fastcgi_param  REMOTE_PORT        $remote_port;
fastcgi_param  SERVER_ADDR        $server_addr;
fastcgi_param  SERVER_PORT        $server_port;
fastcgi_param  SERVER_NAME        $server_name;

# PHP only, required if PHP was built with --enable-force-cgi-redirect
fastcgi_param  REDIRECT_STATUS    200;
</code></pre>

<p>我们想打印一下定义的变量，最快捷的方法，使用nginx输出一下即可</p>

<h1 id="toc_0">如下</h1>

<pre><code class="language-text">server {
    server_name 127.0.0.1;
    location /http{
        expires -1;
        
        echo [request_filename:\t$request_filename];
        echo [request_method:\t$request_method];
        echo [request_body_file:\t$request_body_file];
        
        echo [http_host:\t$http_host];
        echo [remote_addr:\t$remote_addr];
        echo [time_local:\t$time_local];
        echo [request:\t$request];
        echo [xrequest:\t$xrequest];
        echo [http_referer:\t$http_referer];
        echo [http_user_agent:\t$http_user_agent];
        echo [status:\t$status];
        echo [request_time:\t$request_time];
        echo [http_x_forwarded_for:\t$http_x_forwarded_for];
        echo [request_body:\t$request_body];
        
        #return 200 &quot;abc&quot;;
        
    }
}
</code></pre>

<h1 id="toc_1">其它</h1>

<p>顺便提一下nginx的监近模块，如果你的服务使用的是nginx,不访用来定时监控一下</p>

<h2 id="toc_2">ngx_http_stub_status_module</h2>

<p>stub_status</p>

<h2 id="toc_3">ngx_google_perftools_module</h2>

<p>gperftools定位性能问题</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell常用复习]]></title>
    <link href="http://www.shengsheng.net/15876399053304.html"/>
    <updated>2020-04-23T19:05:05+08:00</updated>
    <id>http://www.shengsheng.net/15876399053304.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">常用快捷键</h2>

<ul>
<li>Ctrl + L：清除屏幕并将当前行移到页面顶部。</li>
<li>Ctrl + U：从光标位置删除到行首。</li>
<li>Ctrl + K：从光标位置删除到行尾。</li>
<li>Ctrl + a：移到行首。</li>
<li>Ctrl + b：向行首移动一个字符，与左箭头作用相同。</li>
<li>Ctrl + e：移到行尾。</li>
<li>Ctrl + f：向行尾移动一个字符，与右箭头作用相同。</li>
<li>Alt + f：移动到当前单词的词尾。</li>
<li>Alt + b：移动到当前单词的词首。</li>
<li>Ctrl + d：删除光标位置的字符（delete）。</li>
<li>Ctrl + w：删除光标前面的单词。</li>
<li>Ctrl + t：光标位置的字符与它前面一位的字符交换位置（transpose）。</li>
<li>Alt + t：光标位置的词与它前面一位的词交换位置（transpose）。</li>
<li>Alt + l：将光标位置至词尾转为小写（lowercase）。</li>
<li>Alt + u：将光标位置至词尾转为大写（uppercase）。</li>
<li>使用Ctrl + d的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</li>
</ul>

<h3 id="toc_1">剪切和粘贴快捷键如下。</h3>

<ul>
<li>Ctrl + k：剪切光标位置到行尾的文本。</li>
<li>Ctrl + u：剪切光标位置到行首的文本。</li>
<li>Alt + d：剪切光标位置到词尾的文本。</li>
<li>Alt + Backspace：剪切光标位置到词首的文本。</li>
<li><p>Ctrl + y：在光标位置粘贴文本。</p></li>
<li><p>Ctrl + p：显示上一个命令，与向上箭头效果相同（previous）。</p></li>
<li><p>Ctrl + n：显示下一个命令，与向下箭头效果相同（next）。</p></li>
<li><p>Alt + &lt;：显示第一个命令。</p></li>
<li><p>Alt + &gt;：显示最后一个命令，即当前的命令。</p></li>
<li><p>Ctrl + o：执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</p></li>
</ul>

<h3 id="toc_2">感叹号!的快捷键如下。</h3>

<ul>
<li>!!：执行上一个命令。</li>
<li>!n：执行历史文件里面行号为n的命令。</li>
<li>!-n：执行当前命令之前n条的命令。</li>
<li>!string：执行最近一个以指定字符串string开头的命令。</li>
<li>!?string：执行最近一条包含字符串string的命令。</li>
<li><sup>string1<sup>string2：执行最近一条包含string1的命令，将其替换成string2。</sup></sup></li>
</ul>

<h2 id="toc_3">()号</h2>

<p>\((...)可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。<br/>
\)((...))可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。</p>

<p>\( myvar=USER<br/>
\) echo ${!myvar}<br/>
ruanyf</p>

<p>$?为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是0，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p>

<p>字符串截数<br/>
1.最近 2.最贪婪<br/>
从前往后</p>

<pre><code class="language-text">#
##
</code></pre>

<p>从后往前</p>

<pre><code class="language-text">%
%%
</code></pre>

<h2 id="toc_4">for与while</h2>

<h3 id="toc_5">for</h3>

<p>类型js里面的for in<br/>
for i in &quot;\(@&quot;; do<br/>
  echo \)i<br/>
done</p>

<h3 id="toc_6">while</h3>

<p>while getopts &#39;lha:&#39; OPTION; do<br/>
  case &quot;$OPTION&quot; in<br/>
    l)<br/>
      echo &quot;linuxconfig&quot;<br/>
      ;;</p>

<pre><code class="language-text">h)
  echo &quot;h stands for h&quot;
  ;;

a)
  avalue=&quot;$OPTARG&quot;
  echo &quot;The value provided is $OPTARG&quot;
  ;;
?)
  echo &quot;script usage: $(basename $0) [-l] [-h] [-a somevalue]&quot; &gt;&amp;2
  exit 1
  ;;
</code></pre>

<p>esac<br/>
done<br/>
shift &quot;\(((\)OPTIND - 1))&quot;</p>

<h2 id="toc_7">命令的参数</h2>

<p>bash的-x参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。<br/>
-n：不运行脚本，只检查是否有语法错误。<br/>
-v：输出每一行语句运行结果前，会先输出该行语句。<br/>
-x：每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql导出指定条数的数据]]></title>
    <link href="http://www.shengsheng.net/15875516508594.html"/>
    <updated>2020-04-22T18:34:10+08:00</updated>
    <id>http://www.shengsheng.net/15875516508594.html</id>
    <content type="html"><![CDATA[
<p>平时习惯了使用navicat for mysql来复制数据到本地数据库</p>

<p><img src="media/15875516508594/15875517328254.jpg" alt=""/></p>

<p>数据多的时候，复制会很慢，而且某些hash的索引会变成btree。<br/>
为了使本地测试机有线上部分数据库，故使用mysqldump导出指定条数。</p>

<p><code><br/>
mysqldump  --column-statistics=0 --host=127.0.0.1 --port=3306  -uroot -proot dbname --where=&quot; 1=1 limit 100&quot;&gt; db.sql <br/>
</code></p>

<p>例导出指定库，每个表格前100条数据，可以使用 --where参数，limit 100条</p>

<p>mysqldump导出的时候会锁表，还有比较好的工具，后更新。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[免费域名证书的申请]]></title>
    <link href="http://www.shengsheng.net/15874683984714.html"/>
    <updated>2020-04-21T19:26:38+08:00</updated>
    <id>http://www.shengsheng.net/15874683984714.html</id>
    <content type="html"><![CDATA[
<p>对于ssl，我们经常会用到，但对于我们这种贫穷人家，只能通过各种方式来获取免费的ssl。<br/>
ssl证书好处，这里不多说，有疑问请度娘。<br/>
比较折腾的是，免费的都不支持泛解析。</p>

<h1 id="toc_0">测评</h1>

<h2 id="toc_1">certbot</h2>

<p>业内比较大的免费证书机构是certbot,<br/>
certbot支持强度高，但限制也大，需域名先进行解析才能使用。<br/>
<img src="media/15874683984714/15874686027554.jpg" alt=""/></p>

<h2 id="toc_2">freessl.cn</h2>

<p>操作简单，快捷，打开freessl.cn注册邮箱即可。<br/>
<img src="media/15874683984714/15874687480297.jpg" alt=""/></p>

<p>域名认证方面，使用txt作为解析，解析成功即可获得证书。<br/>
需注意，申请好之后，要保存好私钥。</p>

<h2 id="toc_3">其它</h2>

<h3 id="toc_4">腾讯云导入证书</h3>

<p><img src="media/15874683984714/15874698281428.jpg" alt=""/><br/>
下载之后有两个文件<br/>
private.key为私钥<br/>
full_chain.pem为公钥</p>

<p><img src="media/15874683984714/15874699416978.jpg" alt=""/></p>

<p>复制私钥的内容到私钥栏<br/>
full_chain.pem复制上半部分即可<br/>
<img src="media/15874683984714/15874700104254.jpg" alt=""/></p>

<h3 id="toc_5">证书格式转换:</h3>

<p><a href="https://cloud.tencent.com/document/product/228/41686">https://cloud.tencent.com/document/product/228/41686</a></p>

<h3 id="toc_6">p12,pem,key</h3>

<p>这部分度娘了解一下证书原理即可。</p>

<h2 id="toc_7">结伦</h2>

<p>相对来讲，本人较喜欢freessl.cn，不用解析ip即可申请。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux 2.常用性能工具]]></title>
    <link href="http://www.shengsheng.net/15870471732408.html"/>
    <updated>2020-04-16T22:26:13+08:00</updated>
    <id>http://www.shengsheng.net/15870471732408.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">cpu性能工具</h2>

<table>
<thead>
<tr>
<th>性能指标</th>
<th>性能工具</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>平均负载</td>
<td>Uptime top /proc/loadavg</td>
<td>uptime最简单；top提供了更全的指标；/proc/loadavg常用于监控系统</td>
</tr>
<tr>
<td>系统CPU使用率</td>
<td>Vmstat mpstat top sar /proc/stat</td>
<td>Top vmstat mpstat只能动态查看，而sar还可以记录历史数据；/proc/stat是其他性能工具的数据来源，也常用于监控</td>
</tr>
<tr>
<td>进程CPU使用率</td>
<td>top ps pidstat htop atop</td>
<td>top和ps可以按CPU使用率给进程排序，而pidstat只显示实际用了CPU的进程；htop和atop以不同颜色显示更直观</td>
</tr>
<tr>
<td>进程上下文切换</td>
<td>vmstat</td>
<td>除了上下文切换次数，还提供运行状态和不可中断状态进程的数量</td>
</tr>
<tr>
<td>进程上下文切换</td>
<td>pidstat</td>
<td>注意加上-w选项</td>
</tr>
<tr>
<td>软中断</td>
<td>top mpstat /proc/softirqs</td>
<td>top提供软中断CPU使用率，而/proc/softirqs和mpstat提供了各种软中断在每个cpu上的运行次数</td>
</tr>
<tr>
<td>硬中断</td>
<td>Vmstat /proc/interrupts</td>
<td>vmstat提供总的中断次数，而/proc/interrupts提供各种中断在每个cpu上运行的累积次数</td>
</tr>
<tr>
<td>网络</td>
<td>dstat sar tcpdump</td>
<td>dstat sar提供总的网络接收和发送情况，而tcpdump则是动态抓取天上在进行的网络通讯</td>
</tr>
<tr>
<td>I/O</td>
<td>dstat sar</td>
<td>dstat和sar都提供了I/O的整体情况</td>
</tr>
<tr>
<td>CPU缓存</td>
<td>perf</td>
<td>使用perf stat子命令</td>
</tr>
<tr>
<td>CPU数</td>
<td>lscpu /proc/cpuinfo</td>
<td>lscpu更直观</td>
</tr>
<tr>
<td>事件剖析</td>
<td>Perf \ 火焰图 execsnoop</td>
<td>perf和火焰图用来分析热点函数以及调用栈，execsnoop用来监测短时进程</td>
</tr>
<tr>
<td>动态追踪</td>
<td>ftrace bcc systemtap</td>
<td>ftrace用于跟踪内核函数调用栈，而bcc和systemtap则用于跟踪内核或应用程序的执行过程（注意bcc要求内核版本&gt;=4.1)</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">内存性能工具</h2>

<table>
<thead>
<tr>
<th>性能指标</th>
<th>性能工具</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>系统已用、可用、剩余内存</td>
<td>free vmstat sar /proc/meminfo</td>
<td>free最为简单，而vmstat sar更为全面；/proc/meminfo是其他工具的数据来源，也常用于监控系统中</td>
</tr>
<tr>
<td>进程虚拟内存、常驻内存、共享内存</td>
<td>ps top pidstat /proc/pid/stat /proc/pid/status</td>
<td>ps和top最简单，而pidstat则需要加上-r选项；/proc/pid/stat和/proc/pid/status是其他工具的数据来源，也常用于监控系统中</td>
</tr>
<tr>
<td>进程内存分布</td>
<td>Pmap /proc/pid/maps</td>
<td>/proc/pid/maps是pmap的数据来源</td>
</tr>
<tr>
<td>进程swap换出内存</td>
<td>top /proc/pid/status</td>
<td>/proc/pid/status是top的数据来源</td>
</tr>
<tr>
<td>进程缺页异常</td>
<td>ps top pidstat</td>
<td>注意给pidstat 加上-r选项</td>
</tr>
<tr>
<td>系统换页情况</td>
<td>sar</td>
<td>注意加上-B选项</td>
</tr>
<tr>
<td>缓存 / 缓冲区使用量</td>
<td>free vmstat sar cachestat</td>
<td>vmstat最常用，而cachestat需要安装bcc</td>
</tr>
<tr>
<td>缓存 / 缓冲区命中率</td>
<td>cachetop</td>
<td>需要安装bcc</td>
</tr>
<tr>
<td>SWAP已使用空间和剩余空间</td>
<td>Free sar</td>
<td>free最为简单，而sar还可以记录历史</td>
</tr>
<tr>
<td>swap换入换出</td>
<td>vmsata sar</td>
<td>vmstat最为简单，而sar还可以记录历史</td>
</tr>
<tr>
<td>内存泄露检测</td>
<td>Memleak valgrind</td>
<td>memleak需要安装bcc，valgrind还可以在旧版本（如3.x）内核中使用</td>
</tr>
<tr>
<td>指定文件的缓存大小</td>
<td>pcstat</td>
<td>需要从源码下载安装</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">文件系统和磁盘I/O性能工具</h2>

<table>
<thead>
<tr>
<th style="text-align: center">性能指标</th>
<th style="text-align: center">性能工具</th>
<th style="text-align: center">说明</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">文件系统空间容量、使用量以及剩余空间</td>
<td style="text-align: center">df</td>
<td style="text-align: center">详细文档可以执行info coreutils ‘df invocation&#39;命令查询</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">索引节点容量、使用量以及剩余量</td>
<td style="text-align: center">df</td>
<td style="text-align: center">注意加上-i选项</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">页缓存和可回收Slab缓存</td>
<td style="text-align: center">/proc/meminfo  sar vmstat</td>
<td style="text-align: center">注意sar需要加上-r选项，而/proc/meminfo是其他工具的数据来源，也常用于监控</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">缓冲区</td>
<td style="text-align: center">同上</td>
<td style="text-align: center">同上</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">目录项，索引节点以及文件系统的缓存</td>
<td style="text-align: center">/proc/slabinfo  slabtop</td>
<td style="text-align: center">slabtop更直观，而/proc/slabinfo常用于监控</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">磁盘I/O使用率，iops，吞吐量，响应时间，I/O平均大小以有等待队列长度</td>
<td style="text-align: center">iostat sar dstat /proc/diskstats</td>
<td style="text-align: center">iostat是常用，注意使用iostat -d -x或sar -d选项；/proc/diskstat则是其他工具数据来源，也常用于监控</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">进程I/O大小以及I/O延迟</td>
<td style="text-align: center">pidstat iotop</td>
<td style="text-align: center">注意使用pidstat -d选项</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">块设备I/O事件跟踪</td>
<td style="text-align: center">bltrace</td>
<td style="text-align: center">需要跟blkparse配合使用，比如bltrace -d /dev/sda -o                             bltrace -i</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">进程I/O系统调用跟踪</td>
<td style="text-align: center">strace perf trace</td>
<td style="text-align: center">strace只可以跟踪单个进程，而perf trace还可以跟踪所有进程的系统调用</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">进程块设备I/O大小跟踪</td>
<td style="text-align: center">biosnoop biotop</td>
<td style="text-align: center">安装bcc</td>
<td></td>
</tr>
<tr>
<td style="text-align: center">动态追踪</td>
<td style="text-align: center">ftrace bcc systemtap</td>
<td style="text-align: center">ftrace用户跟踪内核函数调用栈，而bcc和systemtap则用于跟踪内核或应用程序的执行过程（注意bcc要求内核版本&gt;=4.1)</td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="toc_3">网络性能工具</h2>

<table>
<thead>
<tr>
<th>性能指标</th>
<th>性能工具</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>吞吐量（BPS）</td>
<td>sar nethogs iftop /proc/net/dev</td>
<td>分别可以查看网络接口，进程以及IP地址的网络吞吐量；/proc/net/dev常用于监控</td>
</tr>
<tr>
<td>吞吐量（PPS）</td>
<td>sar /proc/net/dev</td>
<td>注意使用sar -n DEV选项</td>
</tr>
<tr>
<td>网络连接数</td>
<td>netstat ss</td>
<td>ss速度更快</td>
</tr>
<tr>
<td>网络错误数</td>
<td>netsta sar</td>
<td>注意使用netstat -s或者sar -n EDEV/EIP选项</td>
</tr>
<tr>
<td>网络延迟</td>
<td>Ping hping3</td>
<td>ping基于ICMP 而hping3则基于TCP协议</td>
</tr>
<tr>
<td>连接跟踪数</td>
<td>conntrack /proc/sys/net/netfilter/nf_conntrack_count  /proc/sys/net/netfilter/nf_conntrack_max</td>
<td>Conntrack可用来查看所有连接跟踪的相关信息 Nf_conntrack_count只是连接跟踪的数量，而nf_conntrack_max则限制了总的连接跟踪数量</td>
</tr>
<tr>
<td>路由</td>
<td>mtr traceroute route</td>
<td>route用于查询路由表，而mtr和traceroute则用来排查和定位网络链路中的路由问题</td>
</tr>
<tr>
<td>DNS</td>
<td>dig nslookup</td>
<td>用于排查DNS解析的问题</td>
</tr>
<tr>
<td>防火墙和NAT</td>
<td>iptables</td>
<td>用于排查防火墙及NAT的问题</td>
</tr>
<tr>
<td>网卡选项</td>
<td>ethtool</td>
<td>用于查看和配置网络接口的项目选项</td>
</tr>
<tr>
<td>网络抓包</td>
<td>tcpdump wireshark</td>
<td>通常在服务器中使用tcpdump抓包后再复制出来用wireshark的图形界面分析</td>
</tr>
<tr>
<td>动态追踪</td>
<td>Ftrace bcc systemtap</td>
<td>ftrace用于跟踪内核函数调用栈，而bcc和systemtap则用于跟踪或应用程序的执行过程（注意bcc要求内核&gt;=4.1)</td>
</tr>
</tbody>
</table>

<h1 id="toc_4">总结</h1>

<p>记录一下常用的linux工具</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux 1.常用性能指标及USE法分类]]></title>
    <link href="http://www.shengsheng.net/15869595689820.html"/>
    <updated>2020-04-15T22:06:08+08:00</updated>
    <id>http://www.shengsheng.net/15869595689820.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">CPU 性能指标</h1>

<h2 id="toc_1">cpu使用率</h2>

<ul>
<li>用户cpu</li>
<li>系统cpu</li>
<li>IOWAIT</li>
<li>软中断</li>
<li>硬中断</li>
<li>窃取cpu</li>
<li>客户cpu</li>
</ul>

<h2 id="toc_2">上下文切换</h2>

<ul>
<li>自愿上下文切换</li>
<li>非自愿上下文切换</li>
</ul>

<h2 id="toc_3">平均负载</h2>

<h2 id="toc_4">cpu缓存命中率</h2>

<h1 id="toc_5">内存性能指标</h1>

<h2 id="toc_6">系统内存指标</h2>

<ul>
<li>已用内存</li>
<li>剩余内存</li>
<li>可用内存</li>
<li>缺页异常</li>
<li>     主缺页异常</li>
<li>     次缺页异常</li>
<li>缓存/ 缓冲区</li>
<li>     使用量</li>
<li>     命中率</li>
<li>Slabs</li>
</ul>

<h2 id="toc_7">进程内存指标</h2>

<ul>
<li>虚拟内存（VSS）</li>
<li>常驻内存（RSS）</li>
<li>按比例分配共享内存后的物理内存(PSS）</li>
<li>独占内存（USS)</li>
<li>共享内存</li>
<li>SWAP内存</li>
<li>缺页异常
<ol>
<li>主缺页异常</li>
<li>次缺页异常</li>
</ol></li>
</ul>

<h2 id="toc_8">SWAP</h2>

<p>已用空间<br/>
剩余空间<br/>
换入速度<br/>
换出速度</p>

<h1 id="toc_9">常用指标分类（USE法）</h1>

<table>
<thead>
<tr>
<th>资源</th>
<th>类型</th>
<th>性能指标</th>
</tr>
</thead>

<tbody>
<tr>
<td>CPU</td>
<td>使用率</td>
<td>CPU使用率</td>
</tr>
<tr>
<td>CPU</td>
<td>饱和度</td>
<td>运行队列长度或平均负载</td>
</tr>
<tr>
<td>CPU</td>
<td>错误数</td>
<td>硬件CPU错误数</td>
</tr>
<tr>
<td>内存</td>
<td>使用率</td>
<td>已用内存百分比或SWAP用量百分比</td>
</tr>
<tr>
<td>内存</td>
<td>饱和度</td>
<td>内存换页量</td>
</tr>
<tr>
<td>内存</td>
<td>错误数</td>
<td>内存分配失败或OOM</td>
</tr>
<tr>
<td>存储设备I/O</td>
<td>使用率</td>
<td>设备I/O时间百分比</td>
</tr>
<tr>
<td>存储设备I/O</td>
<td>饱和度</td>
<td>等待队列长度或延迟</td>
</tr>
<tr>
<td>存储设备I/O</td>
<td>错误数</td>
<td>I/O错误数</td>
</tr>
<tr>
<td>文件系统</td>
<td>使用率</td>
<td>已用容量百分比</td>
</tr>
<tr>
<td>文件系统</td>
<td>错误数</td>
<td>文件读写错误数</td>
</tr>
<tr>
<td>网络</td>
<td>使用率</td>
<td>带宽使用率</td>
</tr>
<tr>
<td>网络</td>
<td>饱和度</td>
<td>重传报文数</td>
</tr>
<tr>
<td>网络</td>
<td>错误数</td>
<td>网卡收发错误数、丢包数</td>
</tr>
<tr>
<td>文件描述符</td>
<td>使用率</td>
<td>已用文件描述符数百分比</td>
</tr>
<tr>
<td>连接跟踪</td>
<td>使用率</td>
<td>已用连接跟踪数百分比</td>
</tr>
<tr>
<td>连接数</td>
<td>饱和度</td>
<td>TIMEWAIT状态连接数</td>
</tr>
</tbody>
</table>

<h1 id="toc_10">I/O性能指标</h1>

<h2 id="toc_11">文件系统</h2>

<p>存储空间容量、使用量以及剩余空间<br/>
索引节点容量、使用量以及剩余量<br/>
缓存<br/>
    页缓存<br/>
    目录项缓存<br/>
    索引节点缓存<br/>
    具体文件系统缓存（如ext4的缓存）<br/>
IOPS（文件I/O）<br/>
响应时间（延迟）<br/>
吞吐量（B/S）</p>

<h2 id="toc_12">磁盘</h2>

<p>使用率<br/>
IOPS<br/>
吞吐量（B/S）<br/>
响应时间（延迟）<br/>
缓冲区<br/>
相关因素<br/>
    读写类型（如顺序还是随机）<br/>
    读写比例<br/>
    读写大小<br/>
    存储类型（如RAID级别、本地还是网络）</p>

<h1 id="toc_13">网络性能指标</h1>

<h2 id="toc_14">应用层</h2>

<p>QPS（每秒请求数）<br/>
套接字缓冲区大小<br/>
DNS解析延迟<br/>
响应时间<br/>
错误数</p>

<h2 id="toc_15">传输层</h2>

<p>tcp连接数<br/>
    全连接<br/>
    半连接<br/>
    TIMEWAIT<br/>
连接跟踪数<br/>
重传数<br/>
丢包数<br/>
延迟</p>

<h2 id="toc_16">网络层</h2>

<p>丢包数<br/>
TTL<br/>
拆包</p>

<h2 id="toc_17">链路层</h2>

<p>PPS（每秒网络帧数）<br/>
BPS（每秒字节数）<br/>
丢包数<br/>
错误数</p>

<h1 id="toc_18">总结</h1>

<p>把极客时间LINUX手册变成MD给大家查看  <sup>_^</sup><br/>
<img src="media/15869595689820/15869605756641.jpg" alt=""/></p>

]]></content>
  </entry>
  
</feed>
